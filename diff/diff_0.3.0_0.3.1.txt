diff --git a/.gitattributes b/.gitattributes
new file mode 100644
index 0000000..dbc1e6d
--- /dev/null
+++ b/.gitattributes
@@ -0,0 +1,54 @@
+# Auto detect text files and perform LF normalization
+* text=auto
+
+# Custom for Visual Studio
+*.cs     diff=csharp
+*.sln    merge=union
+*.csproj merge=union
+*.vbproj merge=union
+*.fsproj merge=union
+*.dbproj merge=union
+
+# Standard to msysgit
+*.doc	 diff=astextplain
+*.DOC	 diff=astextplain
+*.docx diff=astextplain
+*.DOCX diff=astextplain
+*.dot  diff=astextplain
+*.DOT  diff=astextplain
+*.pdf  diff=astextplain
+*.PDF	 diff=astextplain
+*.rtf	 diff=astextplain
+*.RTF	 diff=astextplain
+
+# Project specific files
+*.html  text
+*.xhtml text
+*.xul   text
+*.dtd   text
+*.jsm   text
+*.js    text
+*.css   text
+*.rdf   text
+*.def   text
+*.txt   text
+*.c     text
+*.cc    text
+*.cpp   text
+*.h     text
+*.hpp   text
+*.cs    text
+*.bat   text
+*.properties text
+*.manifest text
+
+*.sln             text eol=crlf
+*.vcxproj         text eol=crlf
+*.vcxproj.filters text eol=crlf
+
+*.jpg   binary
+*.png   binary
+*.gif   binary
+*.exe   binary
+*.dll   binary
+*.xpi   binary
diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..ffd5213
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,104 @@
+#################
+## Visual Studio
+#################
+
+## Ignore Visual Studio temporary files, build results, and
+## files generated by popular Visual Studio add-ons.
+
+# User-specific files
+*.suo
+*.user
+*.sln.docstates
+
+# Build results
+[Dd]ebug/
+[Rr]elease/
+*_i.c
+*_p.c
+*.ilk
+*.meta
+*.obj
+*.pch
+*.pdb
+*.pgc
+*.pgd
+*.rsp
+*.sbr
+*.tlb
+*.tli
+*.tlh
+*.tmp
+*.vspscc
+.builds
+*.dotCover
+
+## TODO: If you have NuGet Package Restore enabled, uncomment this
+#packages/
+
+# Visual C++ cache files
+ipch/
+*.aps
+*.ncb
+*.opensdf
+*.sdf
+
+# Visual Studio profiler
+*.psess
+*.vsp
+
+# ReSharper is a .NET coding add-in
+_ReSharper*
+
+# Installshield output folder
+[Ee]xpress
+
+# DocProject is a documentation generator add-in
+DocProject/buildhelp/
+DocProject/Help/*.HxT
+DocProject/Help/*.HxC
+DocProject/Help/*.hhc
+DocProject/Help/*.hhk
+DocProject/Help/*.hhp
+DocProject/Help/Html2
+DocProject/Help/html
+
+# Click-Once directory
+publish
+
+# Others
+[Bb]in
+[Oo]bj
+sql
+TestResults
+*.Cache
+ClientBin
+stylecop.*
+~$*
+*.dbmdl
+Generated_Code #added for RIA/Silverlight projects
+
+# Backup & report files from converting an old project file to a newer
+# Visual Studio version. Backup files are not needed, because we have git ;-)
+_UpgradeReport_Files/
+Backup*/
+UpgradeLog*.XML
+
+
+
+############
+## Windows
+############
+
+# Windows image file caches
+Thumbs.db
+
+# Folder config file
+Desktop.ini
+
+############
+## Project Specific
+############
+/extension/plugins/npfireie*
+/test/
+/fireie*.xpi
+/ReleaseNotes.txt
diff --git a/extension/chrome/content/options2.js b/extension/chrome/content/options2.js
index 2d19403..54f9fde 100644
--- a/extension/chrome/content/options2.js
+++ b/extension/chrome/content/options2.js
@@ -21,6 +21,7 @@ along with Fire-IE.  If not, see <http://www.gnu.org/licenses/>.
 
 Cu.import(baseURL.spec + "AppIntegration.jsm");
 Cu.import(baseURL.spec + "GesturePrefObserver.jsm");
+Cu.import(baseURL.spec + "ABPObserver.jsm");
 
 if (typeof(Options) == "undefined")
 {
@@ -34,7 +35,7 @@ Options.export = function()
   let aCurrent = Options._getAllOptions(false);
   if (aCurrent) Options._saveToFile(aCurrent);
   Options._setAllOptions(aOld);
-}
+};
 
 Options.import = function()
 {
@@ -51,10 +52,10 @@ Options.import = function()
     }
     else
     {
-      alert(Utils.getString("fireie.options.import.error"));
+      Utils.alert(window, Utils.getString("fireie.options.import.error"), Utils.getString("fireie.options.alert.title"));
     }
   }
-}
+};
 
 Options.restoreDefaultSettings = function()
 {
@@ -64,7 +65,7 @@ Options.restoreDefaultSettings = function()
   Options.initDialog();
   Options._setAllOptions(aOld);
   Options.updateApplyButton(true);
-}
+};
 
 // Apply options
 Options.apply = function(quiet)
@@ -98,6 +99,7 @@ Options.apply = function(quiet)
   Prefs.showTooltipText = E("showTooltipText").checked;
   Prefs.showStatusText = E("showStatusText").checked;
   Prefs.forceMGSupport = E("forceMGSupport").checked;
+  Prefs.abpSupportEnabled = E("abpSupportEnabled").checked;
   
   // IE compatibility mode
   let newMode = "ie7mode";
@@ -113,15 +115,24 @@ Options.apply = function(quiet)
     Options.applyIECompatMode();
   }
   
+  // GPU Rendering State
+  let newGPURendering = E("gpuRendering").checked;
+  if (Prefs.gpuRendering != newGPURendering)
+  {
+    requiresRestart = true;
+    Prefs.gpuRendering = newGPURendering;
+    Options.applyGPURenderingState();
+  }
+
   //update UI
   Options.updateApplyButton(false);
 
   //notify of restart requirement
   if (requiresRestart && !quiet)
   {
-    alert(Utils.getString("fireie.options.alert.restart"));
+    Utils.alert(window, Utils.getString("fireie.options.alert.restart"), Utils.getString("fireie.options.alert.title"));
   }
-}
+};
 
 Options.getIECompatMode = function()
 {
@@ -134,7 +145,7 @@ Options.getIECompatMode = function()
   }
   catch (e)
   {
-    Utils.ERROR(e);
+    Utils.LOG("Failed to get IE Compat Mode from registry: " + e);
   }
   finally
   {
@@ -171,7 +182,7 @@ Options.getIECompatMode = function()
   }
   
   Prefs.compatMode = mode;
-}
+};
 
 Options.applyIECompatMode = function()
 {
@@ -213,13 +224,52 @@ Options.applyIECompatMode = function()
   }
   catch (e)
   {
-    Utils.ERROR(e);
+    Utils.ERROR("Failed to write IE Compat Mode into registry: " + e);
   }
   finally
   {
     wrk.close();
   }
-}
+};
+
+Options.getGPURenderingState = function()
+{
+  let wrk = Cc["@mozilla.org/windows-registry-key;1"].createInstance(Ci.nsIWindowsRegKey);
+  let state = false;
+  try
+  {
+    wrk.create(wrk.ROOT_KEY_CURRENT_USER, "SOFTWARE\\Microsoft\\Internet Explorer\\Main\\FeatureControl\\FEATURE_GPU_RENDERING", wrk.ACCESS_READ);
+    state = wrk.readIntValue(AppIntegration.getPluginProcessName()) == 1;
+  }
+  catch (e)
+  {
+    Utils.LOG("Failed to get GPU Rendering State from registry: " + e);
+  }
+  finally
+  {
+    wrk.close();
+  }
+  
+  Prefs.gpuRendering = state;
+};
+
+Options.applyGPURenderingState = function()
+{
+  let wrk = Cc["@mozilla.org/windows-registry-key;1"].createInstance(Ci.nsIWindowsRegKey);
+  try
+  {
+    wrk.create(wrk.ROOT_KEY_CURRENT_USER, "SOFTWARE\\Microsoft\\Internet Explorer\\Main\\FeatureControl\\FEATURE_GPU_RENDERING", wrk.ACCESS_WRITE);
+    wrk.writeIntValue(AppIntegration.getPluginProcessName(), Prefs.gpuRendering ? 1 : 0);
+  }
+  catch (e)
+  {
+    Utils.ERROR("Failed to write GPU Rendering State into registry: " + e);
+  }
+  finally
+  {
+    wrk.close();
+  }
+};
 
 // Get IE's main version number
 Options.getIEMainVersion = function()
@@ -240,19 +290,19 @@ Options.getIEMainVersion = function()
   }
   catch (e)
   {
-    Utils.ERROR(e);
+    Utils.LOG("Failed to get IE version from registry: " + e);
   }
   finally
   {
     wrk.close();
   }
   return version;
-}
+};
 
 Options.updateIEModeTab = function()
 {
   let mainIEVersion = Options.getIEMainVersion();
-  // IE7 or lower does not support compatible modes
+  // IE7 or lower does not support compatible modes and GPU rendering
   if (mainIEVersion < 8)
   {
     return;
@@ -266,18 +316,39 @@ Options.updateIEModeTab = function()
   {
     E("ie9mode-radio").hidden = false;
     E("ie9forced-radio").hidden = false;
+    // IE9+ supports hardware accelerated rendering
+    E("ieFeatures").hidden = false;
+    E("gpuRendering").hidden = false;
   }
   // mainIEVersion >= 8
   E("ie8mode-radio").hidden = false;
   E("ie8forced-radio").hidden = false;
   E("ie7mode-radio").hidden = false;
+  E("iecompat").hidden = false;
   
   E("iemodeNotSupported").hidden = true;
   E("iemodeDescr").hidden = false;
+  
   Options.getIECompatMode();
   let mode = Prefs.compatMode;
   E("iemode").value = mode;
-}
+  
+  Options.getGPURenderingState();
+  E("gpuRendering").checked = Prefs.gpuRendering;
+};
+
+// Update ABP status according to ABPObserver
+Options.updateABPStatus = function()
+{
+  let status = ABPObserver.getStatus();
+  E("abpStatusNotDetected").hidden = (status != ABPStatus.NotDetected);
+  E("abpStatusEnabled").hidden = (status != ABPStatus.Enabled);
+  E("abpStatusDisabled").hidden = (status != ABPStatus.Disabled);
+  E("abpStatusLoading").hidden = (status != ABPStatus.Loading);
+  E("abpStatusLoadFailed").hidden = (status != ABPStatus.LoadFailed);
+  
+  E("abpSupportEnabled").disabled = (status == ABPStatus.NotDetected);
+};
 
 Options.initDialog = function()
 {
@@ -292,6 +363,7 @@ Options.initDialog = function()
   E("showTooltipText").checked = Prefs.showTooltipText;
   E("showStatusText").checked = Prefs.showStatusText;
   E("forceMGSupport").checked = Prefs.forceMGSupport;
+  E("abpSupportEnabled").checked = Prefs.abpSupportEnabled;
 
   // hide "showStatusText" if we don't handle status messages ourselves
   let ifHide = !AppIntegration.shouldShowStatusOurselves();
@@ -308,24 +380,26 @@ Options.initDialog = function()
     E("alreadyEnabledMGSupportLabel").hidden = true;
   }
   
+  Options.updateABPStatus();
+
   // updateStatus
   Options.updateApplyButton(false);
   Options.handleShortcutEnabled();
 
   // IE Compatibility Mode
   Options.updateIEModeTab();
-}
+};
 
 Options.setIconDisplayValue = function(value)
 {
   E("iconDisplay").value = value;
   this.updateApplyButton(true);
-}
+};
 
 Options.updateApplyButton = function(e)
 {
   document.getElementById("myApply").disabled = !e;
-}
+};
 
 Options.handleShortcutEnabled = function(e)
 {
@@ -333,7 +407,7 @@ Options.handleShortcutEnabled = function(e)
   E("shortcut-modifiers").disabled = disable;
   E("shortcut-plus").disabled = disable;
   E("shortcut-key").disabled = disable;
-}
+};
 
 Options.init = function()
 {
@@ -346,6 +420,8 @@ Options.init = function()
     }
   }
   
+  Options.initDialog();
+  
   // for multi-line label sizing problem
   window.sizeToContent();
   let vboxes = document.querySelectorAll("prefpane > vbox");
@@ -355,24 +431,29 @@ Options.init = function()
   });
   window.sizeToContent();
   
-  Options.initDialog();
   addEventListenerByTagName("checkbox", "command", Options.updateApplyButton);
   addEventListenerByTagName("radio", "command", Options.updateApplyButton);
   addEventListenerByTagName("menulist", "command", Options.updateApplyButton);
   E("shortcutEnabled").addEventListener('command', Options.handleShortcutEnabled);
-}
+  
+  ABPObserver.addListener(Options.updateABPStatus);
+  window.addEventListener("unload", function()
+  {
+    ABPObserver.removeListener(Options.updateABPStatus);
+  });
+};
 
 Options.close = function()
 {
   let isModified = !document.getElementById("myApply").disabled;
   if (isModified)
   {
-    if (confirm(Utils.getString("fireie.options.alert.modified")))
+    if (Utils.confirm(window, Utils.getString("fireie.options.alert.modified"), Utils.getString("fireie.options.alert.title")))
     {
       Options.apply(true);
     }
   }
-}
+};
 
 Options._saveToFile = function(aList)
 {
@@ -406,7 +487,7 @@ Options._saveToFile = function(aList)
       stream.close();
     }
   }
-}
+};
 
 Options._loadFromFile = function()
 {
@@ -436,7 +517,7 @@ Options._loadFromFile = function()
     }
   }
   return [false, null];
-}
+};
 
 Options._getAllOptions = function(isDefault)
 {
@@ -470,7 +551,7 @@ Options._getAllOptions = function(isDefault)
     }
   }
   return aList;
-}
+};
 
 Options._setAllOptions = function(aList)
 {
@@ -518,4 +599,4 @@ Options._setAllOptions = function(aList)
       Utils.ERROR(e);
     }
   }
-}
+};
diff --git a/extension/chrome/content/options2.xul b/extension/chrome/content/options2.xul
index 585ec8b..1f1b29e 100644
--- a/extension/chrome/content/options2.xul
+++ b/extension/chrome/content/options2.xul
@@ -114,17 +114,17 @@
               <hbox align="center">
                 <radio id="iconHidden-radio" label="&fireie.options.ui.iconHidden;" value="iconHidden" />
                 <spacer flex="1"/>
-                <image class="icon-hidden" width="150" height="24" onclick="Options.setIconDisplayValue('iconHidden')" />
+                <image class="icon-hidden" width="150" height="24" onclick="event.button == 0 &amp;&amp; Options.setIconDisplayValue('iconHidden')" />
               </hbox>
               <hbox align="center">
                 <radio id="iconOnly-radio" label="&fireie.options.ui.iconOnly;" value="iconOnly" />
                 <spacer flex="1"/>
-                <image class="icon-only" width="150" height="24" onclick="Options.setIconDisplayValue('iconOnly')" />
+                <image class="icon-only" width="150" height="24" onclick="event.button == 0 &amp;&amp; Options.setIconDisplayValue('iconOnly')" />
               </hbox>
               <hbox align="center">
                 <radio id="iconAndText-radio" label="&fireie.options.ui.iconAndText;" value="iconAndText" />
                 <spacer flex="1"/>
-                <image class="icon-and-text" width="150" height="24" onclick="Options.setIconDisplayValue('iconAndText')" style="list-style-image: url('&fireie.options.ui.buttonStylesURL;');" />
+                <image class="icon-and-text" width="150" height="24" onclick="event.button == 0 &amp;&amp; Options.setIconDisplayValue('iconAndText')" style="list-style-image: url('&fireie.options.ui.buttonStylesURL;');" />
               </hbox>
             </radiogroup>
           </vbox>
@@ -152,30 +152,50 @@
         <checkbox id="forceMGSupport" label="&fireie.options.integration.forceMGSupport;" class="indent" />
         <label id="alreadyEnabledMGSupportLabel" style="color: green;">&fireie.options.integration.alreadyEnabledMGSupport;</label>
       </groupbox>
+      <groupbox>
+        <caption label="&fireie.options.integration.abpCaption;" />
+        <label class="descr">&fireie.options.integration.abpDescr;</label>
+        <checkbox id="abpSupportEnabled" label="&fireie.options.integration.abpSupportEnabled;" class="indent" />
+        <hbox>
+          <label>&fireie.options.integration.abpStatusLabel;</label>
+          <label id="abpStatusNotDetected">&fireie.options.integration.abpStatusNotDetected;</label>
+          <label id="abpStatusEnabled" style="color: green">&fireie.options.integration.abpStatusEnabled;</label>
+          <label id="abpStatusDisabled">&fireie.options.integration.abpStatusDisabled;</label>
+          <label id="abpStatusLoading" style="color: green">&fireie.options.integration.abpStatusLoading;</label>
+          <label id="abpStatusLoadFailed" style="color: red">&fireie.options.integration.abpStatusLoadFailed;</label>
+        </hbox>
+      </groupbox>
     </vbox>
   </prefpane>
 
-  <prefpane id="iemodePane" label="&fireie.options.iecompat.pane;" image="chrome://fireie/skin/pane-iemode.png" flex="1">
+  <prefpane id="iemodePane" label="&fireie.options.ieoptions.pane;" image="chrome://fireie/skin/pane-iemode.png" flex="1">
     <preferences></preferences>
     <vbox flex="1">
       <label id="iemodeNotSupported" class="descr" style="margin-top:20px;">
         &fireie.options.iecompat.notSupported;</label>
-      <radiogroup id="iemode">
-        <radio id="ie7mode-radio" label="&fireie.options.iecompat.ie7;"
-        hidden="true" value="ie7mode" />
-        <radio id="ie8mode-radio" label="&fireie.options.iecompat.ie8;"
-        hidden="true" value="ie8mode" />
-        <radio id="ie8forced-radio" label="&fireie.options.iecompat.ie8f;"
-        hidden="true" value="ie8forced" />
-        <radio id="ie9mode-radio" label="&fireie.options.iecompat.ie9;"
-        hidden="true" value="ie9mode" />
-        <radio id="ie9forced-radio" label="&fireie.options.iecompat.ie9f;"
-        hidden="true" value="ie9forced" />
-        <radio id="ie10mode-radio" label="&fireie.options.iecompat.ie10;"
-        hidden="true" value="ie10mode" />
-        <radio id="ie10forced-radio" label="&fireie.options.iecompat.ie10f;"
-        hidden="true" value="ie10forced" />
-      </radiogroup>
+      <groupbox id="iecompat" hidden="true">
+        <caption label="&fireie.options.iecompat.group;" />
+        <radiogroup id="iemode">
+          <radio id="ie7mode-radio" label="&fireie.options.iecompat.ie7;"
+          hidden="true" value="ie7mode" />
+          <radio id="ie8mode-radio" label="&fireie.options.iecompat.ie8;"
+          hidden="true" value="ie8mode" />
+          <radio id="ie8forced-radio" label="&fireie.options.iecompat.ie8f;"
+          hidden="true" value="ie8forced" />
+          <radio id="ie9mode-radio" label="&fireie.options.iecompat.ie9;"
+          hidden="true" value="ie9mode" />
+          <radio id="ie9forced-radio" label="&fireie.options.iecompat.ie9f;"
+          hidden="true" value="ie9forced" />
+          <radio id="ie10mode-radio" label="&fireie.options.iecompat.ie10;"
+          hidden="true" value="ie10mode" />
+          <radio id="ie10forced-radio" label="&fireie.options.iecompat.ie10f;"
+          hidden="true" value="ie10forced" />
+        </radiogroup>
+      </groupbox>
+      <groupbox id="ieFeatures" hidden="true">
+        <caption label="&fireie.options.iefeat.group;" />
+        <checkbox id="gpuRendering" label="&fireie.options.iefeat.gpuRendering;" hidden="true" />
+      </groupbox>
       <label id="iemodeDescr" class="descr" style="margin-top:20px;" hidden="true">
         &fireie.options.restart.descr;</label>
     </vbox>
diff --git a/extension/chrome/content/overlay.js b/extension/chrome/content/overlay.js
index 4c8a766..bcbc69c 100644
--- a/extension/chrome/content/overlay.js
+++ b/extension/chrome/content/overlay.js
@@ -148,11 +148,11 @@ var gFireIE = null;
           dt.setData("text/plain", value);
           dt.setData("text/html", htmlString);
         }
-      });
+      }, false);
     }
-    catch (e)
+    catch (ex)
     {
-      Utils.ERROR("Failed to add event listener on #identity-box");
+      Utils.ERROR("Failed to add event listener on #identity-box: " + ex);
     }
 
     gFireIE.gIdentityHandler = gIdentityHandler;
diff --git a/extension/chrome/locale/en/fireie.dtd b/extension/chrome/locale/en/fireie.dtd
index 5f538b5..4d04ec2 100644
--- a/extension/chrome/locale/en/fireie.dtd
+++ b/extension/chrome/locale/en/fireie.dtd
@@ -38,8 +38,17 @@
 <!ENTITY fireie.options.integration.pane "Integration">
 <!ENTITY fireie.options.integration.mgCaption "Mouse Gestures Support">
 <!ENTITY fireie.options.integration.mgDescr "Normally Fire-IE will detect your mouse gesture extensions and scripts and automatically enable the support if it found any. If you have a mouse gesture extension or script but can't use it in IE-mode tabs, you can try enable this option.">
-<!ENTITY fireie.options.integration.forceMGSupport "Force the support of mouse gestures in IE-mode tabs">
+<!ENTITY fireie.options.integration.forceMGSupport "Force enable mouse gestures support in IE-mode tabs">
 <!ENTITY fireie.options.integration.alreadyEnabledMGSupport "Mouse gestures support is currently enabled.">
+<!ENTITY fireie.options.integration.abpCaption "Adblock Plus Support">
+<!ENTITY fireie.options.integration.abpDescr "Use filters from Adblock Plus to block ads in IE engine.">
+<!ENTITY fireie.options.integration.abpSupportEnabled "Enable Adblock Plus support">
+<!ENTITY fireie.options.integration.abpStatusLabel "Current Status: ">
+<!ENTITY fireie.options.integration.abpStatusNotDetected "Adblock Plus not detected">
+<!ENTITY fireie.options.integration.abpStatusEnabled "Enabled">
+<!ENTITY fireie.options.integration.abpStatusDisabled "Disabled">
+<!ENTITY fireie.options.integration.abpStatusLoading "Loading filters...">
+<!ENTITY fireie.options.integration.abpStatusLoadFailed "Failed to load filters">
 
 <!ENTITY fireie.options.rule.label "Sites Rule">
 <!ENTITY fireie.options.rule.enabled "Enable Sites Rule">
@@ -49,8 +58,9 @@
 <!ENTITY fireie.options.rule.button.add "Add">
 <!ENTITY fireie.options.rule.button.delete "Delete">
 
-<!ENTITY fireie.options.iecompat.tab   "IE Compatibility Mode">
-<!ENTITY fireie.options.iecompat.pane  "IE Compatibility Mode">
+<!ENTITY fireie.options.ieoptions.tab  "IE Options">
+<!ENTITY fireie.options.ieoptions.pane "IE Options">
+<!ENTITY fireie.options.iecompat.group "IE Compatibility Mode">
 <!ENTITY fireie.options.iecompat.ie7   "IE7 Standards Mode">
 <!ENTITY fireie.options.iecompat.ie8   "IE8 Standards Mode">
 <!ENTITY fireie.options.iecompat.ie8f  "IE8 Forced Standards Mode">
@@ -58,7 +68,9 @@
 <!ENTITY fireie.options.iecompat.ie9f  "IE9 Forced Standards Mode">
 <!ENTITY fireie.options.iecompat.ie10  "IE10 Standards Mode">
 <!ENTITY fireie.options.iecompat.ie10f "IE10 Forced Standards Mode">
-<!ENTITY fireie.options.iecompat.notSupported "Your version of IE does not support IE compatibility mode.">
+<!ENTITY fireie.options.iecompat.notSupported "Your version of IE does not support IE compatibility mode or advanced features.">
+<!ENTITY fireie.options.iefeat.group   "Advanced Features">
+<!ENTITY fireie.options.iefeat.gpuRendering "Enable hardware accelerated rendering">
 
 <!ENTITY fireie.options.apply "Apply">
 <!ENTITY fireie.options.manager "Options Manager">
diff --git a/extension/chrome/locale/en/global.properties b/extension/chrome/locale/en/global.properties
index 45ae913..daaeb4a 100644
--- a/extension/chrome/locale/en/global.properties
+++ b/extension/chrome/locale/en/global.properties
@@ -16,6 +16,7 @@ fireie.erc.uaESROnPage=Use ESR UA for --
 fireie.erc.uaDefaultOnSite=Use Default UA on This Site
 fireie.erc.uaDefaultOnPage=Use Default UA for --
 fireie.options.import.error=Failed to import.
+fireie.options.alert.title=Fire IE Options
 fireie.options.alert.restart=Firefox must be restarted for all changes to take effect.
 fireie.options.alert.modified=The preferences are modified. Save changes?
 fireie.security.notEntrypted=Your connection to this website is not encrypted
diff --git a/extension/chrome/locale/zh-CN/fireie.dtd b/extension/chrome/locale/zh-CN/fireie.dtd
index ff9e961..0040e59 100644
--- a/extension/chrome/locale/zh-CN/fireie.dtd
+++ b/extension/chrome/locale/zh-CN/fireie.dtd
@@ -37,9 +37,18 @@
 <!ENTITY fireie.options.integration.tab "集成">
 <!ENTITY fireie.options.integration.pane "集成">
 <!ENTITY fireie.options.integration.mgCaption "鼠标手势支持">
-<!ENTITY fireie.options.integration.mgDescr "通常，解雇IE会检测您的鼠标手势扩展和脚本，并且自动开启相应的支持。如果您的鼠标手势扩展或脚本无法在IE引擎下使用，请尝试打开这个选项。">
-<!ENTITY fireie.options.integration.forceMGSupport "强制开启IE引擎鼠标手势支持">
+<!ENTITY fireie.options.integration.mgDescr "通常，解雇IE会检测您的鼠标手势扩展和脚本，并且自动启用相应的支持。如果您的鼠标手势扩展或脚本无法在IE引擎下使用，请尝试启用这个选项。">
+<!ENTITY fireie.options.integration.forceMGSupport "强制启用IE引擎鼠标手势支持">
 <!ENTITY fireie.options.integration.alreadyEnabledMGSupport "目前已启用鼠标手势支持。">
+<!ENTITY fireie.options.integration.abpCaption "Adblock Plus 支持">
+<!ENTITY fireie.options.integration.abpDescr "在IE引擎中使用 Adblock Plus 的规则来过滤广告。">
+<!ENTITY fireie.options.integration.abpSupportEnabled "启用 Adblock Plus 支持">
+<!ENTITY fireie.options.integration.abpStatusLabel "当前状态：">
+<!ENTITY fireie.options.integration.abpStatusNotDetected "未检测到 Adblock Plus">
+<!ENTITY fireie.options.integration.abpStatusEnabled "已启用">
+<!ENTITY fireie.options.integration.abpStatusDisabled "已禁用">
+<!ENTITY fireie.options.integration.abpStatusLoading "正在载入过滤规则...">
+<!ENTITY fireie.options.integration.abpStatusLoadFailed "载入过滤规则失败">
 
 <!ENTITY fireie.options.rule.label "网址过滤">
 <!ENTITY fireie.options.rule.enabled "总是使用 IE Tab 浏览以下网址">
@@ -49,8 +58,9 @@
 <!ENTITY fireie.options.rule.button.add "添加">
 <!ENTITY fireie.options.rule.button.delete "删除">
 
-<!ENTITY fireie.options.iecompat.tab   "IE兼容模式">
-<!ENTITY fireie.options.iecompat.pane  "IE兼容模式">
+<!ENTITY fireie.options.ieoptions.tab  "IE引擎选项">
+<!ENTITY fireie.options.ieoptions.pane "IE引擎选项">
+<!ENTITY fireie.options.iecompat.group "IE兼容模式">
 <!ENTITY fireie.options.iecompat.ie7   "IE7标准模式">
 <!ENTITY fireie.options.iecompat.ie8   "IE8标准模式">
 <!ENTITY fireie.options.iecompat.ie8f  "IE8强制标准模式">
@@ -58,7 +68,9 @@
 <!ENTITY fireie.options.iecompat.ie9f  "IE9强制标准模式">
 <!ENTITY fireie.options.iecompat.ie10  "IE10标准模式">
 <!ENTITY fireie.options.iecompat.ie10f "IE10强制标准模式">
-<!ENTITY fireie.options.iecompat.notSupported "您的 IE 版本不支持设置 IE 兼容模式。">
+<!ENTITY fireie.options.iecompat.notSupported "您的 IE 版本不支持设置 IE 兼容模式和高级特性。">
+<!ENTITY fireie.options.iefeat.group   "高级特性">
+<!ENTITY fireie.options.iefeat.gpuRendering "启用硬件加速渲染">
 
 <!ENTITY fireie.options.apply "应用">
 <!ENTITY fireie.options.manager "选项管理">
diff --git a/extension/chrome/locale/zh-CN/global.properties b/extension/chrome/locale/zh-CN/global.properties
index 16a9b5f..ce61b91 100644
--- a/extension/chrome/locale/zh-CN/global.properties
+++ b/extension/chrome/locale/zh-CN/global.properties
@@ -16,6 +16,7 @@ fireie.erc.uaESROnPage=对含 -- 的网址使用 ESR UA
 fireie.erc.uaDefaultOnSite=在此站点使用默认 UA
 fireie.erc.uaDefaultOnPage=对含 -- 的网址使用默认 UA
 fireie.options.import.error=导入失败。
+fireie.options.alert.title=解雇IE 选项
 fireie.options.alert.restart=设置生效需要重启火狐。
 fireie.options.alert.modified=选项已修改，是否保存？
 fireie.security.notEntrypted=您和此网站的连接未被加密
diff --git a/extension/chrome/locale/zh-TW/fireie.dtd b/extension/chrome/locale/zh-TW/fireie.dtd
index 828c3b6..5310cc8 100644
--- a/extension/chrome/locale/zh-TW/fireie.dtd
+++ b/extension/chrome/locale/zh-TW/fireie.dtd
@@ -37,9 +37,18 @@
 <!ENTITY fireie.options.integration.tab "集成">
 <!ENTITY fireie.options.integration.pane "集成">
 <!ENTITY fireie.options.integration.mgCaption "滑鼠手勢支援">
-<!ENTITY fireie.options.integration.mgDescr "通常，解雇IE會檢測您的滑鼠手勢擴展和腳本，並且自動開啟相應的支持。如果您的滑鼠手勢擴展或腳本無法在IE引擎下使用，請嘗試打開這個選項。">
-<!ENTITY fireie.options.integration.forceMGSupport "強制開啟IE引擎滑鼠手勢支援">
+<!ENTITY fireie.options.integration.mgDescr "通常，解雇IE會檢測您的滑鼠手勢擴展和腳本，並且自動啟用相應的支持。如果您的滑鼠手勢擴展或腳本無法在IE引擎下使用，請嘗試啟用這個選項。">
+<!ENTITY fireie.options.integration.forceMGSupport "強制啟用IE引擎滑鼠手勢支援">
 <!ENTITY fireie.options.integration.alreadyEnabledMGSupport "目前已啟用滑鼠手勢支援。">
+<!ENTITY fireie.options.integration.abpCaption "Adblock Plus 支援">
+<!ENTITY fireie.options.integration.abpDescr "在IE引擎中使用 Adblock Plus 的規則來過濾廣告。">
+<!ENTITY fireie.options.integration.abpSupportEnabled "啟用 Adblock Plus 支援">
+<!ENTITY fireie.options.integration.abpStatusLabel "當前狀態：">
+<!ENTITY fireie.options.integration.abpStatusNotDetected "未檢測到 Adblock Plus">
+<!ENTITY fireie.options.integration.abpStatusEnabled "已啟用">
+<!ENTITY fireie.options.integration.abpStatusDisabled "已停用">
+<!ENTITY fireie.options.integration.abpStatusLoading "正在載入過濾規則...">
+<!ENTITY fireie.options.integration.abpStatusLoadFailed "載入過濾規則失敗">
 
 <!ENTITY fireie.options.rule.label "網址過濾">
 <!ENTITY fireie.options.rule.enabled "總是使用 IE Tab 瀏覽以下網址">
@@ -49,8 +58,9 @@
 <!ENTITY fireie.options.rule.button.add "新增">
 <!ENTITY fireie.options.rule.button.delete "刪除">
 
-<!ENTITY fireie.options.iecompat.tab   "IE兼容模式">
-<!ENTITY fireie.options.iecompat.pane  "IE兼容模式">
+<!ENTITY fireie.options.ieoptions.tab  "IE引擎選項">
+<!ENTITY fireie.options.ieoptions.pane "IE引擎選項">
+<!ENTITY fireie.options.iecompat.group "IE兼容模式">
 <!ENTITY fireie.options.iecompat.ie7   "IE7標準模式">
 <!ENTITY fireie.options.iecompat.ie8   "IE8標準模式">
 <!ENTITY fireie.options.iecompat.ie8f  "IE8強制標準模式">
@@ -58,7 +68,9 @@
 <!ENTITY fireie.options.iecompat.ie9f  "IE9強制標準模式">
 <!ENTITY fireie.options.iecompat.ie10  "IE10標準模式">
 <!ENTITY fireie.options.iecompat.ie10f "IE10強制標準模式">
-<!ENTITY fireie.options.iecompat.notSupported "您的 IE 版本不支援設置 IE 兼容模式。">
+<!ENTITY fireie.options.iecompat.notSupported "您的 IE 版本不支援設置 IE 兼容模式和高級特性。">
+<!ENTITY fireie.options.iefeat.group   "高級特性">
+<!ENTITY fireie.options.iefeat.gpuRendering "啟用硬體加速渲染">
 
 <!ENTITY fireie.options.apply "應用">
 <!ENTITY fireie.options.manager "選項管理">
diff --git a/extension/chrome/locale/zh-TW/global.properties b/extension/chrome/locale/zh-TW/global.properties
index 7ac823f..8090438 100644
--- a/extension/chrome/locale/zh-TW/global.properties
+++ b/extension/chrome/locale/zh-TW/global.properties
@@ -16,6 +16,7 @@ fireie.erc.uaESROnPage=對含 -- 的網址使用 ESR UA
 fireie.erc.uaDefaultOnSite=在此網站使用默認 UA
 fireie.erc.uaDefaultOnPage=對含 -- 的網址使用默認 UA
 fireie.options.import.error=匯入失敗。
+fireie.options.alert.title=解雇IE 選項
 fireie.options.alert.restart=設定生效需要重啟火狐。
 fireie.options.alert.modified=選項已修改，是否儲存？
 fireie.security.notEntrypted=您和此網站的連接未被加密
diff --git a/extension/defaults/preferences/fireie.js b/extension/defaults/preferences/fireie.js
index b59b98f..4528184 100644
--- a/extension/defaults/preferences/fireie.js
+++ b/extension/defaults/preferences/fireie.js
@@ -26,10 +26,13 @@ pref("extensions.fireie.showTooltipText", true);
 pref("extensions.fireie.showStatusText", true);
 pref("extensions.fireie.compatMode", "ie7mode");
 pref("extensions.fireie.forceMGSupport", false);
+pref("extensions.fireie.gpuRendering", false);
 
 pref("extensions.fireie.currentTheme", "");
 pref("extensions.fireie.allowedThemeHosts", "[\"fireie.org\"]");
 
+pref("extensions.fireie.abpSupportEnabled", true);
+
 // History & Privacy control
 pref("privacy.cpd.extensions-fireie", true);
 pref("privacy.clearOnShutdown.extensions-fireie", true);
diff --git a/extension/install.rdf b/extension/install.rdf
index b005351..70486c3 100644
--- a/extension/install.rdf
+++ b/extension/install.rdf
@@ -5,7 +5,7 @@
 
    <em:id>fireie@fireie.org</em:id>
    <em:name>Fire IE</em:name>
-   <em:version>0.3.0</em:version>
+   <em:version>0.3.1</em:version>
    <em:description>Switch to IE engine in one click and give up your Internet Explorer.</em:description>
    <em:creator>Yuan Xulei</em:creator>
    <em:contributor>Wei Deng</em:contributor>
@@ -20,8 +20,8 @@
    <em:targetApplication>
      <Description>
        <em:id>{ec8030f7-c20a-464f-9b0e-13a3a9e97384}</em:id>
-       <em:minVersion>4.0</em:minVersion>
-       <em:maxVersion>19.0a1</em:maxVersion>
+       <em:minVersion>6.0</em:minVersion>
+       <em:maxVersion>20.0a1</em:maxVersion>
      </Description>
    </em:targetApplication>
    
diff --git a/extension/modules/ABPObserver.jsm b/extension/modules/ABPObserver.jsm
new file mode 100644
index 0000000..24e5120
--- /dev/null
+++ b/extension/modules/ABPObserver.jsm
@@ -0,0 +1,640 @@
+/*
+This file is part of Fire-IE.
+
+Fire-IE is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Fire-IE is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Fire-IE.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+/**
+ * @fileOverview Manages ABP support and observes ABP preferences
+ */
+
+let EXPORTED_SYMBOLS = ["ABPObserver", "ABPStatus"];
+
+const Cc = Components.classes;
+const Ci = Components.interfaces;
+const Cr = Components.results;
+const Cu = Components.utils;
+
+let baseURL = Cc["@fireie.org/fireie/private;1"].getService(Ci.nsIURI);
+
+Cu.import("resource://gre/modules/Services.jsm");
+Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+Cu.import("resource://gre/modules/AddonManager.jsm");
+
+Cu.import(baseURL.spec + "UtilsPluginManager.jsm");
+Cu.import(baseURL.spec + "Utils.jsm");
+Cu.import(baseURL.spec + "Prefs.jsm");
+
+let abp = {};
+
+const abpId = "{d10d0bf8-f5b5-c8b4-a8b2-2b9879e08c5d}";
+/**
+ * Queries the FilterNotifier Object used to trigger reloads on "save" events
+ */
+function queryFilterNotifier()
+{
+  // ABP 2.0 and older
+  let ABPPrivate = Cc["@adblockplus.org/abp/private;1"];
+  if (ABPPrivate)
+  {
+    let abpURL = ABPPrivate.getService(Ci.nsIURI);
+    try
+    {
+      Cu.import(abpURL.spec + "FilterNotifier.jsm", abp);
+      return;
+    }
+    catch (ex) { }
+  }
+
+  // ABP 2.1+
+  function require(/**String*/ module)
+  {
+    let result = {};
+    result.wrappedJSObject = result;
+    Services.obs.notifyObservers(result, "adblockplus-require", module);
+    if(!result.exports)
+    {
+      return null;
+    }
+    return result.exports;
+  }
+
+  try
+  {
+    let {FilterNotifier} = require("filterNotifier");
+    if (FilterNotifier)
+    {
+      abp.FilterNotifier = FilterNotifier;
+      return;
+    }
+  }
+  catch (ex) { }
+}
+
+let ABPStatus = {
+  NotDetected: 0,
+  Enabled: 1,
+  Disabled: 2,
+  Loading: 3,
+  LoadFailed: 4
+};
+
+let ABPObserver = {
+
+  _abpInstalled: false,
+  
+  _abpBranch: null,
+  
+  /**
+   * Whether init() has been called
+   */
+  _isInitCalled: false,
+  
+  /**
+   * Whether there's any pending updateState calls during filter loading
+   */
+  _pendingUpdate: false,
+  
+  /**
+   * Whether a reload is needed for the current updateState call
+   */
+  _needReload: false,
+  
+  /**
+   * Whether there's scheduled (runAsync) updateState calls
+   */
+  _scheduledUpdate: false,
+  
+  /**
+   * ABP status
+   */
+  _status: ABPStatus.NotDetected,
+  
+  /**
+   * Listeners of ABPObserver
+   */
+  _listeners: [],
+  
+  /**
+   * Timer for clearing the loaded ABP filters
+   */
+  _clearTimer: null,
+  
+  /**
+   * Lazy initialization on first browser window creation. See Bootstrap.jsm
+   */
+  lazyStartup: function()
+  {
+    this.init();
+  },
+  
+  init: function()
+  {
+    if (this._isInitCalled) return;
+    this._isInitCalled = true;
+    
+    UtilsPluginManager.fireAfterInit(function()
+    {
+      this._abpBranch = Services.prefs.getBranch("extensions.adblockplus.");
+      
+      if (this._abpBranch)
+      {
+        this._abpBranch.QueryInterface(Ci.nsIPrefBranch2);
+        this._abpBranch.addObserver("", ABPObserverPrivate, false);
+      }
+      
+      this._registerListeners();
+      
+      this._detectABP();
+    }, this, []);
+  },
+  
+  shutdown: function()
+  {
+    if (!this._isInitCalled) return;
+    UtilsPluginManager.fireAfterInit(function()
+    {
+      this._listeners = [];
+      this._abpBranch = null;
+      this._unregisterListeners();
+      
+      // unload all filters if possible
+      try
+      {
+        UtilsPluginManager.getPlugin().ABPClear();
+      }
+      catch (e) {}
+      
+      this._cancelClearTimer();
+    }, this, []);
+  },
+  
+  isInstalled: function()
+  {
+    return this._abpInstalled;
+  },
+  
+  getStatus: function()
+  {
+    return this._status;
+  },
+  
+  addListener: function(listener)
+  {
+    this._listeners.push(listener);
+  },
+  
+  removeListener: function(listener)
+  {
+    Utils.removeOneItem(this._listeners, listener);
+  },
+  
+  _onABPEnable: function()
+  {
+    this._abpInstalled = true;
+    Utils.LOG("[ABP] Adblock Plus detected.");
+    
+    if (!abp.FilterNotifier)
+      queryFilterNotifier();
+    this._setStatus(ABPStatus.Disabled);
+
+    try
+    {
+      abp.FilterNotifier.removeListener(onABPFilterNotify);
+      abp.FilterNotifier.addListener(onABPFilterNotify);
+    }
+    catch (ex)
+    {
+      Utils.LOG("[ABP] Failed to add listener to ABP's FilterNotifier: " + ex);
+    }
+    
+    this.reloadUpdate();
+  },
+  
+  _onABPDisable: function()
+  {
+    this._abpInstalled = false;
+    Utils.LOG("[ABP] Adblock Plus not installed or disabled.");
+
+    try
+    {
+      abp.FilterNotifier.removeListener(onABPFilterNotify);
+    }
+    catch (ex) {}
+
+    this.updateState();
+
+    abp = {};
+    this._setStatus(ABPStatus.NotDetected);
+  },
+  
+  _detectABP: function()
+  {
+    AddonManager.getAddonByID(abpId, function(addon)
+    {
+      let installed = (addon != null && addon.isActive);
+      if (installed)
+        this._onABPEnable();
+      else
+        this._onABPDisable();
+    }.bind(this));
+  },
+  
+  _setStatus: function(status)
+  {
+    this._status = status;
+    switch (this._status)
+    {
+    case ABPStatus.NotDetected:
+    case ABPStatus.Disabled:
+    case ABPStatus.LoadFailed:
+      this._setClearTimer();
+      break;
+    case ABPStatus.Loading:
+    case ABPStatus.Enabled:
+      this._cancelClearTimer();
+      break;
+    }
+    this._triggerListeners("statusChanged", status);
+  },
+  
+  _triggerListeners: function(topic, data)
+  {
+    this._listeners.forEach(function(listener)
+    {
+      try { listener(topic, data); } catch (ex) {}
+    });
+  },
+  
+  /**
+   * Non-throwing pref accessors for abp branch
+   */
+  _getABPCharPref: function(name)
+  {
+    try
+    {
+      return this._abpBranch.getCharPref(name);
+    }
+    catch (e)
+    {
+      return null;
+    }
+  },
+  _getABPBoolPref: function(name)
+  {
+    try
+    {
+      return this._abpBranch.getBoolPref(name);
+    }
+    catch (e)
+    {
+      return null;
+    }
+  },
+
+  /**
+   * Whether we should enable ABP support?
+   */
+  _canEnable: function()
+  {
+    return this._abpInstalled && Prefs.abpSupportEnabled && this._getABPBoolPref("enabled");
+  },
+  
+  /**
+   * Returns the filter file pathname
+   */
+  _getFilterFile: function()
+  {
+    let file = null;
+    let pref = this._getABPCharPref("patternsfile");
+    if (pref)
+    {
+      // Override in place, use it instead of placing the file in the regular data dir
+      file = Utils.resolveFilePath(pref);
+    }
+    if (!file)
+    {
+      // Place the file in the data dir
+      pref = this._getABPCharPref("data_directory")
+      if (pref)
+      {
+        file = Utils.resolveFilePath(pref);
+        if (file)
+          file.append("patterns.ini");
+      }
+    }
+    if (!file)
+    {
+      // Data directory pref misconfigured? Try the default value
+      try
+      {
+        file = Utils.resolveFilePath(Services.prefs.getDefaultBranch("extensions.adblockplus.").getCharPref("data_directory"));
+        if (file)
+          file.append("patterns.ini");
+      } catch (ex) {}
+    }
+    if (!file)
+    {
+      // Still no good? Try the hard-coded path
+      try
+      {
+        file = Utils.resolveFilePath("adblockplus/patterns.ini");
+      } catch (ex) {}
+    }
+    let pathname = file ? file.path : null;
+    return pathname;
+  },
+  
+  _loadFilters: function()
+  {
+    let pathname = this._getFilterFile();
+    if (pathname)
+    {
+      try
+      {
+        UtilsPluginManager.getPlugin().ABPLoad(pathname);
+        this._setStatus(ABPStatus.Loading);
+        Utils.LOG("[ABP] Loading filters from \"" + pathname + "\"...");
+      }
+      catch (ex)
+      {
+        this._setStatus(ABPStatus.LoadFailed);
+        Utils.ERROR("[ABP] Failed to load filters from \"" + pathname + "\": " + ex);
+      }
+    }
+    this._needReload = false;
+  },
+  
+  /**
+   * Enable ABP support
+   */
+  _enable: function()
+  {
+    try
+    {
+      UtilsPluginManager.getPlugin().ABPEnable();
+      this._setStatus(ABPStatus.Enabled);
+      Utils.LOG("[ABP] Enabled.");
+    }
+    catch (ex)
+    {
+      this._setStatus(ABPStatus.Disabled);
+      Utils.ERROR("[ABP] Cannot enable ABP support: " + ex);
+    }
+  },
+  
+  /**
+   * Disable ABP support
+   */
+  _disable: function()
+  {
+    try
+    {
+      UtilsPluginManager.getPlugin().ABPDisable();
+      this._setStatus(this._abpInstalled ? ABPStatus.Disabled : ABPStatus.NotDetected);
+      Utils.LOG("[ABP] Disabled.");
+    }
+    catch (ex)
+    {
+      this._setStatus(ABPStatus.Disabled);
+      Utils.ERROR("[ABP] Cannot disable ABP support: " + ex);
+    }
+  },
+  
+  /**
+   * Update plugin state according to current prefs.
+   * Core updateState function.
+   */
+  _updateStateCore: function()
+  {
+    Utils.LOG("[ABP] updateState() called.");
+    this._scheduledUpdate = false;
+    
+    // updates the plugin state
+    let plugin = UtilsPluginManager.getPlugin();
+    if (plugin)
+    {
+      // Don't do anything while filters are loading
+      // We'll handle later in the Loaded/LoadFailure event handlers
+      if (plugin.ABPIsLoading)
+      {
+        this._pendingUpdate = true;
+        return;
+      }
+      
+      let enabled = plugin.ABPIsEnabled;
+      let pathname = plugin.ABPLoadedFile;
+      
+      if (enabled)
+      {
+        if (!this._canEnable())
+          this._disable();
+        else if (this._needReload || pathname != this._getFilterFile())
+          this._loadFilters();
+      }
+      else
+      {
+        if (this._canEnable())
+        {
+          if (this._needReload || pathname != this._getFilterFile())
+            this._loadFilters();
+          else this._enable();
+        }
+      }
+    }
+    this._pendingUpdate = false;
+  },
+  
+  /**
+   * Update plugin state according to current prefs.
+   * Just schedules calls to the core function.
+   */
+  updateState: function()
+  {
+    if (this._scheduledUpdate) return;
+    this._scheduledUpdate = true;
+    Utils.runAsync(this._updateStateCore, this);
+  },
+  
+  /**
+   * Update plugin state according to current prefs.
+   * Just schedules calls to the core function.
+   * This version always forces a reload
+   */
+  reloadUpdate: function()
+  {
+    Utils.LOG("[ABP] Reloading filters...");
+    this._needReload = true;
+    this.updateState();
+  },
+  
+  _registerListeners: function()
+  {
+    let window = UtilsPluginManager.getWindow();
+    window.addEventListener("IEABPFilterLoaded", onABPFilterLoaded, false);
+    window.addEventListener("IEABPLoadFailure", onABPLoadFailure, false);
+    Prefs.addListener(onFireIEPrefChanged);
+    AddonManager.addAddonListener(ABPAddonListener);
+  },
+  
+  _unregisterListeners: function()
+  {
+    let window = UtilsPluginManager.getWindow();
+    window.removeEventListener("IEABPFilterLoaded", onABPFilterLoaded, false);
+    window.removeEventListener("IEABPLoadFailure", onABPLoadFailure, false);
+    Prefs.removeListener(onFireIEPrefChanged);
+    AddonManager.removeAddonListener(ABPAddonListener);
+  },
+  
+  _onPrefChanged: function()
+  {
+    // do not take actions on pref change when abp is not detected
+    if (!this._abpInstalled)
+      return;
+    this.updateState();
+    if (!this._canEnable())
+      this._setStatus(ABPStatus.Disabled);
+  },
+  
+  _setClearTimer: function()
+  {
+    if (this._clearTimer) return;
+    this._clearTimer = Utils.runAsyncTimeout(function()
+    {
+      UtilsPluginManager.getPlugin().ABPClear();
+      this._clearTimer = null;
+      Utils.LOG("[ABP] Cleared.");
+    }, this, 60000);
+    Utils.LOG("[ABP] Scheduled to clear in 60 seconds.");
+  },
+  
+  _cancelClearTimer: function()
+  {
+    if (!this._clearTimer) return;
+    Utils.cancelAsyncTimeout(this._clearTimer);
+    this._clearTimer = null;
+    Utils.LOG("[ABP] Canceled previous clear schedule.");
+  }
+};
+  
+/**
+ * Filter load handler: enables ABP support if necessary
+ */
+function onABPFilterLoaded(e)
+{
+  try
+  {
+    let detailObj = { number: "unknown", ticks: "unknown" };
+    detailObj = JSON.parse(e.detail);
+    Utils.LOG("[ABP] Filters loaded: " + detailObj.number + " active filter(s) in " + detailObj.ticks + " ms.");
+  }
+  catch (ex)
+  {
+    Utils.LOG("[ABP] Filters loaded.");
+  }
+  // enable ABP support
+  let self = ABPObserver;
+  if (self._pendingUpdate)
+    self.updateState();
+  else
+    self._enable();
+}
+
+/**
+ * Filter load failure handler
+ */
+function onABPLoadFailure(e)
+{
+  let self = ABPObserver;
+  self._setStatus(ABPStatus.LoadFailed);
+  Utils.LOG("[ABP] Failed to load filters.");
+  Utils.ERROR("[ABP] Failed to load filters.");
+  if (self._pendingUpdate)
+    self.updateState();
+}
+
+function onFireIEPrefChanged(name)
+{
+  if (name == "abpSupportEnabled")
+  {
+    let self = ABPObserver;
+    self._onPrefChanged();
+  }
+}
+
+function onABPFilterNotify(action, item, newValue, oldValue)
+{
+  if (action == "save")
+    ABPObserver.reloadUpdate();
+}
+
+/**
+ * Observer for ABP pref change
+ */
+let ABPObserverPrivate = {
+  /**
+   * nsIObserver implementation
+   */
+  observe: function(subject, topic, data)
+  {
+    if (topic == "nsPref:changed" && data == "enabled")
+    {
+      ABPObserver._onPrefChanged();
+    }
+  },
+
+  QueryInterface: XPCOMUtils.generateQI([Ci.nsISupportsWeakReference, Ci.nsIObserver])
+
+};
+
+/**
+ * Listen for addon changes
+ */
+let ABPAddonListener = {
+  onEnabled: function(/* in Addon */addon)
+  {
+    if (addon.id == abpId)
+      Utils.runAsync(function()
+      {
+        ABPObserver._onABPEnable();
+      }, this);
+  },
+  
+  onDisabled: function(/* in Addon */addon)
+  {
+    if (addon.id == abpId)
+      Utils.runAsync(function()
+      {
+        ABPObserver._onABPDisable();
+      }, this);
+  },
+  
+  onInstalled: function(/* in Addon */addon)
+  {
+    if (addon.id == abpId)
+      Utils.runAsync(function()
+      {
+        ABPObserver._onABPEnable();
+      }, this);
+  },
+  
+  onUninstalled: function(/* in Addon */addon)
+  {
+    if (addon.id == abpId)
+      Utils.runAsync(function()
+      {
+        ABPObserver._onABPDisable();
+      }, this);
+  }
+};
diff --git a/extension/modules/AppIntegration.jsm b/extension/modules/AppIntegration.jsm
index ee7cad5..734b16b 100644
--- a/extension/modules/AppIntegration.jsm
+++ b/extension/modules/AppIntegration.jsm
@@ -147,7 +147,7 @@ let AppIntegration = {
   getWrapperForWindow: function( /**Window*/ wnd) /**WindowWrapper*/
   {
     for each(let wrapper in wrappers)
-    if (wrapper.window == wnd) return wrapper;
+      if (wrapper.window == wnd) return wrapper;
 
     return null;
   },
@@ -337,7 +337,7 @@ WindowWrapper.prototype = {
 
   init: function()
   {
-    UtilsPluginManager.init();
+    Services.obs.notifyObservers(null, "fireie-lazy-init", null);
 
     this._registerEventListeners();
 
@@ -413,6 +413,8 @@ WindowWrapper.prototype = {
 
   /**
    * Updates the UI for an application window.
+   * Note that UI is not immediately updated until the queued update code is run,
+   * so don't rely on any UI state after the update
    */
   updateInterface: function() { this._updateInterface(); },
   _updateInterface: function()
@@ -940,7 +942,7 @@ WindowWrapper.prototype = {
     let progress = parseInt(event.detail);
     if (progress == 0) this.window.gBrowser.userTypedValue = null;
     this._updateProgressStatus();
-    if (progress >= 100)
+    if (progress >= 100 || progress == -1)
       this._updateInterface();
   },
 
@@ -1814,9 +1816,9 @@ WindowWrapper.prototype = {
   {
     this.E("fireie-menu-item-autoswitch-disabled").setAttribute("checked", !Prefs.autoswitch_enabled);
   },
-  fireAfterInit: function(callback, self, arguments)
+  fireAfterInit: function(callback, self, args)
   {
-    UtilsPluginManager.fireAfterInit(callback, self, arguments);
+    UtilsPluginManager.fireAfterInit(callback, self, args);
   },
   // Handler for click event on engine switch button
   clickSwitchButton: function(e)
diff --git a/extension/modules/Bootstrap.jsm b/extension/modules/Bootstrap.jsm
index f455620..3f5ba4a 100644
--- a/extension/modules/Bootstrap.jsm
+++ b/extension/modules/Bootstrap.jsm
@@ -60,12 +60,27 @@ let factoryPrivate = {
 };
 
 let defaultModules = [
-baseURL.spec + "Prefs.jsm", baseURL.spec + "RuleListener.jsm", baseURL.spec + "ContentPolicy.jsm", baseURL.spec + "Synchronizer.jsm", baseURL.spec + "IECookieManager.jsm", baseURL.spec + "FontObserver.jsm"];
+  baseURL.spec + "Prefs.jsm",
+  baseURL.spec + "RuleListener.jsm",
+  baseURL.spec + "ContentPolicy.jsm",
+  baseURL.spec + "Synchronizer.jsm",
+  baseURL.spec + "IECookieManager.jsm",
+  baseURL.spec + "FontObserver.jsm",
+  baseURL.spec + "UtilsPluginManager.jsm",
+  baseURL.spec + "ABPObserver.jsm"
+];
 
 let loadedModules = {
   __proto__: null
 };
 
+let lazyLoadModules = {
+  __proto__: null
+};
+
+// Ensures ordered initialization for lazy loaded modules
+let lazyLoadModulesOrdered = [];
+
 let initialized = false;
 
 /**
@@ -87,8 +102,7 @@ var Bootstrap = {
     registrar.registerFactory(cidPrivate, "Fire-IE private module URL", contractIDPrivate, factoryPrivate);
 
     // Load and initialize modules
-    for each(let url in defaultModules)
-    Bootstrap.loadModule(url);
+    defaultModules.forEach(Bootstrap.loadModule);
 
     let categoryManager = Cc["@mozilla.org/categorymanager;1"].getService(Ci.nsICategoryManager);
     let enumerator = categoryManager.enumerateCategory("fireie-module-location");
@@ -100,7 +114,7 @@ var Bootstrap = {
 
     Services.obs.addObserver(BootstrapPrivate, "xpcom-category-entry-added", true);
     Services.obs.addObserver(BootstrapPrivate, "xpcom-category-entry-removed", true);
-
+    Services.obs.addObserver(BootstrapLazyLoadPrivate, "fireie-lazy-init", true);
   },
 
   /**
@@ -112,10 +126,11 @@ var Bootstrap = {
 
     // Shut down modules
     for (let url in loadedModules)
-    Bootstrap.shutdownModule(url);
+      Bootstrap.shutdownModule(url);
 
     Services.obs.removeObserver(BootstrapPrivate, "xpcom-category-entry-added");
     Services.obs.removeObserver(BootstrapPrivate, "xpcom-category-entry-removed");
+    Services.obs.removeObserver(BootstrapLazyLoadPrivate, "fireie-lazy-init");
   },
 
   /**
@@ -123,7 +138,7 @@ var Bootstrap = {
    */
   loadModule: function( /**String*/ url)
   {
-    if (url in loadedModules) return;
+    if (url in loadedModules || url in lazyLoadModules) return;
 
     let module = {};
     try
@@ -136,8 +151,9 @@ var Bootstrap = {
       return;
     }
 
-    for each(let obj in module)
+    for (let prop in module)
     {
+      let obj = module[prop];
       if ("startup" in obj)
       {
         try
@@ -151,6 +167,12 @@ var Bootstrap = {
         }
         return;
       }
+      if ("lazyStartup" in obj)
+      {
+        lazyLoadModules[url] = obj;
+        lazyLoadModulesOrdered.push(url);
+        return;
+      }
     }
 
     Cu.reportError("Fire-IE: No exported object with startup() method found for module " + url);
@@ -176,6 +198,30 @@ var Bootstrap = {
       }
       return;
     }
+  },
+  
+  /**
+   * Lazy load all modules in lazyLoadModules
+   */
+  doLazyLoadModules: function()
+  {
+    if (lazyLoadModules == null) return;
+    
+    lazyLoadModulesOrdered.forEach(function(url)
+    {
+      let obj = lazyLoadModules[url];
+      try
+      {
+        obj.lazyStartup();
+        loadedModules[url] = obj;
+      }
+      catch (e)
+      {
+        Cu.reportError("Fire-IE: Calling method lazyStartup() for module " + url + " failed: " + e);
+      }
+    });
+    lazyLoadModules = null;
+    lazyLoadModulesOrdered = null;
   }
 };
 
@@ -201,3 +247,17 @@ var BootstrapPrivate = {
     }
   }
 };
+
+/**
+ * Observer called on module lazy initialization
+ * @class
+ */
+var BootstrapLazyLoadPrivate = {
+  QueryInterface: XPCOMUtils.generateQI([Ci.nsIObserver, Ci.nsISupportsWeakReference]),
+  
+  observe: function(subject, topic, data)
+  {
+    if (topic == "fireie-lazy-init")
+      Bootstrap.doLazyLoadModules();
+  }
+};
diff --git a/extension/modules/GesturePrefObserver.jsm b/extension/modules/GesturePrefObserver.jsm
index 44dea29..8af8d4f 100644
--- a/extension/modules/GesturePrefObserver.jsm
+++ b/extension/modules/GesturePrefObserver.jsm
@@ -31,7 +31,7 @@ let baseURL = Cc["@fireie.org/fireie/private;1"].getService(Ci.nsIURI);
 Cu.import("resource://gre/modules/Services.jsm");
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 
-Cu.import(baseURL.spec + "AppIntegration.jsm");
+Cu.import(baseURL.spec + "UtilsPluginManager.jsm");
 Cu.import(baseURL.spec + "Utils.jsm");
 Cu.import(baseURL.spec + "Prefs.jsm");
 
@@ -63,7 +63,7 @@ let GesturePrefObserver = {
   _getUtilsPlugin: function()
   {
     // since we don't have any window handles, we'll ask for one
-    return AppIntegration.getAnyUtilsPlugin();
+    return UtilsPluginManager.getPlugin();
   },
 
   /**
diff --git a/extension/modules/IECookieManager.jsm b/extension/modules/IECookieManager.jsm
index a038a2c..c4ebaaf 100644
--- a/extension/modules/IECookieManager.jsm
+++ b/extension/modules/IECookieManager.jsm
@@ -325,12 +325,14 @@ let CookieObserver = {
   {
     Services.obs.addObserver(this, "cookie-changed", false);
     Services.obs.addObserver(this, "fireie-set-cookie", false);
+    Services.obs.addObserver(this, "fireie-batch-set-cookie", false);
   },
 
   unregister: function()
   {
     Services.obs.removeObserver(this, "cookie-changed");
     Services.obs.removeObserver(this, "fireie-set-cookie");
+    Services.obs.removeObserver(this, "fireie-batch-set-cookie");
   },
 
   // nsIObserver
@@ -344,6 +346,9 @@ let CookieObserver = {
     case 'fireie-set-cookie':
       this.onIECookieChanged(data);
       break;
+    case 'fireie-batch-set-cookie':
+      this.onIEBatchCookieChanged(data);
+      break;
     }
   },
 
@@ -398,6 +403,23 @@ let CookieObserver = {
     }
   },
 
+  onIEBatchCookieChanged: function(data)
+  {
+    try
+    {
+      let cookies = JSON.parse(data);
+      cookies.forEach(function(cookie)
+      {
+        let {header, url} = cookie;
+        IECookieManager.saveFirefoxCookie(url, header);
+      });
+    }
+    catch(e)
+    {
+      Utils.ERROR("onIEBatchCookieChanged(" + data + "): " + e);
+    }
+  },
+
   logFirefoxCookie: function(tag, cookie2)
   {
     Utils.LOG('[CookieObserver ' + tag + "] host:" + cookie2.host + " path:" + cookie2.path + " name:" + cookie2.name + " value:" + cookie2.value + " expires:" + new Date(cookie2.expires * 1000).toGMTString() + " isHttpOnly:" + cookie2.isHttpOnly + " isSession:" + cookie2.isSession);
diff --git a/extension/modules/Utils.jsm b/extension/modules/Utils.jsm
index 6160615..e734f69 100644
--- a/extension/modules/Utils.jsm
+++ b/extension/modules/Utils.jsm
@@ -550,26 +550,32 @@ var Utils = {
    * Any additional parameters to this function are passed as parameters
    * to the callback.
    */
-  runAsyncTimeout: function( /**Function*/ callback, /**Object*/ thisPtr, /**Number*/ timeout)
+  runAsyncTimeout: function( /**Function*/ callback, /**Object*/ thisPtr, /**Number*/ timeout) /**nsITimer*/
   {
     let params = Array.prototype.slice.call(arguments, 3);
     let event = {
       notify: function(timer)
       {
-        for (let i = 0, l = this._timers.length; i < l; i++)
-        {
-          if (this._timers[i] === timer)
-          {
-            this._timers.splice(i, 1);
-            break;
-          }
-        }
+        this.removeOneItem(this._timers, timer);
         callback.apply(thisPtr, params);
       }.bind(this)
     };
     let timer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
     timer.initWithCallback(event, timeout, Ci.nsITimer.TYPE_ONE_SHOT);
     this._timers.push(timer);
+    return timer;
+  },
+  
+  /**
+   * Cancels previous runAsyncTimeout operation
+   */
+  cancelAsyncTimeout: function( /**nsITimer*/ timer)
+  {
+    if (timer)
+    {
+      timer.cancel();
+      this.removeOneItem(this._timers, timer);
+    }
   },
 
   /**
@@ -860,7 +866,26 @@ var Utils = {
                .hiddenDOMWindow;
     this.getHiddenWindow = function() hiddenWindow;
     return hiddenWindow;
-  }
+  },
+  
+  // Removes the first occurance of item in arr
+  removeOneItem: function(arr, item)
+  {
+    let idx = arr.indexOf(item);
+    if (idx != -1)
+      arr.splice(idx, 1);
+  },
+  
+  // Removes all occurances of item in arr
+  removeAllItems: function(arr, item)
+  {
+    let idx = arr.indexOf(item);
+    while (idx != -1)
+    {
+      arr.splice(idx, 1);
+      idx = arr.indexOf(item);
+    }
+  },
 };
 
 /**
diff --git a/extension/modules/UtilsPluginManager.jsm b/extension/modules/UtilsPluginManager.jsm
index 9dcff12..aedf7e3 100644
--- a/extension/modules/UtilsPluginManager.jsm
+++ b/extension/modules/UtilsPluginManager.jsm
@@ -45,6 +45,16 @@ let UtilsPluginManager = {
    */
   _isInitCalled: false,
   
+  lazyStartup: function()
+  {
+    this.init();
+  },
+  
+  shutdown: function()
+  {
+    this.uninit();
+  },
+  
   init: function()
   {
     if (this._isInitCalled) return;
@@ -57,6 +67,7 @@ let UtilsPluginManager = {
   
   uninit: function()
   {
+    if (!this._isInitCalled) return;
     this._unregisterHandlers();
     this._cancelPluginEvents();
   },
@@ -72,20 +83,31 @@ let UtilsPluginManager = {
   },
   
   /**
+   * Retrieves the window where utils plugin sits in
+   */
+  getWindow: function()
+  {
+    return Utils.getHiddenWindow();
+  },
+  
+  /**
    * Ensures that the plugin is initialized before calling the callback
    */
-  fireAfterInit: function(callback, self, arguments)
+  fireAfterInit: function(callback, self, args)
   {
     if (this.isPluginInitialized)
     {
-      callback.apply(self, arguments);
+      callback.apply(self, args);
     }
     else
     {
-      Utils.getHiddenWindow().addEventListener("IEUtilsPluginInitialized", function(e)
+      let window = Utils.getHiddenWindow();
+      let handler = function(e)
       {
-        callback.apply(self, arguments);
-      }, false);
+        window.removeEventListener("IEUtilsPluginInitialized", handler, false);
+        callback.apply(self, args);
+      };
+      window.addEventListener("IEUtilsPluginInitialized", handler, false);
     }
   },
 
@@ -147,14 +169,18 @@ let UtilsPluginManager = {
   
   _registerHandlers: function()
   {
-    Utils.getHiddenWindow().addEventListener("IEUserAgentReceived", onIEUserAgentReceived, false);
-    Utils.getHiddenWindow().addEventListener("IESetCookie", onIESetCookie, false);
+    let window = Utils.getHiddenWindow();
+    window.addEventListener("IEUserAgentReceived", onIEUserAgentReceived, false);
+    window.addEventListener("IESetCookie", onIESetCookie, false);
+    window.addEventListener("IEBatchSetCookie", onIEBatchSetCookie, false);
   },
   
   _unregisterHandlers: function()
   {
-    Utils.getHiddenWindow().removeEventListener("IEUserAgentReceived", onIEUserAgentReceived, false);
-    Utils.getHiddenWindow().removeEventListener("IESetCookie", onIESetCookie, false);
+    let window = Utils.getHiddenWindow();
+    window.removeEventListener("IEUserAgentReceived", onIEUserAgentReceived, false);
+    window.removeEventListener("IESetCookie", onIESetCookie, false);
+    window.removeEventListener("IEBatchSetCookie", onIEBatchSetCookie, false);
   },
 };
 
@@ -250,3 +276,14 @@ function onIESetCookie(event)
   let data = event.detail;
   Services.obs.notifyObservers(subject, topic, data);
 }
+
+/**
+ * Handles 'IEBatchSetCookie' event receiving from the plugin
+ */
+function onIEBatchSetCookie(event)
+{
+  let subject = null;
+  let topic = "fireie-batch-set-cookie";
+  let data = event.detail;
+  Services.obs.notifyObservers(subject, topic, data);
+}
diff --git a/plugin/BrowserHook/AtlDepHook.cpp b/plugin/BrowserHook/AtlDepHook.cpp
index b5cce31..f006021 100644
--- a/plugin/BrowserHook/AtlDepHook.cpp
+++ b/plugin/BrowserHook/AtlDepHook.cpp
@@ -77,6 +77,7 @@ namespace BrowserHook
 	const size_t s_FunctionsCount = sizeof(s_Functions)/sizeof(FunctionInfo);
 
 	// WindowProc thunks 
+#if !defined(_M_X64)
 #pragma pack(push,1)
 	struct _WndProcThunk
 	{
@@ -99,7 +100,34 @@ namespace BrowserHook
 		}
 		return TRUE;
 	}
+#else
+#pragma pack(push,2)
+	struct _WndProcThunk
+	{
+		USHORT  RcxMov;         // mov rcx, pThis
+		ULONG64 RcxImm;         //
+		USHORT  RaxMov;         // mov rax, target
+		ULONG64 RaxImm;         //
+		USHORT  RaxJmp;         // jmp target
+	};
 
+	BOOL CheckThunk(_WndProcThunk* pThunk)
+	{
+		if (pThunk->RcxMov != 0xb948)
+		{
+			return FALSE;
+		}
+		if (pThunk->RaxMov != 0xb848)
+		{
+			return FALSE;
+		}
+		if (pThunk->RaxJmp != 0xe0ff)
+		{
+			return FALSE;
+		}
+		return TRUE;
+	}
+#endif
 	BOOL FixThunk(LONG dwLong)
 	{
 		_WndProcThunk* pThunk = (_WndProcThunk*)dwLong;
diff --git a/plugin/BrowserHook/GestureHandler.cpp b/plugin/BrowserHook/GestureHandler.cpp
index 9257746..e7a2b87 100644
--- a/plugin/BrowserHook/GestureHandler.cpp
+++ b/plugin/BrowserHook/GestureHandler.cpp
@@ -17,10 +17,21 @@ along with Fire-IE.  If not, see <http://www.gnu.org/licenses/>.
 
 #include "StdAfx.h"
 #include "GestureHandler.h"
+#include "App.h"
 
 using namespace BrowserHook;
+using namespace Utils;
 
-std::vector<GestureHandler*> GestureHandler::s_vHandlers;
+GestureHandler::Handlers GestureHandler::s_handlers;
+std::vector<GestureHandler*>& GestureHandler::s_vHandlers = s_handlers.m_vHandlers;
+
+// Automatically cleanup at program exit
+GestureHandler::Handlers::~Handlers()
+{
+	for (size_t i = 0; i < m_vHandlers.size(); i++)
+		delete m_vHandlers[i];
+	m_vHandlers.clear();
+}
 
 GestureHandler::GestureHandler() :
 	m_state(GS_None), m_bEnabled(true)
@@ -51,7 +62,7 @@ void GestureHandler::forwardAllOrigin(HWND hOrigin)
 	if (size = m_vMessages.size())
 	{
 		MSG* msg = &m_vMessages[size - 1];
-		::PostMessage(hOrigin, msg->message, msg->wParam, msg->lParam);
+		::SendMessage(hOrigin, msg->message, msg->wParam, msg->lParam);
 	}
 	m_vMessages.clear();
 }
@@ -59,13 +70,17 @@ void GestureHandler::forwardAllOrigin(HWND hOrigin)
 void GestureHandler::forwardAllTarget(HWND hOrigin, HWND hTarget)
 {
 	_ASSERT(hOrigin != NULL && hTarget != NULL);
+	bool oopp = App::GetApplication() == App::OOPP;
 	for (std::vector<MSG>::iterator iter = m_vMessages.begin();
 		iter != m_vMessages.end(); ++iter)
 	{
 		CPoint pt(iter->lParam);
 		ClientToScreen(hOrigin, &pt);
 		ScreenToClient(hTarget, &pt);
-		::PostMessage(hTarget, iter->message, iter->wParam, MAKELPARAM(pt.x, pt.y));
+		if (oopp) // When OOPP is on, forwarding to firefox must use PostMessage to avoid deadlocks
+			::PostMessage(hTarget, iter->message, iter->wParam, MAKELPARAM(pt.x, pt.y));
+		else
+			::SendMessage(hTarget, iter->message, iter->wParam, MAKELPARAM(pt.x, pt.y));
 	}
 	m_vMessages.clear();
 }
@@ -101,7 +116,7 @@ MessageHandleResult GestureHandler::handleMessage(MSG* msg)
 
 void GestureHandler::forwardOrigin(MSG* pMsg)
 {
-	::PostMessage(pMsg->hwnd, pMsg->message, pMsg->wParam, pMsg->lParam);
+	::SendMessage(pMsg->hwnd, pMsg->message, pMsg->wParam, pMsg->lParam);
 }
 
 void GestureHandler::forwardTarget(MSG* pMsg, HWND hTarget)
@@ -109,7 +124,10 @@ void GestureHandler::forwardTarget(MSG* pMsg, HWND hTarget)
 	CPoint pt(pMsg->lParam);
 	ClientToScreen(pMsg->hwnd, &pt);
 	ScreenToClient(hTarget, &pt);
-	::PostMessage(hTarget, pMsg->message, pMsg->wParam, MAKELPARAM(pt.x, pt.y));
+	if (App::GetApplication() == App::OOPP)
+		::PostMessage(hTarget, pMsg->message, pMsg->wParam, MAKELPARAM(pt.x, pt.y));
+	else
+		::SendMessage(hTarget, pMsg->message, pMsg->wParam, MAKELPARAM(pt.x, pt.y));
 }
 
 void GestureHandler::setEnabled(bool bEnabled)
diff --git a/plugin/BrowserHook/GestureHandler.h b/plugin/BrowserHook/GestureHandler.h
index 26e7875..2e53c44 100644
--- a/plugin/BrowserHook/GestureHandler.h
+++ b/plugin/BrowserHook/GestureHandler.h
@@ -37,7 +37,12 @@ namespace BrowserHook
 	private:
 		bool shouldKeepTrack(MessageHandleResult res) const;
 
-		static std::vector<GestureHandler*> s_vHandlers;
+		static struct Handlers {
+			~Handlers();
+			std::vector<GestureHandler*> m_vHandlers;
+		} s_handlers;
+
+		static std::vector<GestureHandler*>& s_vHandlers;
 	protected:
 		GestureState m_state;
 		bool m_bEnabled;
diff --git a/plugin/HttpMonitor/ContentType.h b/plugin/HttpMonitor/ContentType.h
new file mode 100644
index 0000000..db6b04f
--- /dev/null
+++ b/plugin/HttpMonitor/ContentType.h
@@ -0,0 +1,99 @@
+/*
+This file is part of Fire-IE.
+
+Fire-IE is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Fire-IE is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Fire-IE.  If not, see <http://www.gnu.org/licenses/>.
+*/
+#pragma once
+
+/* nsIContentPolicy content type constants definition */
+
+namespace HttpMonitor
+{
+	typedef unsigned long ContentType_T;
+
+	namespace ContentType
+	{
+		const unsigned long TYPE_OTHER       = 1;
+
+		/**
+		* Indicates an executable script (such as JavaScript).
+		*/
+		const unsigned long TYPE_SCRIPT      = 2;
+
+		/**
+		* Indicates an image (e.g., IMG elements).
+		*/
+		const unsigned long TYPE_IMAGE       = 3;
+
+		/**
+		* Indicates a stylesheet (e.g., STYLE elements).
+		*/
+		const unsigned long TYPE_STYLESHEET  = 4;
+
+		/**
+		* Indicates a generic object (plugin-handled content typically falls under
+		* this category).
+		*/
+		const unsigned long TYPE_OBJECT      = 5;
+
+		/**
+		* Indicates a document at the top-level (i.e., in a browser).
+		*/
+		const unsigned long TYPE_DOCUMENT    = 6;
+
+		/**
+		* Indicates a document contained within another document (e.g., IFRAMEs,
+		* FRAMES, and OBJECTs).
+		*/
+		const unsigned long TYPE_SUBDOCUMENT = 7;
+
+		/**
+		* Indicates a timed refresh.
+		*
+		* shouldLoad will never get this, because it does not represent content
+		* to be loaded (the actual load triggered by the refresh will go through
+		* shouldLoad as expected).
+		*
+		* shouldProcess will get this for, e.g., META Refresh elements and HTTP
+		* Refresh headers.
+		*/
+		const unsigned long TYPE_REFRESH     = 8;
+
+		/**
+		* Indicates an XBL binding request, triggered either by -moz-binding CSS
+		* property or Document.addBinding method.
+		*/
+		const unsigned long TYPE_XBL         = 9;
+
+		/**
+		* Indicates a ping triggered by a click on <A PING="..."> element.
+		*/
+		const unsigned long TYPE_PING        = 10;
+
+		/**
+		* Indicates an XMLHttpRequest.
+		*/
+		const unsigned long TYPE_XMLHTTPREQUEST = 11;
+
+		/**
+		* Indicates a request by a plugin.
+		*/
+		const unsigned long TYPE_OBJECT_SUBREQUEST = 12;
+
+		/**
+		* Indicates a DTD loaded by an XML document.
+		*/
+		const unsigned long TYPE_DTD = 13;
+	}
+}
diff --git a/plugin/HttpMonitor/HttpMonitorApp.cpp b/plugin/HttpMonitor/HttpMonitorApp.cpp
index 86a9fe6..f02f656 100644
--- a/plugin/HttpMonitor/HttpMonitorApp.cpp
+++ b/plugin/HttpMonitor/HttpMonitorApp.cpp
@@ -3,27 +3,66 @@
 
 namespace HttpMonitor
 {
-	HRESULT HttpMonitorAPP::FinalConstruct() 
+
+	HttpMonitorAPP::~HttpMonitorAPP()
 	{
+	}
+
+	HRESULT HttpMonitorAPP::FinalConstruct() {
+	
+		m_Sink = HttpMonitorStartPolicy::GetSink(this);
+	
+		m_nDataWritten = 0;
+
 		return S_OK;
 	}
 
 	STDMETHODIMP HttpMonitorAPP::Start(
-		/* [in] */ LPCWSTR url,
-		/* [in] */ IInternetProtocolSink *protocol_sink,
-		/* [in] */ IInternetBindInfo *bind_info,
-		/* [in] */ DWORD flags,
-		/* [in] */ HANDLE_PTR reserved)
+			/* [in] */ LPCWSTR url,
+			/* [in] */ IInternetProtocolSink *protocol_sink,
+			/* [in] */ IInternetBindInfo *bind_info,
+			/* [in] */ DWORD flags,
+			/* [in] */ HANDLE_PTR reserved)
 	{
 		return BaseClass::Start(url, protocol_sink, bind_info, flags, reserved);
 	}
 
 	STDMETHODIMP HttpMonitorAPP::Read(
-		/* [in, out] */ void *pv,
-		/* [in] */ ULONG cb,
-		/* [out] */ ULONG *pcbRead)
+								   /* [in, out] */ void *pv,
+								   /* [in] */ ULONG cb,
+								   /* [out] */ ULONG *pcbRead)
 	{
-		return BaseClass::Read(pv, cb, pcbRead);
+		const BYTE * pBuffer = m_Sink->pTargetBuffer;
+		DWORD dwBufLen = m_Sink->dwTargetBufSize;
+		if ( pBuffer )
+		{
+			DWORD dwSize = 0;
+			if ( dwBufLen > m_nDataWritten )
+			{
+				dwSize = min(dwBufLen - m_nDataWritten, cb);
+			}
+
+			* pcbRead = dwSize;
+
+			if ( dwSize > 0 )
+			{
+				memcpy( pv, pBuffer + m_nDataWritten, dwSize );
+
+				m_nDataWritten += dwSize;
+
+				if ( m_nDataWritten == dwBufLen ) return S_FALSE;
+			}
+			else
+			{
+				return S_FALSE;
+			}
+
+			return S_OK;
+		}
+		else
+		{
+			return BaseClass::Read(pv, cb, pcbRead);
+		}
 	}
 
 	STDMETHODIMP HttpMonitorAPP::Terminate(/* [in] */ DWORD options)
diff --git a/plugin/HttpMonitor/HttpMonitorApp.h b/plugin/HttpMonitor/HttpMonitorApp.h
index 75eb5a0..3b0383a 100644
--- a/plugin/HttpMonitor/HttpMonitorApp.h
+++ b/plugin/HttpMonitor/HttpMonitorApp.h
@@ -4,13 +4,9 @@
 
 namespace HttpMonitor
 {
-
 	class HttpMonitorAPP;
+	typedef PassthroughAPP::CustomSinkStartPolicy<HttpMonitorAPP, MonitorSink> HttpMonitorStartPolicy;
 
-	typedef PassthroughAPP::CustomSinkStartPolicy<HttpMonitorAPP, MonitorSink>
-		HttpMonitorStartPolicy;
-
-	/** coral ietabڹ˹httpûнйˣԽӿڲ*/
 	class HttpMonitorAPP : public PassthroughAPP::CInternetProtocol<HttpMonitorStartPolicy>
 	{
 		typedef PassthroughAPP::CInternetProtocol<HttpMonitorStartPolicy> BaseClass;
@@ -19,7 +15,7 @@ namespace HttpMonitor
 
 		HttpMonitorAPP() {}
 
-		~HttpMonitorAPP() {}
+		~HttpMonitorAPP();
 
 		// IInternetProtocolRoot
 		STDMETHODIMP Start(
@@ -40,6 +36,14 @@ namespace HttpMonitor
 	public:
 
 		HRESULT FinalConstruct();
+
+	private:
+
+		/** Ӧ MonitorSink  */
+		MonitorSink *m_Sink;
+
+		/** , Ϊ Read() ᱻ, Ҫһ¼Ѿ Read ˶ */
+		DWORD m_nDataWritten;
 	};
 
 }
diff --git a/plugin/HttpMonitor/MonitorSink.cpp b/plugin/HttpMonitor/MonitorSink.cpp
index 4bad725..d62567b 100644
--- a/plugin/HttpMonitor/MonitorSink.cpp
+++ b/plugin/HttpMonitor/MonitorSink.cpp
@@ -8,9 +8,28 @@
 #include "MonitorSink.h"
 #include "PluginApp.h"
 #include "ScriptablePluginObject.h"
+#include "abp/AdBlockPlus.h"
+#include "URL.h"
 
 namespace HttpMonitor
 {
+	
+	/** 1x1 Ŀհ͸ GIF ļ, ͼƬ */
+	static const BYTE  TRANSPARENT_GIF_1x1 [] =
+	{
+		0x47,0x49,0x46,0x38,0x39,0x61,0x01,0x00,/**/ 0x01,0x00,0x91,0x00,0x00,0x00,0x00,0x00,
+		0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,/**/ 0x00,0x21,0xf9,0x04,0x05,0x14,0x00,0x02,
+		0x00,0x2c,0x00,0x00,0x00,0x00,0x01,0x00,/**/ 0x01,0x00,0x00,0x02,0x02,0x54,0x01,0x00,
+		0x3b
+	};
+	static const DWORD  TRANSPARENT_GIF_1x1_LENGTH = sizeof(TRANSPARENT_GIF_1x1);
+	/** հ HTML, ҳ */
+	static const BYTE   BLANK_HTML []= "<HTML></HTML>";
+	static const DWORD  BLANK_HTML_LENGTH = sizeof(BLANK_HTML)-1;
+
+	static const BYTE   EMPTY_FILE []= "";
+	static const DWORD  EMPTY_FILE_LENGTH = sizeof(EMPTY_FILE)-1;
+
 	//  \0 ָ Raw HTTP Header ת \r\n ָ Header
 	void HttpRawHeader2CrLfHeader(LPCSTR szRawHeader, CString & strCrLfHeader)
 	{
@@ -43,12 +62,12 @@ namespace HttpMonitor
 
 			size_t nSize = pEnd - pStart;
 			size_t nBufLen = nSize + 2;		// ַ 0 
-			LPWSTR lpBuffer = (LPWSTR)VirtualAlloc( NULL, nBufLen * sizeof(WCHAR), MEM_COMMIT, PAGE_READWRITE );
+			LPWSTR lpBuffer = (LPWSTR)malloc(nBufLen * sizeof(WCHAR));
 			if ( !lpBuffer ) break;
 
 			if (wcsncpy_s( lpBuffer, nBufLen, pStart, nSize))
 			{
-				VirtualFree( lpBuffer, 0, MEM_RELEASE);
+				free(lpBuffer);
 				break;
 			}
 
@@ -61,8 +80,94 @@ namespace HttpMonitor
 		return r;
 	}
 
+	bool FuzzyUrlCompare( LPCTSTR lpszUrl1, LPCTSTR lpszUrl2 )
+	{
+		static const TCHAR ANCHOR = _T('#');
+		static const TCHAR FILE_PROTOCOL [] = _T("file://");
+		static const size_t FILE_PROTOCOL_LENGTH = _tcslen(FILE_PROTOCOL);
+
+		bool bMatch = true;
+
+		if ( lpszUrl1 && lpszUrl2 )
+		{
+			TCHAR szDummy1[MAX_PATH];
+			TCHAR szDummy2[MAX_PATH];
+
+			if ( _tcsncmp( lpszUrl1, FILE_PROTOCOL, FILE_PROTOCOL_LENGTH ) == 0 )
+			{
+				DWORD dwLen = MAX_PATH;
+				if ( PathCreateFromUrl( lpszUrl1, szDummy1, & dwLen, 0 ) == S_OK )
+				{
+					lpszUrl1 = szDummy1;
+				}
+			}
+
+			if ( _tcsncmp( lpszUrl2, FILE_PROTOCOL, FILE_PROTOCOL_LENGTH ) == 0 )
+			{
+				DWORD dwLen = MAX_PATH;
+				if ( PathCreateFromUrl( lpszUrl2, szDummy2, & dwLen, 0 ) == S_OK )
+				{
+					lpszUrl2 = szDummy2;
+				}
+			}
+
+			do
+			{
+				if ( *lpszUrl1 != *lpszUrl2 )
+				{
+					if ( ( ( ANCHOR == *lpszUrl1 ) && ( 0 == *lpszUrl2 ) ) ||
+						( ( ANCHOR == *lpszUrl2 ) && ( 0 == *lpszUrl1 ) ) )
+					{
+						bMatch = true;
+					}
+					else
+					{
+						bMatch = false;
+					}
+
+					break;
+				}
+
+				lpszUrl1++;
+				lpszUrl2++;
+
+			} while ( *lpszUrl1 || *lpszUrl2 );
+		}
+
+		return bMatch;
+	}
+
+	// converts content types from nsIContentPolicy to ABP bit mask style
+	abp::ContentType_T nsItoABP(HttpMonitor::ContentType_T contentType)
+	{
+		static abp::ContentType_T typeMap[] = { 0,
+			abp::UNKNOWN_OTHER,
+			abp::SCRIPT,
+			abp::IMAGE,
+			abp::STYLESHEET,
+			abp::OBJECT,
+			abp::DOCUMENT,
+			abp::SUBDOCUMENT,
+			0,/* Redirect */
+			abp::XBL,
+			abp::PING,
+			abp::XMLHTTPREQUEST,
+			abp::OBJECT_SUBREQUEST,
+			abp::DTD
+		};
+
+		return typeMap[contentType];
+	}
+
+	// MonitorSink implementation
+
 	MonitorSink::MonitorSink()
 	{
+		pTargetBuffer = NULL;
+		dwTargetBufSize = 0;
+
+		m_pIEHostWindow = NULL;
+		m_bIsSubRequest = true;
 	}
 
 	STDMETHODIMP MonitorSink::BeginningTransaction(
@@ -77,6 +182,17 @@ namespace HttpMonitor
 			spHttpNegotiate->BeginningTransaction(szURL, szHeaders,
 			dwReserved, pszAdditionalHeaders) : E_UNEXPECTED;
 
+		// BeginningTransaction() Ǳʼõķ, µõ URL
+		m_strURL = szURL;
+
+		ExtractReferer(pszAdditionalHeaders);
+
+		// ѯӦ CIEHostWindow , ʱõ
+		QueryIEHostWindow();
+
+		// ԶheaderDNT
+		SetCustomHeaders(pszAdditionalHeaders);
+		
 		return hr;
 	}
 
@@ -86,17 +202,80 @@ namespace HttpMonitor
 		LPCWSTR szRequestHeaders,
 		LPWSTR *pszAdditionalRequestHeaders)
 	{
+		if (pszAdditionalRequestHeaders)
+			*pszAdditionalRequestHeaders = NULL;
+
 		CComPtr<IHttpNegotiate> spHttpNegotiate;
 		QueryServiceFromClient(&spHttpNegotiate);
 		
 		HRESULT hr = spHttpNegotiate ?
 			spHttpNegotiate->OnResponse(dwResponseCode, szResponseHeaders,
 			szRequestHeaders, pszAdditionalRequestHeaders) :
-		E_UNEXPECTED;
+		S_OK;
 
 		if ((dwResponseCode >= 200 ) && (dwResponseCode < 300))
 		{
-			ExportCookies(szResponseHeaders);
+			bool bExportCookies = true;
+
+			if (abp::AdBlockPlus::isEnabled())
+			{
+				static const WCHAR CONTENT_TYPE_HEAD [] = L"Content-Type:";
+				LPWSTR pContentType = NULL;
+				size_t nLen = 0;
+				if (ExtractFieldValue(szResponseHeaders, CONTENT_TYPE_HEAD, &pContentType, &nLen))
+				{
+					ContentType_T aContentType = ScanContentType(pContentType);
+
+					if (pContentType) free(pContentType);
+
+					if ((ContentType::TYPE_DOCUMENT == aContentType) && m_bIsSubRequest)
+						aContentType = ContentType::TYPE_SUBDOCUMENT;
+
+					// ֻҳʼӦñ
+					if (m_bIsSubRequest && !CanLoadContent(aContentType))
+					{
+						// ˾Ͳõ Cookie 
+						bExportCookies = false;
+
+						switch (aContentType)
+						{
+						case ContentType::TYPE_IMAGE:
+							{
+								pTargetBuffer = TRANSPARENT_GIF_1x1;
+								dwTargetBufSize = TRANSPARENT_GIF_1x1_LENGTH;
+
+								break;
+							}
+						case ContentType::TYPE_DOCUMENT:
+						case ContentType::TYPE_SUBDOCUMENT:
+							{
+								pTargetBuffer = BLANK_HTML;
+								dwTargetBufSize = BLANK_HTML_LENGTH;
+
+								break;
+							}
+						case ContentType::TYPE_SCRIPT:
+						case ContentType::TYPE_STYLESHEET:
+						default:
+							{
+								pTargetBuffer = EMPTY_FILE;
+								dwTargetBufSize = EMPTY_FILE_LENGTH;
+								break;
+							}
+							//{
+							//	// ͵ļ, ֱֹ
+							//	hr = E_ABORT;
+							//}
+						}
+
+						if (m_spInternetProtocolSink) m_spInternetProtocolSink->ReportData(BSCF_FIRSTDATANOTIFICATION | BSCF_LASTDATANOTIFICATION | BSCF_DATAFULLYAVAILABLE, 0, 0);
+						if (m_spInternetProtocolSink) m_spInternetProtocolSink->ReportResult(S_OK, S_OK, NULL);
+					}
+				}
+			}
+
+			if (bExportCookies)
+				ExportCookies(szResponseHeaders);
 		}
 
 		return hr;
@@ -128,10 +307,34 @@ namespace HttpMonitor
 		return strURL;
 	}
 
+	void MonitorSink::QueryIEHostWindow()
+	{
+		// ѯĸ IE 
+		CComPtr<IWindowForBindingUI> spWindowForBindingUI;
+		if ( SUCCEEDED(QueryServiceFromClient(&spWindowForBindingUI)) && spWindowForBindingUI )
+		{
+			HWND hwndIEServer = NULL;
+			if ( SUCCEEDED(spWindowForBindingUI->GetWindow(IID_IHttpSecurity, &hwndIEServer)) && IsWindow(hwndIEServer))
+			{
+				// õ hwndIEServer ܸ,  Internet Explorer_Server ڻûüʱ(շʱ),
+				// hwndIEServer  Shell Embedding ڵľ; ֮ Internet Explorer_Server ڵľ, ʱҲ
+				// Shell DocObject View ڵľ
+
+				// , ʹ hwndIEServer һֱ, ֱҵ CIEHostWindow  ATL Host Ϊֹ. Ϊ˰ȫ, 
+				//  5 
+				m_pIEHostWindow = CIEHostWindow::FromChildWindow(hwndIEServer);
+			}
+		}
+
+		//  URL ʶǷҳڵ
+		m_bIsSubRequest = !(m_pIEHostWindow && FuzzyUrlCompare(m_pIEHostWindow->GetLoadingURL(), m_strURL));
+	}
+
 	void MonitorSink::ExportCookies(LPCWSTR szResponseHeaders)
 	{
 		static const WCHAR SET_COOKIE_HEAD [] = L"\r\nSet-Cookie:";
 
+		std::vector<UserMessage::SetFirefoxCookieParams> vCookieParams;
 		LPWSTR p = (LPWSTR)szResponseHeaders;
 		LPWSTR lpCookies = NULL;
 		size_t nCookieLen = 0;
@@ -141,13 +344,114 @@ namespace HttpMonitor
 			{
 				CString strURL = GetBindURL();
 				CString strCookie((LPCTSTR)CW2T(lpCookies));
-				TRACE(_T("[ExportCookies] URL: %s  Cookie: %s\n"), strURL, strCookie);
-				CIEHostWindow::SetFirefoxCookie(strURL, strCookie);
-				VirtualFree(lpCookies, 0, MEM_RELEASE);
+				free(lpCookies);
 				lpCookies = NULL;
+
+				UserMessage::SetFirefoxCookieParams cookieParam;
+				cookieParam.strURL = strURL;
+				cookieParam.strCookie = strCookie;
+				vCookieParams.push_back(cookieParam);
+				TRACE(_T("[ExportCookies] URL: %s  Cookie: %s\n"), strURL, strCookie);
 				nCookieLen = 0;
 			}
+		}
+		if (vCookieParams.size())
+			CIEHostWindow::SetFirefoxCookie(std::move(vCookieParams));
+	}
 
+	ContentType_T MonitorSink::ScanContentType(LPCWSTR szContentType)
+	{
+		static const struct	{ const wchar_t * name;	const int value; } MAP [] = {
+			{L"image/", ContentType::TYPE_IMAGE},
+			{L"text/css", ContentType::TYPE_STYLESHEET},
+			{L"text/javascript", ContentType::TYPE_SCRIPT},
+			{L"text/", ContentType::TYPE_DOCUMENT},
+			{L"application/x-javascript", ContentType::TYPE_SCRIPT},
+			{L"application/javascript", ContentType::TYPE_SCRIPT},
+			{L"application/", ContentType::TYPE_OBJECT},
+		};
+
+		for ( int i = 0; i < ARRAYSIZE(MAP); i++ )
+		{
+			if ( _wcsnicmp(MAP[i].name, szContentType, wcslen(MAP[i].name)) == 0 )
+			{
+				return MAP[i].value;
+			}
+		}
+
+		return ContentType::TYPE_OTHER;
+	}
+
+	void MonitorSink::ExtractReferer(LPWSTR *pszAdditionalHeaders)
+	{
+		if ( pszAdditionalHeaders )
+		{
+			static const WCHAR REFERER [] = L"Referer:";
+
+			LPWSTR lpReferer = NULL;
+			size_t nRefererLen = 0;
+			if (ExtractFieldValue(*pszAdditionalHeaders, REFERER, &lpReferer, &nRefererLen))
+			{
+				m_strReferer = lpReferer;
+
+				free(lpReferer);
+			}
+		}
+	}
+	bool MonitorSink::CanLoadContent(ContentType_T aContentType)
+	{
+		// stub implementation, filter baidu logo
+		/*bool result = m_strURL != _T("http://www.baidu.com/img/baidu_sylogo1.gif")
+			&& m_strURL != _T("http://www.baidu.com/img/baidu_jgylogo3.gif")
+			&& m_strURL != _T("http://img.baidu.com/img/post-jg.gif")
+			&& m_strURL.Find(_T("http://tb2.bdstatic.com/tb/static-common/img/tieba_logo")) != 0
+			&& m_strURL.Find(_T("http://360.cn")) != 0
+			&& m_strURL.Find(_T("http://static.youku.com/v1.0.0223/v/swf")) != 0
+		;*/ /*!re::RegExp(_T("/http:\\/\\/\\w+\\.(qhimg\\.com)/i")).test(std::wstring(m_strURL.GetString()));*/
+		bool thirdParty = m_strReferer.GetLength() ? Utils::IsThirdPartyRequest(m_strURL, m_strReferer) : false;
+		const CString& referer =  m_strReferer.GetLength() ? m_strReferer : m_strURL;
+
+		bool result = abp::AdBlockPlus::shouldLoad(m_strURL.GetString(), nsItoABP(aContentType), referer.GetString(), thirdParty);
+
+		TRACE(_T("[CanLoadContent]: [%s] [%s] %s [Referer: %s]\n"), result ? _T("true") : _T("false"),
+			m_bIsSubRequest ? _T("sub") : _T("main"), m_strURL, m_strReferer);
+		return result;
+	}
+
+	void MonitorSink::SetCustomHeaders(LPWSTR *pszAdditionalHeaders)
+	{
+		if (pszAdditionalHeaders && *pszAdditionalHeaders)
+		{
+			CStringW strHeaders(*pszAdditionalHeaders);
+			size_t nOrigLen = strHeaders.GetLength();
+
+			if (abp::AdBlockPlus::shouldSendDNTHeader(m_strURL.GetString()))
+			{
+				LPWSTR lpDNT = NULL;
+				size_t nDNTLen = 0;
+				bool hasDNT = false;
+				if (ExtractFieldValue(*pszAdditionalHeaders, L"DNT:", &lpDNT, &nDNTLen))
+				{
+					if (nDNTLen && lpDNT[0] == L'1')
+					{
+						// ѾDNTͷˣټ
+						hasDNT = true;
+					}
+					if (lpDNT) free(lpDNT);
+				}
+				//  DoNotTrack (DNT) ͷ
+				if (!hasDNT)
+					strHeaders.Append(L"DNT: 1\r\n");
+			}
+
+			if (strHeaders.GetLength() == nOrigLen)
+				return; // ûĹֱӷ
+
+			size_t nLen = strHeaders.GetLength() + 2;
+			if (*pszAdditionalHeaders = (LPWSTR)CoTaskMemRealloc(*pszAdditionalHeaders, nLen * sizeof(WCHAR)))
+			{
+				wcscpy_s(*pszAdditionalHeaders, nLen, strHeaders);
+			}
 		}
 	}
 
@@ -161,9 +465,16 @@ namespace HttpMonitor
 		switch ( ulStatusCode )
 		{
 			 
-		// ض, ¼¼ URL
 		case BINDSTATUS_REDIRECTING:
 			{
+				// ض, ¼¼ URL
+				if (!m_bIsSubRequest)
+				{
+					if (m_pIEHostWindow)
+						m_pIEHostWindow->SetLoadingURL(szStatusText);
+					m_strURL = szStatusText;
+				}
+
 				// ܶվ¼ʱ302תʱCookie, Gmail, ҲҪ Cookie
 				CComPtr<IWinInetHttpInfo> spWinInetHttpInfo;
 				if (SUCCEEDED(m_spTargetProtocol->QueryInterface(&spWinInetHttpInfo)) && spWinInetHttpInfo )
diff --git a/plugin/HttpMonitor/MonitorSink.h b/plugin/HttpMonitor/MonitorSink.h
index ac36699..bfaf0be 100644
--- a/plugin/HttpMonitor/MonitorSink.h
+++ b/plugin/HttpMonitor/MonitorSink.h
@@ -1,6 +1,7 @@
 #pragma once
 
 #include <urlmon.h>
+#include "ContentType.h"
 
 class CIEHostWindow;
 
@@ -62,10 +63,50 @@ namespace HttpMonitor
 		STDMETHODIMP Switch(PROTOCOLDATA *pProtocolData);
 
 	private:
+		/** ѯӦ CIEHostWindow  */
+		void QueryIEHostWindow();
+
+		// ReportProgress() ڲרãǷҪ
+		bool CanLoadContent(ContentType_T aContentType);
+
+		/**  Content-Type  nsIContentPolicy Ķ */
+		ContentType_T ScanContentType(LPCWSTR szContentType);
+
 		// Current http request URL
 		CString GetBindURL() const;
 
 		// Export IE cookies to firefox by parsing the HTTP response headers
 		void ExportCookies(LPCWSTR szResponseHeaders);
+
+		// RefererϢ
+		void ExtractReferer(LPWSTR *pszAdditionalHeaders);
+
+		// Զheaders
+		void SetCustomHeaders(LPWSTR *pszAdditionalHeaders);
+
+		/**  URL */
+		CString m_strURL;
+
+		/**  Referer */
+		CString m_strReferer;
+
+		/** 𱾴 CIEHostWindow  */
+		CIEHostWindow * m_pIEHostWindow;
+
+		/** Ƿҳ, HTMLҳͼƬűȵ */
+		bool m_bIsSubRequest;
+
+	private:
+
+		friend class HttpMonitorAPP;
+
+		/**
+		 * ˹, ԭ,  HTML ͼƬ, Ǹ IE һ
+		 * ļȥ, ͹. ļ, һ, Ȼ
+		 *  IE ȡʱѻݷظ IE.
+		 */
+		const BYTE * pTargetBuffer;
+		DWORD dwTargetBufSize;
 	};
+
 }
diff --git a/plugin/IEHostWindow.cpp b/plugin/IEHostWindow.cpp
index 5c2a862..4416a56 100644
--- a/plugin/IEHostWindow.cpp
+++ b/plugin/IEHostWindow.cpp
@@ -24,10 +24,20 @@ along with Fire-IE.  If not, see <http://www.gnu.org/licenses/>.
 #include <comutil.h>
 #include "IEControlSite.h"
 #include "PluginApp.h"
+#include "HttpMonitorApp.h"
 #include "IEHostWindow.h"
 #include "plugin.h"
+#include "URL.h"
+#include "abp/AdBlockPlus.h"
+#include "re/strutils.h"
+#include "OS.h"
+#include "App.h"
 
 using namespace UserMessage;
+using namespace Utils;
+using namespace abp;
+using namespace std;
+using namespace re::strutils;
 
 // Initilizes the static member variables of CIEHostWindow
 
@@ -38,12 +48,15 @@ CCriticalSection CIEHostWindow::s_csNewIEWindowMap;
 CSimpleMap<HWND, CIEHostWindow *> CIEHostWindow::s_UtilsIEWindowMap;
 CCriticalSection CIEHostWindow::s_csUtilsIEWindowMap;
 CString CIEHostWindow::s_strIEUserAgent = _T("");
+const TCHAR* const CIEHostWindow::s_strElemHideClass = _T("fireie-elemhide-style");
 
 // CIEHostWindow dialog
 
 IMPLEMENT_DYNAMIC(CIEHostWindow, CDialog)
 
-	CIEHostWindow::CIEHostWindow(Plugin::CPlugin* pPlugin /*=NULL*/, CWnd* pParent /*=NULL*/)
+typedef PassthroughAPP::CMetaFactory<PassthroughAPP::CComClassFactoryProtocol, HttpMonitor::HttpMonitorAPP> MetaFactory;
+
+CIEHostWindow::CIEHostWindow(Plugin::CPlugin* pPlugin /*=NULL*/, CWnd* pParent /*=NULL*/)
 	: CDialog(CIEHostWindow::IDD, pParent)
 	, m_pPlugin(pPlugin)
 	, m_bCanBack(FALSE)
@@ -59,6 +72,7 @@ IMPLEMENT_DYNAMIC(CIEHostWindow, CDialog)
 	, m_pNavigateParams(NULL)
 	, m_strStatusText(_T(""))
 	, m_bUtils(false)
+	, m_strLoadingUrl(_T(""))
 {
 	FBResetFindStatus();
 }
@@ -94,6 +108,26 @@ CIEHostWindow* CIEHostWindow::FromInternetExplorerServer(HWND hwndIEServer)
 	return pInstance;
 }
 
+CIEHostWindow* CIEHostWindow::FromChildWindow(HWND hwndChild)
+{
+	// һѭң 5 㣩
+	HWND hwnd = hwndChild;
+	int count = 0;
+	while ((count++ < 5) && (hwnd = ::GetParent(hwnd)))
+	{
+		CString strClassName;
+		GetClassName(hwnd, strClassName.GetBuffer(MAX_PATH), MAX_PATH);
+		strClassName.ReleaseBuffer();
+		if (strClassName != STR_WINDOW_CLASS_NAME)
+			continue;
+
+		// Window LongȡCIEHostWindowָ 
+		CIEHostWindow* pInstance = reinterpret_cast<CIEHostWindow* >(::GetWindowLongPtrA(hwnd, GWLP_USERDATA));
+		return pInstance;
+	}
+	return NULL;
+}
+
 CIEHostWindow* CIEHostWindow::CreateNewIEHostWindow(CWnd* pParentWnd, DWORD dwId, bool isUtils)
 {
 	CIEHostWindow *pIEHostWindow = NULL;
@@ -169,13 +203,21 @@ HWND CIEHostWindow::GetAnyUtilsHWND()
 	return hwnd;
 }
 
-void CIEHostWindow::SetFirefoxCookie(CString strURL, CString strCookie)
+void CIEHostWindow::SetFirefoxCookie(vector<UserMessage::SetFirefoxCookieParams>&& vCookieParams)
 {
-	HWND hwnd = GetAnyUtilsHWND();
-	if (hwnd)
+	CIEHostWindow* pWindow = GetAnyUtilsWindow();
+	if (pWindow)
 	{
-		SetFirefoxCookieParams params = {strURL, strCookie};
-		::SendMessage(hwnd, WM_USER_MESSAGE, WPARAM_SET_FIREFOX_COOKIE, reinterpret_cast<LPARAM>(&params));
+		vector<UserMessage::SetFirefoxCookieParams>* pvParams = 
+			new vector<UserMessage::SetFirefoxCookieParams>(std::move(vCookieParams));
+		pWindow->RunAsync([=]
+		{
+			if (pWindow->m_pPlugin)
+			{
+				pWindow->m_pPlugin->SetFirefoxCookie(*pvParams);
+			}
+			delete pvParams;
+		});
 	}
 }
 
@@ -250,8 +292,15 @@ void CIEHostWindow::UninitIE()
 	s_csUtilsIEWindowMap.Lock();
 	s_UtilsIEWindowMap.Remove(GetSafeHwnd());
 	s_csUtilsIEWindowMap.Unlock();
-}
 
+	if (m_bUtils)
+	{
+		AdBlockPlus::clearFilters();
+#ifdef MATCHER_PERF
+		AdBlockPlus::showPerfInfo();
+#endif
+	}
+}
 
 void CIEHostWindow::OnSize(UINT nType, int cx, int cy)
 {
@@ -267,63 +316,30 @@ LRESULT CIEHostWindow::OnUserMessage(WPARAM wParam, LPARAM lParam)
 {
 	switch(wParam)
 	{
-	case WPARAM_SET_FIREFOX_COOKIE:
-		{
-			SetFirefoxCookieParams* pData = reinterpret_cast<SetFirefoxCookieParams*>(lParam);
-			OnSetFirefoxCookie(pData->strURL, pData->strCookie);
-		}
-		break;
-	case WPARAM_UTILS_PLUGIN_INIT:
-		{
-			OnUtilsPluginInit();
-		}
-		break;
-	case WPARAM_CONTENT_PLUGIN_INIT:
-		{
-			OnContentPluginInit();
-		}
-		break;
-	case WPARAM_NAVIGATE:
-		{
-			OnNavigate();
-		}
-		break;
-	case WPARAM_REFRESH:
+	case WPARAM_RUN_ASYNC_CALL:
 		{
-			OnRefresh();
-		}
-		break;
-	case WPARAM_STOP:
-		{
-			OnStop();
-		}
-		break;
-	case WPARAM_BACK:
-		{
-			OnBack();
-		}
-		break;
-	case WPARAM_FORWARD:
-		{
-			OnForward();
+			ICallable* callable = reinterpret_cast<ICallable*>(lParam);
+			if (m_setCallables.find(callable) != m_setCallables.end())
+			{
+				m_setCallables.erase(callable);
+				callable->call();
+				delete callable;
+			}
+			break;
 		}
+	case WPARAM_ABP_FILTER_LOADED:
+		OnABPFilterLoaded();
 		break;
-	case WPARAM_EXEC_OLE_CMD:
-		{
-			OLECMDID id = (OLECMDID)lParam;
-			ExecOleCmd(id);
-		}
+	case WPARAM_ABP_LOAD_FAILURE:
+		OnABPLoadFailure();
 		break;
-	case WPARAM_DISPLAY_SECURITY_INFO:
-		{
-			OnDisplaySecurityInfo();
-		}
+	default:
+		TRACE(_T("Unexpected user message sent: %d\n"), (int)wParam);
 		break;
 	}
 	return 0;
 }
 
-
 BEGIN_EVENTSINK_MAP(CIEHostWindow, CDialog)
 	ON_EVENT(CIEHostWindow, IDC_IE_CONTROL, DISPID_COMMANDSTATECHANGE, CIEHostWindow::OnCommandStateChange, VTS_I4 VTS_BOOL)
 	ON_EVENT(CIEHostWindow, IDC_IE_CONTROL, DISPID_STATUSTEXTCHANGE  , CIEHostWindow::OnStatusTextChange, VTS_BSTR)
@@ -372,95 +388,6 @@ HRESULT FillSafeArray(_variant_t &vDest, LPCSTR szSrc)
 	return NOERROR;
 }
 
-CString GetHostFromUrl(const CString& strUrl)
-{
-	CString strHost(strUrl);
-	int pos = strUrl.Find(_T("://"));
-	if (pos != -1)
-	{
-		strHost.Delete(0, pos+3);
-
-	}
-	pos = strHost.Find(_T("/"));
-	if (pos != -1)
-	{
-		strHost = strHost.Left(pos);
-	}
-	return strHost;
-}
-
-CString GetProtocolFromUrl(const CString& strUrl)
-{
-	int pos = strUrl.Find(_T("://"));
-	if (pos != -1)
-	{
-		return strUrl.Left(pos);
-	}
-	return _T("http"); // Assume http
-}
-
-CString GetPathFromUrl(const CString& strUrl)
-{
-	CString strPath(strUrl);
-	int pos = strUrl.Find(_T("://"));
-	if (pos != -1)
-	{
-		strPath.Delete(0, pos+3);
-
-	}
-	pos = strPath.Find(_T('/'));
-	if (pos != -1)
-	{
-		strPath = strPath.Mid(pos);
-		pos = strPath.Find(_T('?'));
-		if (pos != -1)
-		{
-			strPath = strPath.Left(pos);
-		}
-		pos = strPath.ReverseFind(_T('/'));
-		// pos can't be -1 here
-		strPath = strPath.Left(pos + 1);
-	}
-	else
-	{
-		strPath = _T("/");
-	}
-	return strPath;
-}
-
-CString GetURLRelative(const CString& baseURL, const CString relativeURL)
-{
-	if (relativeURL.Find(_T("://")) != -1)
-	{
-		// complete url, return immediately
-		// test url: https://addons.mozilla.org/zh-CN/firefox/
-		return relativeURL;
-	}
-
-	CString protocol = GetProtocolFromUrl(baseURL);
-	if (relativeURL.GetLength() >= 2 && relativeURL.Left(2) == _T("//"))
-	{
-		// same protocol semi-complete url, return immediately
-		// test url: http://www.windowsazure.com/zh-cn/
-		return protocol + _T(":") + relativeURL;
-	}
-
-	CString host = GetHostFromUrl(baseURL);
-	if (relativeURL.GetLength() && relativeURL[0] == _T('/'))
-	{
-		// root url
-		// test url: https://mail.qq.com/cgi-bin/loginpage?
-		return protocol + _T("://") + host + relativeURL;
-	}
-	else
-	{
-		CString path = GetPathFromUrl(baseURL);
-		// relative url
-		// test url: http://www.update.microsoft.com/windowsupdate/v6/thanks.aspx?ln=zh-cn&&thankspage=5
-		return protocol + _T("://") + host + path + relativeURL;
-	}
-}
-
 void CIEHostWindow::Navigate(const CString& strURL, const CString& strPost, const CString& strHeaders)
 {
 	m_csNavigateParams.Lock();
@@ -479,28 +406,28 @@ void CIEHostWindow::Navigate(const CString& strURL, const CString& strPost, cons
 	m_pNavigateParams->strHeaders = strHeaders;
 	m_csNavigateParams.Unlock();
 
-	//PostMessage(WM_USER_MESSAGE, WPARAM_NAVIGATE, 0);
+	//RunAsync([=] { OnNavigate(); });
 	OnNavigate();
 }
 
 void CIEHostWindow::Refresh()
 {
-	PostMessage(WM_USER_MESSAGE, WPARAM_REFRESH, 0);
+	RunAsync([=] { OnRefresh(); });
 }
 
 void CIEHostWindow::Stop()
 {
-	PostMessage(WM_USER_MESSAGE, WPARAM_STOP, 0);
+	RunAsync([=] { OnStop(); });
 }
 
 void CIEHostWindow::Back()
 {
-	PostMessage(WM_USER_MESSAGE, WPARAM_BACK, 0);
+	RunAsync([=] { OnBack(); });
 }
 
 void CIEHostWindow::Forward()
 {
-	PostMessage(WM_USER_MESSAGE, WPARAM_FORWARD, 0);
+	RunAsync([=] { OnForward(); });
 }
 
 void CIEHostWindow::Focus()
@@ -652,27 +579,27 @@ void CIEHostWindow::Zoom(double level)
 
 void CIEHostWindow::DisplaySecurityInfo()
 {
-	PostMessage(WM_USER_MESSAGE, WPARAM_DISPLAY_SECURITY_INFO);
+	RunAsync([=] { OnDisplaySecurityInfo(); });
 }
 
 void CIEHostWindow::SaveAs()
 {
-	PostOleCmd(OLECMDID_SAVEAS);
+	RunAsyncOleCmd(OLECMDID_SAVEAS);
 }
 
 void CIEHostWindow::Print()
 {
-	PostOleCmd(OLECMDID_PRINT);
+	RunAsyncOleCmd(OLECMDID_PRINT);
 }
 
 void CIEHostWindow::PrintPreview()
 {
-	PostOleCmd(OLECMDID_PRINTPREVIEW);
+	RunAsyncOleCmd(OLECMDID_PRINTPREVIEW);
 }
 
 void CIEHostWindow::PrintSetup()
 {
-	PostOleCmd(OLECMDID_PAGESETUP);
+	RunAsyncOleCmd(OLECMDID_PAGESETUP);
 }
 
 void CIEHostWindow::ViewPageSource()
@@ -760,6 +687,26 @@ void CIEHostWindow::ScrollWheelLine(bool up)
 	}
 }
 
+void CIEHostWindow::ABPEnable()
+{
+	AdBlockPlus::enable();
+}
+
+void CIEHostWindow::ABPDisable()
+{
+	AdBlockPlus::disable();
+}
+
+void CIEHostWindow::ABPLoad(const CString& pathname)
+{
+	AdBlockPlus::loadFilterFile(pathname.GetString());
+}
+
+void CIEHostWindow::ABPClear()
+{
+	AdBlockPlus::clearFilters();
+}
+
 CString CIEHostWindow::GetURL()
 {
 	CString url;
@@ -815,15 +762,16 @@ CString CIEHostWindow::GetFaviconURL()
 			{
 				return GetURLRelative(url, contentFaviconURL);
 			}
-			host = GetHostFromUrl(url);
-			if (host != _T(""))
+			URLTokenizer tokens(url.GetString());
+			if (tokens.getAuthority().length())
 			{
-				CString protocol = GetProtocolFromUrl(url);
-				if (protocol.MakeLower() != _T("http") && protocol.MakeLower() != _T("https")) {
+				CString protocol = CString(tokens.protocol.c_str()).MakeLower();
+				if (protocol != _T("http") && protocol != _T("https")) {
 					// force http/https protocols -- others are not supported for purpose of fetching favicons
 					protocol = _T("http");
+					tokens.protocol = protocol.GetString();
 				}
-				favurl = protocol + _T("://") + host + _T("/favicon.ico");
+				favurl = tokens.getRelativeURL(_T("/favicon.ico")).c_str();
 			}
 		}
 	}
@@ -868,17 +816,9 @@ void CIEHostWindow::ExecOleCmd(OLECMDID cmdID)
 	}
 }
 
-void CIEHostWindow::PostOleCmd(OLECMDID cmdID)
-{
-	PostMessage(WM_USER_MESSAGE, WPARAM_EXEC_OLE_CMD, (LPARAM)cmdID);
-}
-
-void CIEHostWindow::OnSetFirefoxCookie(const CString& strURL, const CString& strCookie)
+void CIEHostWindow::RunAsyncOleCmd(OLECMDID cmdID)
 {
-	if (m_pPlugin)
-	{
-		m_pPlugin->SetFirefoxCookie(strURL, strCookie);
-	}
+	RunAsync([=] { ExecOleCmd(cmdID); });
 }
 
 /** @TODO strPostеContent-TypeContent-LengthϢƶstrHeadersУֱȥ*/
@@ -1014,19 +954,20 @@ void CIEHostWindow::OnDisplaySecurityInfo()
 	}
 }
 
-void CIEHostWindow::OnUtilsPluginInit()
+void CIEHostWindow::OnABPFilterLoaded()
 {
 	if (m_pPlugin)
 	{
-		m_pPlugin->OnUtilsPluginInit();
+		m_pPlugin->OnABPFilterLoaded(
+			AdBlockPlus::getNumberOfActiveFilters(), AdBlockPlus::getLoadTicks());
 	}
 }
 
-void CIEHostWindow::OnContentPluginInit()
+void CIEHostWindow::OnABPLoadFailure()
 {
 	if (m_pPlugin)
 	{
-		m_pPlugin->OnContentPluginInit();
+		m_pPlugin->OnABPLoadFailure();
 	}
 }
 
@@ -1051,11 +992,13 @@ void CIEHostWindow::OnIEProgressChanged(INT32 iProgress)
 void CIEHostWindow::OnStatusChanged(const CString& message)
 {
 	m_strStatusText = message;
-
-	if (m_pPlugin)
+	RunAsync([=]
 	{
-		m_pPlugin->SetStatus(message);
-	}
+		if (m_pPlugin)
+		{
+			m_pPlugin->SetStatus(m_strStatusText);
+		}
+	});
 }
 
 void CIEHostWindow::OnCloseIETab()
@@ -1098,6 +1041,56 @@ void CIEHostWindow::OnProgressChange(long Progress, long ProgressMax)
 }
 
 
+static inline BOOL UrlCanHandle(LPCTSTR szUrl)
+{
+	// 1:  C:\Documents and Settings\<username>\My Documents\Filename.mht ļ
+	TCHAR c = _totupper(szUrl[0]);
+	if ( (c >= _T('A')) && (c <= _T('Z')) && (szUrl[1]==_T(':')) && (szUrl[2]==_T('\\')) )
+	{
+		return TRUE;
+	}
+
+	// 2: \\fileserver\folder  UNC ·
+	if ( PathIsUNC(szUrl) )
+	{
+		return TRUE;
+	}
+
+	// 3: http://... https://... file://...
+	URL_COMPONENTS uc;
+	ZeroMemory( &uc, sizeof(uc) );
+	uc.dwStructSize = sizeof(uc);
+	if ( ! InternetCrackUrl( szUrl, 0, 0, &uc ) ) return FALSE;
+
+	switch ( uc.nScheme )
+	{
+	case INTERNET_SCHEME_HTTP:
+	case INTERNET_SCHEME_HTTPS:
+	case INTERNET_SCHEME_FILE:
+		return TRUE;
+	default:
+		{
+			// 4: about:blank
+			return ( _tcsncmp(szUrl, _T("about:"), 6) == 0 );
+		}
+	}
+}
+
+void CIEHostWindow::SetLoadingURL(const CString& url)
+{
+	m_csLoadingUrl.Lock();
+	m_strLoadingUrl = url;
+	m_csLoadingUrl.Unlock();
+}
+
+CString CIEHostWindow::GetLoadingURL()
+{
+	m_csLoadingUrl.Lock();
+	CString result = m_strLoadingUrl;
+	m_csLoadingUrl.Unlock();
+	return result;
+}
+
 void CIEHostWindow::OnBeforeNavigate2(LPDISPATCH pDisp, VARIANT* URL, VARIANT* Flags, VARIANT* TargetFrameName, VARIANT* PostData, VARIANT* Headers, BOOL* Cancel)
 {
 	// Firefoxҳ
@@ -1109,6 +1102,27 @@ void CIEHostWindow::OnBeforeNavigate2(LPDISPATCH pDisp, VARIANT* URL, VARIANT* F
 			Zoom(level);
 		}
 	}
+
+	if (!URL) return;
+
+	COLE2T szUrl(URL->bstrVal);
+
+	// ˵ HTTP Э
+	if (!UrlCanHandle(szUrl)) return;
+
+	// һ frame , 
+	CComQIPtr<IWebBrowser2> spBrowser(pDisp);
+	if (spBrowser)
+	{
+		VARIANT_BOOL vbIsTopLevelContainer;
+		if (SUCCEEDED(spBrowser->get_RegisterAsBrowser(&vbIsTopLevelContainer)))
+		{
+			if ( VARIANT_FALSE == vbIsTopLevelContainer ) return;
+		}
+	}
+
+	// Url
+	SetLoadingURL(CString(szUrl));
 }
 
 
@@ -1147,6 +1161,9 @@ void CIEHostWindow::OnDocumentComplete(LPDISPATCH pDisp, VARIANT* URL)
 	if (m_bFBInProgress)
 		FBResetFindRange();
 
+	/** Set element hiding styles */
+	ProcessElemHideStyles();
+
 	if (m_pPlugin)
 	{
 		m_pPlugin->OnDocumentComplete();
@@ -1390,15 +1407,22 @@ BOOL CIEHostWindow::ShouldPreventStatusFlash()
 
 CString CIEHostWindow::GetProcessName()
 {
-	TCHAR szPathName[MAX_PATH];
-	GetModuleFileName(NULL, szPathName, MAX_PATH);
-	TCHAR szFileName[MAX_PATH];
-	TCHAR szFileExt[MAX_PATH];
-	if (0 == _tsplitpath_s(szPathName, NULL, 0, NULL, 0, szFileName, MAX_PATH, szFileExt, MAX_PATH))
-	{
-		return CString(szFileName) + szFileExt;
-	}
-	return _T("");
+	return App::GetProcessName();
+}
+
+BOOL CIEHostWindow::GetABPIsEnabled()
+{
+	return AdBlockPlus::isEnabled();
+}
+
+BOOL CIEHostWindow::GetABPIsLoading()
+{
+	return AdBlockPlus::isLoading();
+}
+
+CString CIEHostWindow::GetABPLoadedFile()
+{
+	return AdBlockPlus::getLoadedFile().c_str();
 }
 
 BOOL CIEHostWindow::DestroyWindow()
@@ -1410,7 +1434,7 @@ BOOL CIEHostWindow::DestroyWindow()
 
 BOOL CIEHostWindow::Create(UINT nIDTemplate,CWnd* pParentWnd)
 {
-	return CDialog::Create(nIDTemplate,pParentWnd);
+	return CDialog::Create(nIDTemplate, pParentWnd);
 }
 
 void CIEHostWindow::SetPlugin(Plugin::CPlugin* pPlugin)
@@ -1448,6 +1472,190 @@ void CIEHostWindow::OnNewWindow3Ie(LPDISPATCH* ppDisp, BOOL* Cancel, unsigned lo
 	}
 }
 
+void CIEHostWindow::ProcessElemHideStyles()
+{
+	if (!AdBlockPlus::isEnabled()) return;
+
+	// Don't apply elemhide styles for IE6 -- they break pages badly
+	if (OS::GetIEVersion() <= 6)
+		return;
+
+	if (m_ie.GetSafeHwnd())
+	{
+		CComQIPtr<IDispatch> pDisp;
+		pDisp.Attach(m_ie.get_Document());
+		CComQIPtr<IHTMLDocument2> pDoc = pDisp;
+		if (!pDoc) return;
+
+		ProcessElemHideStylesForDoc(pDoc);
+	}
+}
+
+void DumpInnerHTML(const CComPtr<IHTMLDocument2>& pDoc)
+{
+	// first retrieve the head node
+	CComQIPtr<IHTMLDocument3> pDoc3 = pDoc;
+	if (!pDoc3) return;
+
+	CComPtr<IHTMLElementCollection> pcolHead;
+	if (FAILED(pDoc3->getElementsByTagName(_T("head"), &pcolHead)) || !pcolHead)
+		return;
+
+	long length;
+	if (FAILED(pcolHead->get_length(&length)) || length < 1)
+		return; // no head = =|
+
+	CComPtr<IDispatch> pDisp;
+	CComVariant varindex = 0;
+	if (FAILED(pcolHead->item(varindex, varindex, &pDisp)) || !pDisp)
+		return;
+
+	CComQIPtr<IHTMLElement> pHeadElement = pDisp;
+	if (!pHeadElement) return;
+
+	CComBSTR bstrInnerHTML;
+	if (FAILED(pHeadElement->get_innerHTML(&bstrInnerHTML)) || !bstrInnerHTML)
+		return;
+
+	wstring html(bstrInnerHTML);
+	html.c_str();
+}
+
+void CIEHostWindow::ProcessElemHideStylesForDoc(const CComPtr<IHTMLDocument2>& pDoc)
+{
+	CComBSTR bstrURL;
+	// while -- break, essentially a break-able 'if'
+	while (SUCCEEDED(pDoc->get_URL(&bstrURL)) && bstrURL)
+	{
+		std::wstring strURL = CString(bstrURL).GetString();
+		URLTokenizer tokensURL(strURL);
+
+		std::wstring strProtocol = toLowerCase(tokensURL.protocol);
+		// Do not handle protocols other than http/https
+		if (strProtocol != L"http" && strProtocol != L"https") break;
+
+		std::vector<std::wstring> vStyles;
+		if (AdBlockPlus::getElemHideStyles(strURL, vStyles))
+		{
+			if (IfAlreadyHaveElemHideStyles(pDoc)) break;
+			ApplyElemHideStylesForDoc(pDoc, vStyles);
+			ApplyElemHideStylesForDoc(pDoc, AdBlockPlus::getGlobalElemHideStyles());
+		}
+		break;
+	}
+	//DumpInnerHTML(pDoc);
+
+	CComPtr<IHTMLFramesCollection2> pFrames;
+	long length;
+	if (SUCCEEDED(pDoc->get_frames(&pFrames)) && pFrames && SUCCEEDED(pFrames->get_length(&length)))
+	{
+		for (long i = 0; i < length; i++)
+		{
+			CComVariant varindex = i;
+			CComVariant vDisp;
+			if (SUCCEEDED(pFrames->item(&varindex, &vDisp)))
+			{
+				CComPtr<IDispatch> pDisp = vDisp.pdispVal;
+				CComQIPtr<IHTMLWindow2> pWindow;
+				CComPtr<IHTMLDocument2> pSubDoc;
+				if ((pWindow = pDisp) && SUCCEEDED(pWindow->get_document(&pSubDoc)) && pSubDoc)
+				{
+					ProcessElemHideStylesForDoc(pSubDoc);
+				}
+			}
+		}
+	}
+}
+
+bool CIEHostWindow::IfAlreadyHaveElemHideStyles(const CComPtr<IHTMLDocument2>& pDoc)
+{
+	CComQIPtr<IHTMLDocument3> pDoc3 = pDoc;
+	if (!pDoc3) return false;
+
+	// Remove all previously created stylesheets
+	CComPtr<IHTMLElementCollection> pcolStyles;
+	if (FAILED(pDoc3->getElementsByTagName(_T("style"), &pcolStyles)) || !pcolStyles)
+		return false;
+
+	long length;
+	if (FAILED(pcolStyles->get_length(&length)))
+		return false;
+
+	for (long i = 0; i < length; i++)
+	{
+		CComVariant varindex = i;
+		CComPtr<IDispatch> pDisp;
+		if (FAILED(pcolStyles->item(varindex, varindex, &pDisp)) || !pDisp)
+			continue;
+
+		CComQIPtr<IHTMLElement> pElem = pDisp;
+		if (!pElem) continue;
+
+		CComVariant varStrClassName;
+		if (FAILED(pElem->getAttribute(_T("class"), 0, &varStrClassName)))
+			continue;
+
+		if (varStrClassName.vt != VT_BSTR || CComBSTR(varStrClassName.bstrVal) != s_strElemHideClass)
+			continue;
+
+		TRACE(_T("[ElemHide] Stylesheet already exists, will not add.\n"));
+		return true;
+	}
+	return false;
+}
+
+void CIEHostWindow::ApplyElemHideStylesForDoc(const CComPtr<IHTMLDocument2>& pDoc, const vector<wstring>& vStyles)
+{
+	if (!vStyles.size()) return;
+
+	// first retrieve the head node
+	CComQIPtr<IHTMLDocument3> pDoc3 = pDoc;
+	if (!pDoc3) return;
+
+	CComPtr<IHTMLElementCollection> pcolHead;
+	if (FAILED(pDoc3->getElementsByTagName(_T("head"), &pcolHead)) || !pcolHead)
+		return;
+
+	long length;
+	if (FAILED(pcolHead->get_length(&length)) || length < 1)
+		return; // no head = =|
+
+	CComPtr<IDispatch> pDisp;
+	CComVariant varindex = 0;
+	if (FAILED(pcolHead->item(varindex, varindex, &pDisp)) || !pDisp)
+		return;
+
+	CComQIPtr<IHTMLDOMNode> pHeadNode = pDisp;
+	if (!pHeadNode) return;
+
+	// add our stylesheets
+	for (size_t i = 0; i < vStyles.size(); i++)
+	{
+		const wstring& style = vStyles[i];
+
+		CComPtr<IHTMLStyleSheet> pStyleSheet;
+		if (FAILED(pDoc->createStyleSheet(_T(""), -1, &pStyleSheet)) || !pStyleSheet)
+			continue;
+
+		if (FAILED(pStyleSheet->put_cssText(CComBSTR((int)style.length(), (LPCOLESTR)style.c_str()))))
+			continue;
+
+		CComPtr<IHTMLElement> pElem;
+		if (FAILED(pStyleSheet->get_owningElement(&pElem)) || !pElem)
+			continue;
+
+		CComVariant varStrType = _T("text/css");
+		if (FAILED(pElem->setAttribute(_T("type"), varStrType)))
+			continue;
+
+		CComVariant varStrClass = s_strElemHideClass;
+		if (FAILED(pElem->setAttribute(_T("class"), varStrClass)))
+			continue;
+
+		TRACE(_T("[ElemHide] Stylesheet added. Length: %d\n"), style.size());
+	}
+}
+
 void CIEHostWindow::FBFindText(const CString& text)
 {
 	FBSetFindText(text);
@@ -1565,7 +1773,7 @@ void CIEHostWindow::FBObtainFindRangeRecursive(const CComPtr<IHTMLDocument2>& pD
 
 	CComPtr<IHTMLFramesCollection2> pFrames;
 	long length;
-	if (SUCCEEDED(pDoc->get_frames(&pFrames)) && SUCCEEDED(pFrames->get_length(&length)))
+	if (SUCCEEDED(pDoc->get_frames(&pFrames)) && pFrames && SUCCEEDED(pFrames->get_length(&length)))
 	{
 		for (long i = 0; i < length; i++)
 		{
@@ -1576,7 +1784,7 @@ void CIEHostWindow::FBObtainFindRangeRecursive(const CComPtr<IHTMLDocument2>& pD
 				CComPtr<IDispatch> pDisp = vDisp.pdispVal;
 				CComQIPtr<IHTMLWindow2> pWindow;
 				CComPtr<IHTMLDocument2> pSubDoc;
-				if ((pWindow = pDisp) && SUCCEEDED(pWindow->get_document(&pSubDoc)))
+				if ((pWindow = pDisp) && SUCCEEDED(pWindow->get_document(&pSubDoc)) && pSubDoc)
 				{
 					FBObtainFindRangeRecursive(pSubDoc);
 				}
@@ -2017,7 +2225,7 @@ bool CIEHostWindow::FBCheckRangeVisible(const CComPtr<IHTMLTxtRange>& pRange)
 	return true;
 }
 
-bool CIEHostWindow::FBCheckRangeHighlightable(const CComPtr<IDisplayServices> pDS, const CComPtr<IMarkupServices> pMS, const CComPtr<IHTMLTxtRange>& pRange)
+bool CIEHostWindow::FBCheckRangeHighlightable(const CComPtr<IDisplayServices>& pDS, const CComPtr<IMarkupServices>& pMS, const CComPtr<IHTMLTxtRange>& pRange)
 {
 	CComPtr<IDisplayPointer> pDStart, pDEnd;
 	CComPtr<IMarkupPointer> pMStart, pMEnd;
diff --git a/plugin/IEHostWindow.h b/plugin/IEHostWindow.h
index dfc0af9..14f6118 100644
--- a/plugin/IEHostWindow.h
+++ b/plugin/IEHostWindow.h
@@ -18,48 +18,17 @@ along with Fire-IE.  If not, see <http://www.gnu.org/licenses/>.
 
 #include "resource.h"
 #include "IECtrl.h"
+#include "UserMessage.h"
+#include "PointerHash.h"
 #include <vector>
+#include <string>
+#include <unordered_set>
 
 namespace Plugin
 {
 	class CPlugin;
 }
 
-namespace UserMessage
-{
-	// User defined window message
-	static const UINT WM_USER_MESSAGE =  WM_USER + 200;
-
-	//
-	// Sub-types of the user defined window message
-	//
-
-	static const WPARAM WPARAM_SET_FIREFOX_COOKIE = 0;
-	struct SetFirefoxCookieParams
-	{
-		CString strURL;
-		CString strCookie;
-	};
-
-	static const WPARAM WPARAM_NAVIGATE = 1;
-	struct NavigateParams
-	{
-		CString strURL;
-		CString strPost;
-		CString strHeaders;
-	};
-
-	static const WPARAM WPARAM_REFRESH = 2;
-	static const WPARAM WPARAM_STOP = 3;
-	static const WPARAM WPARAM_BACK = 4;
-	static const WPARAM WPARAM_FORWARD = 5;
-	static const WPARAM WPARAM_EXEC_OLE_CMD = 6;
-	static const WPARAM WPARAM_DISPLAY_SECURITY_INFO = 7;
-	static const WPARAM WPARAM_UTILS_PLUGIN_INIT = 8;
-	static const WPARAM WPARAM_CONTENT_PLUGIN_INIT = 9;
-
-}
-
 // Firefox 4.0 ʼµĴڽṹ
 // ڲǷ GeckoPluginWindow һ MozillaWindowClassǶ
 // MozillaWindowClassǵϢҪ㣬дһҵĺ
@@ -81,10 +50,12 @@ public:
 
 	/** Get CIEHostWindow object by its embeded Internet Explorer_Server window handle*/
 	static CIEHostWindow* FromInternetExplorerServer(HWND hwndIEServer);
+	/** Similar to FromInternetExplorerServer, but involves a lookup routine*/
+	static CIEHostWindow* FromChildWindow(HWND hwndChild);
 
 	static void AddUtilsIEWindow(CIEHostWindow *pWnd);
 
-	static void SetFirefoxCookie(CString strURL, CString strCookie);
+	static void SetFirefoxCookie(std::vector<UserMessage::SetFirefoxCookieParams>&& vCookieParams);
 
 	static HWND GetAnyUtilsHWND();
 	static CIEHostWindow* GetAnyUtilsWindow();
@@ -99,6 +70,9 @@ public:
 	/* Get the embedded Internet Explorer_server window */
 	HWND GetInternetExplorerServer() const;
 
+	CString GetLoadingURL();
+	void SetLoadingURL(const CString& value);
+	
 public:
 	
 	virtual ~CIEHostWindow();
@@ -142,6 +116,8 @@ protected:
 
 	static const CString s_strSecureLockInfos[];
 
+	static const TCHAR* const s_strElemHideClass;
+
 	void InitIE();
 	void UninitIE();
 
@@ -154,10 +130,9 @@ protected:
 	// ִ
 	void ExecOleCmd(OLECMDID cmdID);
 	// delay ole cmd execution to next message loop
-	void PostOleCmd(OLECMDID cmdID);
+	void RunAsyncOleCmd(OLECMDID cmdID);
 
 	// Զ崰ϢӦ
-	void OnSetFirefoxCookie(const CString& strURL, const CString& strCookie);
 	void OnNavigate();
 	void OnRefresh();
 	void OnStop();
@@ -194,9 +169,14 @@ protected:
 	bool FBCheckDocument();
 	static bool FBCheckRangeVisible(const CComPtr<IHTMLTxtRange>& pRange);
 	static bool FBRangesEqual(const CComPtr<IHTMLTxtRange>& pRange1, const CComPtr<IHTMLTxtRange>& pRange2);
-	static bool FBCheckRangeHighlightable(const CComPtr<IDisplayServices> pDS, const CComPtr<IMarkupServices> pMS, const CComPtr<IHTMLTxtRange>& pRange);
+	static bool FBCheckRangeHighlightable(const CComPtr<IDisplayServices>& pDS, const CComPtr<IMarkupServices>& pMS, const CComPtr<IHTMLTxtRange>& pRange);
 
 	static BOOL CALLBACK GetInternetExplorerServerCallback(HWND hWnd, LPARAM lParam);
+
+	void ProcessElemHideStyles();
+	void ProcessElemHideStylesForDoc(const CComPtr<IHTMLDocument2>& pDoc);
+	bool IfAlreadyHaveElemHideStyles(const CComPtr<IHTMLDocument2>& pDoc);
+	void ApplyElemHideStylesForDoc(const CComPtr<IHTMLDocument2>& pDoc, const std::vector<std::wstring>& vStyles);
 public:
 	CIECtrl m_ie;
 
@@ -238,6 +218,12 @@ public:
 	void FBToggleCase(bool bCase);
 	CString FBGetLastFindStatus();
 
+	// ABP methods
+	void ABPEnable();
+	void ABPDisable();
+	void ABPLoad(const CString& pathname);
+	void ABPClear();
+
 	// read only plugin properties
 	CString GetURL();
 	CString GetTitle();
@@ -260,6 +246,9 @@ public:
 	BOOL ShouldShowStatusOurselves();
 	BOOL ShouldPreventStatusFlash();
 	CString GetProcessName();
+	BOOL GetABPIsEnabled();
+	BOOL GetABPIsLoading();
+	CString GetABPLoadedFile();
 
 	// plugin events
 	void OnTitleChanged(const CString& title);
@@ -267,12 +256,11 @@ public:
 	void OnStatusChanged(const CString& message);
 	void OnCloseIETab();
 	void OnSetSecureLockIcon(int state);
-	void OnUtilsPluginInit();
-	void OnContentPluginInit();
+	void OnABPFilterLoaded();
+	void OnABPLoadFailure();
 
 	// miscellaneous
 	bool IsUtils() const { return m_bUtils; }
-
 protected:
 	BOOL m_bCanBack;
 	BOOL m_bCanForward;
@@ -326,4 +314,45 @@ protected:
 
 	/** Indicates whether the associated plugin is a utils plugin */
 	bool m_bUtils;
+
+	/** The top-level url currently loading */
+	CString m_strLoadingUrl;
+	/** Ensure the operations on m_strLoadingUrl are thread safe. */
+	CCriticalSection m_csLoadingUrl;
+
+protected:
+	class ICallable;
+	// Keep track of callable instances, make sure the calling is safe as it's converted from a (untrusted) raw pointer
+	std::unordered_set<ICallable*, Utils::PointerHasher<ICallable>, Utils::PointerEqualTo<ICallable> > m_setCallables;
+
+	// Asynchronous function calling, replaces original PostMessage approach
+	// This makes code more readable by putting caller code and callee code together
+
+	// After message is sent the type info is lost (the handler only sees LPARAM),
+	// Our only hope is a vtable that dispatches to different functions
+	class ICallable {
+	public:
+		virtual void call() const = 0;
+		virtual ~ICallable() { }
+	};
+
+	// Wraps callable function (typically a lambda expression) into ICallable
+	template<class Func>
+	class CallableFuncWrapper : public ICallable {
+	public:
+		CallableFuncWrapper(const Func& func) : func(func) { }
+		virtual void call() const { func(); }
+	private:
+		Func func;
+	};
+
+public:
+	// Asynchronously run the specified function at next message loop
+	template <class Func>
+	void RunAsync(const Func& func)
+	{
+		ICallable* wrapper = new CallableFuncWrapper<Func>(func);
+		m_setCallables.insert(wrapper);
+		PostMessage(UserMessage::WM_USER_MESSAGE, UserMessage::WPARAM_RUN_ASYNC_CALL, reinterpret_cast<LPARAM>(wrapper));
+	}
 };
diff --git a/plugin/Plugin.vcxproj b/plugin/Plugin.vcxproj
index f2db738..5de8c06 100644
--- a/plugin/Plugin.vcxproj
+++ b/plugin/Plugin.vcxproj
@@ -249,7 +249,7 @@ buildxpi.bat</Command>
     <ClCompile>
       <Optimization>MaxSpeed</Optimization>
       <IntrinsicFunctions>true</IntrinsicFunctions>
-      <PreprocessorDefinitions>WIN32;_WINDOWS;NDEBUG;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <PreprocessorDefinitions>WIN32;_WIN64;_WINDOWS;NDEBUG;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
       <FunctionLevelLinking>true</FunctionLevelLinking>
       <PrecompiledHeader>Use</PrecompiledHeader>
@@ -300,6 +300,11 @@ buildxpi64.bat</Command>
     </Link>
   </ItemDefinitionGroup>
   <ItemGroup>
+    <ClCompile Include="abp\AdBlockPlus.cpp" />
+    <ClCompile Include="abp\ElemHideMatcher.cpp" />
+    <ClCompile Include="abp\FilterClasses.cpp" />
+    <ClCompile Include="abp\Matcher.cpp" />
+    <ClCompile Include="abp\RAIILock.cpp" />
     <ClCompile Include="BrowserHook\AtlDepHook.cpp" />
     <ClCompile Include="BrowserHook\GestureHandler.cpp" />
     <ClCompile Include="BrowserHook\GestureHandlerImpl.cpp" />
@@ -307,8 +312,58 @@ buildxpi64.bat</Command>
     <ClCompile Include="IEControlSite.cpp" />
     <ClCompile Include="IECtrl.cpp" />
     <ClCompile Include="IEHostWindow.cpp" />
+    <ClCompile Include="jscre\JSRegExp_chartables.c">
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="jscre\JSRegExp_compile.cpp">
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">NotUsing</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">NotUsing</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="jscre\JSRegExp_exec.cpp">
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">NotUsing</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">NotUsing</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="jscre\JSRegExp_tables.cpp">
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">NotUsing</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">NotUsing</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="jscre\JSRegExp_ucp_searchfuncs.cpp">
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">NotUsing</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">NotUsing</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="jscre\JSRegExp_xclass.cpp">
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">NotUsing</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">NotUsing</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="jscre\ucptable.cpp">
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
+    </ClCompile>
     <ClCompile Include="PluginApp.cpp" />
     <ClCompile Include="Plugin\PluginGlobal.cpp" />
+    <ClCompile Include="regdom-libs\dkim-regdom.cpp">
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">NotUsing</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">NotUsing</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="re\RegExp.cpp" />
+    <ClCompile Include="re\strutils.cpp" />
     <ClCompile Include="stdafx.cpp">
       <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
       <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
@@ -323,18 +378,42 @@ buildxpi64.bat</Command>
     <ClCompile Include="Plugin\plugin.cpp" />
     <ClCompile Include="Plugin\ScriptablePluginObject.cpp" />
     <ClCompile Include="Plugin\ScriptablePluginObjectBase.cpp" />
+    <ClCompile Include="test\test.cpp" />
+    <ClCompile Include="Utils\App.cpp" />
     <ClCompile Include="Utils\OS.cpp" />
+    <ClCompile Include="Utils\PointerHash.cpp" />
+    <ClCompile Include="Utils\TLD.cpp" />
+    <ClCompile Include="Utils\URL.cpp" />
   </ItemGroup>
   <ItemGroup>
+    <ClInclude Include="abp\AdBlockPlus.h" />
+    <ClInclude Include="abp\ElemHideMatcher.h" />
+    <ClInclude Include="abp\FilterClasses.h" />
+    <ClInclude Include="abp\FilterContentType.h" />
+    <ClInclude Include="abp\Matcher.h" />
+    <ClInclude Include="abp\RAIILock.h" />
+    <ClInclude Include="abp\TList.h" />
+    <ClInclude Include="abp\TriBool.h" />
     <ClInclude Include="BrowserHook\AtlDepHook.h" />
     <ClInclude Include="BrowserHook\GestureHandler.h" />
     <ClInclude Include="BrowserHook\WindowMessageHook.h" />
+    <ClInclude Include="HttpMonitor\ContentType.h" />
     <ClInclude Include="IEControlSite.h" />
     <ClInclude Include="IECtrl.h" />
     <ClInclude Include="IEHostWindow.h" />
+    <ClInclude Include="jscre\ASCIICType.h" />
+    <ClInclude Include="jscre\config.h" />
+    <ClInclude Include="jscre\JSRegExp.h" />
+    <ClInclude Include="jscre\JSRegExp_internal.h" />
+    <ClInclude Include="jscre\stdint.h" />
+    <ClInclude Include="jscre\ucpinternal.h" />
     <ClInclude Include="PluginApp.h" />
     <ClInclude Include="Plugin\PluginGlobal.h" />
+    <ClInclude Include="regdom-libs\dkim-regdom.h" />
+    <ClInclude Include="regdom-libs\tld-canon.h" />
     <ClInclude Include="Resource.h" />
+    <ClInclude Include="re\RegExp.h" />
+    <ClInclude Include="re\strutils.h" />
     <ClInclude Include="stdafx.h" />
     <ClInclude Include="targetver.h" />
     <ClInclude Include="np\npapi.h" />
@@ -352,7 +431,13 @@ buildxpi64.bat</Command>
     <ClInclude Include="Plugin\pluginbase.h" />
     <ClInclude Include="Plugin\ScriptablePluginObject.h" />
     <ClInclude Include="Plugin\ScriptablePluginObjectBase.h" />
+    <ClInclude Include="test\test.h" />
+    <ClInclude Include="UserMessage.h" />
+    <ClInclude Include="Utils\App.h" />
     <ClInclude Include="Utils\OS.h" />
+    <ClInclude Include="Utils\PointerHash.h" />
+    <ClInclude Include="Utils\TLD.h" />
+    <ClInclude Include="Utils\URL.h" />
   </ItemGroup>
   <ItemGroup>
     <None Include="plugin.def" />
diff --git a/plugin/Plugin.vcxproj.filters b/plugin/Plugin.vcxproj.filters
index ea3f22e..d76255d 100644
--- a/plugin/Plugin.vcxproj.filters
+++ b/plugin/Plugin.vcxproj.filters
@@ -48,6 +48,66 @@
     <ClCompile Include="BrowserHook\GestureHandlerImpl.cpp">
       <Filter>BrowserHook</Filter>
     </ClCompile>
+    <ClCompile Include="jscre\ucptable.cpp">
+      <Filter>jscre</Filter>
+    </ClCompile>
+    <ClCompile Include="jscre\JSRegExp_chartables.c">
+      <Filter>jscre</Filter>
+    </ClCompile>
+    <ClCompile Include="jscre\JSRegExp_compile.cpp">
+      <Filter>jscre</Filter>
+    </ClCompile>
+    <ClCompile Include="jscre\JSRegExp_exec.cpp">
+      <Filter>jscre</Filter>
+    </ClCompile>
+    <ClCompile Include="jscre\JSRegExp_tables.cpp">
+      <Filter>jscre</Filter>
+    </ClCompile>
+    <ClCompile Include="jscre\JSRegExp_ucp_searchfuncs.cpp">
+      <Filter>jscre</Filter>
+    </ClCompile>
+    <ClCompile Include="jscre\JSRegExp_xclass.cpp">
+      <Filter>jscre</Filter>
+    </ClCompile>
+    <ClCompile Include="re\RegExp.cpp">
+      <Filter>re</Filter>
+    </ClCompile>
+    <ClCompile Include="abp\FilterClasses.cpp">
+      <Filter>abp</Filter>
+    </ClCompile>
+    <ClCompile Include="re\strutils.cpp">
+      <Filter>re</Filter>
+    </ClCompile>
+    <ClCompile Include="abp\Matcher.cpp">
+      <Filter>abp</Filter>
+    </ClCompile>
+    <ClCompile Include="abp\RAIILock.cpp">
+      <Filter>abp</Filter>
+    </ClCompile>
+    <ClCompile Include="abp\AdBlockPlus.cpp">
+      <Filter>abp</Filter>
+    </ClCompile>
+    <ClCompile Include="Utils\URL.cpp">
+      <Filter>Utils</Filter>
+    </ClCompile>
+    <ClCompile Include="abp\ElemHideMatcher.cpp">
+      <Filter>abp</Filter>
+    </ClCompile>
+    <ClCompile Include="regdom-libs\dkim-regdom.cpp">
+      <Filter>regdom-libs</Filter>
+    </ClCompile>
+    <ClCompile Include="Utils\TLD.cpp">
+      <Filter>Utils</Filter>
+    </ClCompile>
+    <ClCompile Include="test\test.cpp">
+      <Filter>test</Filter>
+    </ClCompile>
+    <ClCompile Include="Utils\PointerHash.cpp">
+      <Filter>Utils</Filter>
+    </ClCompile>
+    <ClCompile Include="Utils\App.cpp">
+      <Filter>Utils</Filter>
+    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="IECtrl.h" />
@@ -117,6 +177,79 @@
     <ClInclude Include="BrowserHook\GestureHandler.h">
       <Filter>BrowserHook</Filter>
     </ClInclude>
+    <ClInclude Include="jscre\ucpinternal.h">
+      <Filter>jscre</Filter>
+    </ClInclude>
+    <ClInclude Include="jscre\ASCIICType.h">
+      <Filter>jscre</Filter>
+    </ClInclude>
+    <ClInclude Include="jscre\config.h">
+      <Filter>jscre</Filter>
+    </ClInclude>
+    <ClInclude Include="jscre\JSRegExp.h">
+      <Filter>jscre</Filter>
+    </ClInclude>
+    <ClInclude Include="jscre\JSRegExp_internal.h">
+      <Filter>jscre</Filter>
+    </ClInclude>
+    <ClInclude Include="jscre\stdint.h">
+      <Filter>jscre</Filter>
+    </ClInclude>
+    <ClInclude Include="re\RegExp.h">
+      <Filter>re</Filter>
+    </ClInclude>
+    <ClInclude Include="abp\FilterClasses.h">
+      <Filter>abp</Filter>
+    </ClInclude>
+    <ClInclude Include="re\strutils.h">
+      <Filter>re</Filter>
+    </ClInclude>
+    <ClInclude Include="abp\TriBool.h">
+      <Filter>abp</Filter>
+    </ClInclude>
+    <ClInclude Include="abp\FilterContentType.h">
+      <Filter>abp</Filter>
+    </ClInclude>
+    <ClInclude Include="abp\Matcher.h">
+      <Filter>abp</Filter>
+    </ClInclude>
+    <ClInclude Include="abp\TList.h">
+      <Filter>abp</Filter>
+    </ClInclude>
+    <ClInclude Include="abp\RAIILock.h">
+      <Filter>abp</Filter>
+    </ClInclude>
+    <ClInclude Include="abp\AdBlockPlus.h">
+      <Filter>abp</Filter>
+    </ClInclude>
+    <ClInclude Include="HttpMonitor\ContentType.h">
+      <Filter>HttpMonitor</Filter>
+    </ClInclude>
+    <ClInclude Include="Utils\URL.h">
+      <Filter>Utils</Filter>
+    </ClInclude>
+    <ClInclude Include="abp\ElemHideMatcher.h">
+      <Filter>abp</Filter>
+    </ClInclude>
+    <ClInclude Include="UserMessage.h" />
+    <ClInclude Include="regdom-libs\dkim-regdom.h">
+      <Filter>regdom-libs</Filter>
+    </ClInclude>
+    <ClInclude Include="regdom-libs\tld-canon.h">
+      <Filter>regdom-libs</Filter>
+    </ClInclude>
+    <ClInclude Include="Utils\TLD.h">
+      <Filter>Utils</Filter>
+    </ClInclude>
+    <ClInclude Include="test\test.h">
+      <Filter>test</Filter>
+    </ClInclude>
+    <ClInclude Include="Utils\PointerHash.h">
+      <Filter>Utils</Filter>
+    </ClInclude>
+    <ClInclude Include="Utils\App.h">
+      <Filter>Utils</Filter>
+    </ClInclude>
   </ItemGroup>
   <ItemGroup>
     <None Include="plugin.def" />
@@ -150,6 +283,21 @@
     <Filter Include="Utils">
       <UniqueIdentifier>{ad158e8c-751c-405f-b9a1-724f4860bdb1}</UniqueIdentifier>
     </Filter>
+    <Filter Include="jscre">
+      <UniqueIdentifier>{70d9eaef-9e09-4049-b1dc-5a62b57ebe25}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="abp">
+      <UniqueIdentifier>{e5aa9f7e-47a0-4090-994b-12429b516e93}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="re">
+      <UniqueIdentifier>{34c92999-e07e-47a9-8dd6-24e0956040c0}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="regdom-libs">
+      <UniqueIdentifier>{a453b9ff-d57d-4f23-956c-daa98578b0b7}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="test">
+      <UniqueIdentifier>{8ba6f65f-4a26-4d74-a74e-c6037ba83c5c}</UniqueIdentifier>
+    </Filter>
   </ItemGroup>
   <ItemGroup>
     <ResourceCompile Include="plugin.rc" />
diff --git a/plugin/Plugin/PluginGlobal.cpp b/plugin/Plugin/PluginGlobal.cpp
index c48a153..a19f6fb 100644
--- a/plugin/Plugin/PluginGlobal.cpp
+++ b/plugin/Plugin/PluginGlobal.cpp
@@ -18,7 +18,7 @@ namespace Plugin
 	// global plugin initialization
 	NPError NS_PluginInitialize()
 	{
-		// httphttpsͬcookie
+		// httphttpsͬcookie˹
 		CComPtr<IInternetSession> spSession;
 		if (FAILED(CoInternetGetSession(0, &spSession, 0)) && spSession )
 		{
diff --git a/plugin/Plugin/ScriptablePluginObject.cpp b/plugin/Plugin/ScriptablePluginObject.cpp
index fa68e0a..7251c10 100644
--- a/plugin/Plugin/ScriptablePluginObject.cpp
+++ b/plugin/Plugin/ScriptablePluginObject.cpp
@@ -184,6 +184,27 @@ namespace Plugin
 			STRINGZ_TO_NPVARIANT(CStringToNPStringCharacters(name), *result);
 			return true;
 		}
+		// readonly property {bool} ABPIsEnabled
+		else if (name == NPI_ID(ABPIsEnabled))
+		{
+			BOOL value = pMainWindow->GetABPIsEnabled();
+			BOOLEAN_TO_NPVARIANT(value, *result);
+			return true;
+		}
+		// readonly property {bool} ABPIsLoading
+		else if (name == NPI_ID(ABPIsLoading))
+		{
+			BOOL value = pMainWindow->GetABPIsLoading();
+			BOOLEAN_TO_NPVARIANT(value, *result);
+			return true;
+		}
+		// readonly property {String} ABPLoadedFile
+		else if (name == NPI_ID(ABPLoadedFile))
+		{
+			CString file = pMainWindow->GetABPLoadedFile();
+			STRINGZ_TO_NPVARIANT(CStringToNPStringCharacters(file), *result);
+			return true;
+		}
 
 		VOID_TO_NPVARIANT(*result);
 		return true;
@@ -369,72 +390,84 @@ namespace Plugin
 			pMainWindow->PrintSetup();
 			return true;
 		}
+		// void ViewPageSource()
 		else if (name == NPI_ID(ViewPageSource))
 		{
 			TRACE ("ViewPageSource called!\n");
 			pMainWindow->ViewPageSource();
 			return true;
 		}
+		// void PageUp()
 		else if (name == NPI_ID(PageUp))
 		{
 			TRACE ("PageUp called!\n");
 			pMainWindow->ScrollPage(true);
 			return true;
 		}
+		// void PageDown()
 		else if (name == NPI_ID(PageDown))
 		{
 			TRACE ("PageDown called!\n");
 			pMainWindow->ScrollPage(false);
 			return true;
 		}
+		// void LineUp()
 		else if (name == NPI_ID(LineUp))
 		{
 			TRACE ("LineUp called!\n");
 			pMainWindow->ScrollLine(true);
 			return true;
 		}
+		// void LineDown()
 		else if (name == NPI_ID(LineDown))
 		{
 			TRACE ("LineDown called!\n");
 			pMainWindow->ScrollLine(false);
 			return true;
 		}
+		// void ScrollTop()
 		else if (name == NPI_ID(ScrollTop))
 		{
 			TRACE ("ScrollTop called!\n");
 			pMainWindow->ScrollWhole(true);
 			return true;
 		}
+		// void ScrollBottom()
 		else if (name == NPI_ID(ScrollBottom))
 		{
 			TRACE ("ScrollBottom called!\n");
 			pMainWindow->ScrollWhole(false);
 			return true;
 		}
+		// void ScrollLeft()
 		else if (name == NPI_ID(ScrollLeft))
 		{
 			TRACE ("ScrollLeft called!\n");
 			pMainWindow->ScrollHorizontal(true);
 			return true;
 		}
+		// void ScrollRight()
 		else if (name == NPI_ID(ScrollRight))
 		{
 			TRACE ("ScrollRight called!\n");
 			pMainWindow->ScrollHorizontal(false);
 			return true;
 		}
+		// void ScrollWheelUp()
 		else if (name == NPI_ID(ScrollWheelUp))
 		{
 			TRACE ("ScrollWheelUp called!\n");
 			pMainWindow->ScrollWheelLine(true);
 			return true;
 		}
+		// void ScrollWheelDown()
 		else if (name == NPI_ID(ScrollWheelDown))
 		{
 			TRACE ("ScrollWheelDown called!\n");
 			pMainWindow->ScrollWheelLine(false);
 			return true;
 		}
+		// void FBFindText({String} text)
 		else if (name == NPI_ID(FBFindText))
 		{
 			TRACE ("FBFindText called!\n");
@@ -449,6 +482,7 @@ namespace Plugin
 			pMainWindow->FBFindText(text);
 			return true;
 		}
+		// void FBEndFindText()
 		else if (name == NPI_ID(FBEndFindText))
 		{
 			TRACE ("FBEndFindText called!\n");
@@ -456,6 +490,7 @@ namespace Plugin
 			pMainWindow->FBEndFindText();
 			return true;
 		}
+		// void FBFindAgain()
 		else if (name == NPI_ID(FBFindAgain))
 		{
 			TRACE ("FBFindAgain called!\n");
@@ -463,6 +498,7 @@ namespace Plugin
 			pMainWindow->FBFindAgain();
 			return true;
 		}
+		// void FBFindPrevious()
 		else if (name == NPI_ID(FBFindPrevious))
 		{
 			TRACE ("FBFindPrevious called!\n");
@@ -470,6 +506,7 @@ namespace Plugin
 			pMainWindow->FBFindPrevious();
 			return true;
 		}
+		// void FBToggleHighlight({Boolean} highlight)
 		else if (name == NPI_ID(FBToggleHighlight))
 		{
 			TRACE ("FBToggleHighlight called!\n");
@@ -485,6 +522,7 @@ namespace Plugin
 			pMainWindow->FBToggleHighlight(ifHighlight);
 			return true;
 		}
+		// void FBToggleCase({Boolean} case)
 		else if (name == NPI_ID(FBToggleCase))
 		{
 			TRACE ("FBToggleCase called!\n");
@@ -500,6 +538,7 @@ namespace Plugin
 			pMainWindow->FBToggleCase(ifCase);
 			return true;
 		}
+		// void FBSetFindText({String} text)
 		else if (name == NPI_ID(FBSetFindText))
 		{
 			TRACE ("FBSetFindText called!\n");
@@ -514,6 +553,7 @@ namespace Plugin
 			pMainWindow->FBSetFindText(text);
 			return true;
 		}
+		// void SetEnabledGestures({Array of String} gestures)
 		else if (name == NPI_ID(SetEnabledGestures))
 		{
 			TRACE ("SetEnabledGestures called!\n");
@@ -550,6 +590,46 @@ namespace Plugin
 				}
 			}
 		}
+		// void ABPEnable()
+		else if (name == NPI_ID(ABPEnable))
+		{
+			TRACE ("ABPEnable called!\n");
+			
+			pMainWindow->ABPEnable();
+			return true;
+		}
+		// void ABPDisable()
+		else if (name == NPI_ID(ABPDisable))
+		{
+			TRACE ("ABPDisable called!\n");
+			
+			pMainWindow->ABPDisable();
+			return true;
+		}
+		// void ABPLoad({String} pathname)
+		else if (name == NPI_ID(ABPLoad))
+		{
+			TRACE ("ABPLoad called!\n");
+			
+			if (argCount < 1) return false;
+
+			CString pathname = _T("");
+			if (NPVARIANT_IS_STRING(args[0]))
+				pathname = NPStringToCString(NPVARIANT_TO_STRING(args[0]));
+			else
+				return false;
+
+			pMainWindow->ABPLoad(pathname);
+			return true;
+		}
+		// void ABPClear()
+		else if (name == NPI_ID(ABPClear))
+		{
+			TRACE ("ABPClear called!\n");
+			
+			pMainWindow->ABPClear();
+			return true;
+		}
 		return false;
 	}
 
diff --git a/plugin/Plugin/ScriptablePluginObject.h b/plugin/Plugin/ScriptablePluginObject.h
index fd0af5b..405614d 100644
--- a/plugin/Plugin/ScriptablePluginObject.h
+++ b/plugin/Plugin/ScriptablePluginObject.h
@@ -78,6 +78,11 @@ namespace Plugin
 
 		// util methods
 		NPI_DEF(SetEnabledGestures);
+		// ABP methods
+		NPI_DEF(ABPEnable);
+		NPI_DEF(ABPDisable);
+		NPI_DEF(ABPLoad);
+		NPI_DEF(ABPClear);
 
 		// properties
 		NPI_DEF(URL);
@@ -102,6 +107,10 @@ namespace Plugin
 		NPI_DEF(ShouldPreventStatusFlash);
 		NPI_DEF(ProcessName);
 
+		// ABP properties
+		NPI_DEF(ABPIsEnabled);
+		NPI_DEF(ABPIsLoading);
+		NPI_DEF(ABPLoadedFile);
 	public:
 		ScriptablePluginObject(NPP npp)
 			: ScriptablePluginObjectBase(npp)
@@ -146,6 +155,10 @@ namespace Plugin
 			NPN_GSI_M(FBToggleCase);
 			NPN_GSI_M(FBSetFindText);
 			NPN_GSI_M(SetEnabledGestures);
+			NPN_GSI_M(ABPEnable);
+			NPN_GSI_M(ABPDisable);
+			NPN_GSI_M(ABPLoad);
+			NPN_GSI_M(ABPClear);
 
 			// properties
 			NPN_GSI_P(URL);
@@ -169,6 +182,9 @@ namespace Plugin
 			NPN_GSI_P(ShouldShowStatusOurselves);
 			NPN_GSI_P(ShouldPreventStatusFlash);
 			NPN_GSI_P(ProcessName);
+			NPN_GSI_P(ABPIsEnabled);
+			NPN_GSI_P(ABPIsLoading);
+			NPN_GSI_P(ABPLoadedFile);
 		}
 
 		virtual bool HasMethod(NPIdentifier name);
diff --git a/plugin/Plugin/plugin.cpp b/plugin/Plugin/plugin.cpp
index 5717afd..e75bc08 100644
--- a/plugin/Plugin/plugin.cpp
+++ b/plugin/Plugin/plugin.cpp
@@ -49,6 +49,13 @@
 #include "json/json.h"
 #include "OS.h"
 
+#ifdef DEBUG
+#include "test/test.h"
+#endif
+
+using namespace std;
+using namespace UserMessage;
+
 namespace Plugin
 {
 
@@ -163,9 +170,7 @@ namespace Plugin
 		{
 			// cannot directly fire the event since the plugin is not fully constructed 
 			// - we are still in the initializer
-			HWND hwnd = m_pIEHostWindow->GetSafeHwnd();
-			if (hwnd)
-				PostMessage(hwnd, UserMessage::WM_USER_MESSAGE, UserMessage::WPARAM_UTILS_PLUGIN_INIT, 0);
+			m_pIEHostWindow->RunAsync([=] { OnUtilsPluginInit(); });
 		}
 		else
 		{
@@ -173,9 +178,7 @@ namespace Plugin
 
 			// cannot directly fire the event since the plugin is not fully constructed 
 			// - we are still in the initializer
-			HWND hwnd = m_pIEHostWindow->GetSafeHwnd();
-			if (hwnd)
-				PostMessage(hwnd, UserMessage::WM_USER_MESSAGE, UserMessage::WPARAM_CONTENT_PLUGIN_INIT, 0);
+			m_pIEHostWindow->RunAsync([=] { OnContentPluginInit(); });
 		}
 
 		return TRUE;
@@ -544,6 +547,7 @@ namespace Plugin
 			NPN_ReleaseVariantValue(&vEvent);
 			if (!bOK || !NPVARIANT_IS_BOOLEAN(vNotCanceled)) 
 			{
+				NPN_ReleaseVariantValue(&vNotCanceled);
 				throw CString(_T("Cannot dispatchEvent"));
 			}
 			if (NPVARIANT_TO_BOOLEAN(vNotCanceled) != true)
@@ -619,6 +623,24 @@ namespace Plugin
 		FireEvent(strEventType, strDetail);
 	}
 
+	void CPlugin::SetFirefoxCookie(const vector<SetFirefoxCookieParams>& vCookies)
+	{
+		USES_CONVERSION_EX;
+		CString strEventType = _T("IEBatchSetCookie");
+		CString strDetail;
+		Json::Value aCookies;
+		for (size_t i = 0; i < vCookies.size(); i++)
+		{
+			const SetFirefoxCookieParams& param = vCookies[i];
+			Json::Value cookie;
+			cookie["url"] = T2A_EX(param.strURL, param.strURL.GetLength() + 1);
+			cookie["header"] = T2A_EX(param.strCookie, param.strCookie.GetLength() + 1);
+			aCookies.append(cookie);
+		}
+		strDetail = CA2T(aCookies.toStyledString().c_str());
+		FireEvent(strEventType, strDetail);
+	}
+
 	void CPlugin::SetURLCookie(const CString& strURL, const CString& strCookie)
 	{
 		char* url = CStringToNPStringCharacters(strURL);
@@ -677,6 +699,9 @@ namespace Plugin
 
 	void CPlugin::OnUtilsPluginInit()
 	{
+#ifdef DEBUG
+		test::doTest();
+#endif
 		CString strEventType = _T("IEUtilsPluginInitialized");
 		CString strDetail = _T("");
 		FireEvent(strEventType, strDetail);
@@ -688,4 +713,19 @@ namespace Plugin
 		CString strDetail = _T("");
 		FireEvent(strEventType, strDetail);
 	}
+
+	void CPlugin::OnABPFilterLoaded(int numFilters, unsigned int ticks)
+	{
+		CString strEventType = _T("IEABPFilterLoaded");
+		CString strDetail;
+		strDetail.Format(_T("{ \"number\": %d, \"ticks\": %d }"), numFilters, ticks);
+		FireEvent(strEventType, strDetail);
+	}
+
+	void CPlugin::OnABPLoadFailure()
+	{
+		CString strEventType = _T("IEABPLoadFailure");
+		CString strDetail = _T("");
+		FireEvent(strEventType, strDetail);
+	}
 }
diff --git a/plugin/Plugin/plugin.h b/plugin/Plugin/plugin.h
index 5418b54..b04b0d9 100644
--- a/plugin/Plugin/plugin.h
+++ b/plugin/Plugin/plugin.h
@@ -41,6 +41,8 @@
 #include "npruntime.h"
 #include "PluginApp.h"
 #include "pluginbase.h"
+#include "UserMessage.h"
+#include <vector>
 
 class CIEHostWindow;
 
@@ -121,7 +123,11 @@ namespace Plugin
 		/**
 		 * Sets Firefox Cookie by firing a JavaScript event.
 		 */
-		void SetFirefoxCookie(const CString& strURL, const CString& strCookieHeader);
+		void SetFirefoxCookie(const CString& strURL, const CString& strCookie);
+		/**
+		 * Batch-setting Firefox Cookie by firing a JavaScript event.
+		 */
+		void SetFirefoxCookie(const std::vector<UserMessage::SetFirefoxCookieParams>& vCookies);
 
 		/** 
 		 * Sets Firefox Cookie using NPAPI
@@ -156,6 +162,12 @@ namespace Plugin
 
 		/** Content plugin intialized */
 		void OnContentPluginInit();
+
+		/** AdBlock Plus filters loaded */
+		void OnABPFilterLoaded(int numFilters, unsigned int ticks);
+
+		/** AdBlock Plus filters failed load */
+		void OnABPLoadFailure();
 	protected:
 
 		NPP m_pNPInstance;
diff --git a/plugin/UserMessage.h b/plugin/UserMessage.h
new file mode 100644
index 0000000..9477641
--- /dev/null
+++ b/plugin/UserMessage.h
@@ -0,0 +1,46 @@
+/*
+This file is part of Fire-IE.
+
+Fire-IE is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Fire-IE is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Fire-IE.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+namespace UserMessage
+{
+	// User defined window message
+	static const UINT WM_USER_MESSAGE =  WM_USER + 200;
+
+	//
+	// Sub-types of the user defined window message
+	//
+
+	struct SetFirefoxCookieParams
+	{
+		CString strURL;
+		CString strCookie;
+	};
+
+	struct NavigateParams
+	{
+		CString strURL;
+		CString strPost;
+		CString strHeaders;
+	};
+
+	// WPARAM 10 is used by content policy delegation on CPDelegate branch, DO NOT USE IT HERE
+	static const WPARAM WPARAM_ABP_FILTER_LOADED = 11;
+	static const WPARAM WPARAM_ABP_LOAD_FAILURE = 12;
+	static const WPARAM WPARAM_RUN_ASYNC_CALL = 13;
+}
diff --git a/plugin/Utils/App.cpp b/plugin/Utils/App.cpp
new file mode 100644
index 0000000..a4d9655
--- /dev/null
+++ b/plugin/Utils/App.cpp
@@ -0,0 +1,60 @@
+/*
+This file is part of Fire-IE.
+
+Fire-IE is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Fire-IE is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Fire-IE.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+// App.cpp : App related information
+
+#include "StdAfx.h"
+
+#include "App.h"
+
+using namespace Utils;
+
+App::Application App::s_app = UNKNOWN;
+CString App::s_strProcessName = _T("");
+
+App::Application App::GetApplication()
+{
+	if (s_app != UNKNOWN) return s_app;
+
+	CString strProcessName = GetProcessName().MakeLower();
+	if (strProcessName == _T("firefox.exe"))
+		s_app = FIREFOX;
+	else if (strProcessName == _T("palemoon.exe"))
+		s_app = PALEMOON;
+	else if (strProcessName == _T("waterfox.exe"))
+		s_app = WATERFOX;
+	else if (strProcessName == _T("plugin-container.exe"))
+		s_app = OOPP;
+	else s_app = UNRECOGNIZED_APP;
+
+	return s_app;
+}
+
+CString App::GetProcessName()
+{
+	if (s_strProcessName.GetLength()) return s_strProcessName;
+
+	TCHAR szPathName[MAX_PATH];
+	GetModuleFileName(NULL, szPathName, MAX_PATH);
+	TCHAR szFileName[MAX_PATH];
+	TCHAR szFileExt[MAX_PATH];
+	if (0 == _tsplitpath_s(szPathName, NULL, 0, NULL, 0, szFileName, MAX_PATH, szFileExt, MAX_PATH))
+	{
+		return s_strProcessName = CString(szFileName) + szFileExt;
+	}
+	return s_strProcessName = _T("firefox.exe");
+}
diff --git a/plugin/Utils/App.h b/plugin/Utils/App.h
new file mode 100644
index 0000000..b4e948b
--- /dev/null
+++ b/plugin/Utils/App.h
@@ -0,0 +1,41 @@
+/*
+This file is part of Fire-IE.
+
+Fire-IE is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Fire-IE is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Fire-IE.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// App.h : App related information
+
+namespace Utils
+{
+	class App {
+	public:
+		enum Application {
+			UNKNOWN,
+			FIREFOX,
+			PALEMOON,
+			WATERFOX,
+			OOPP,
+			UNRECOGNIZED_APP
+		};
+
+		static Application GetApplication();
+		static CString GetProcessName();
+	private:
+		static Application s_app;
+		static CString s_strProcessName;
+	};
+} // namespace Utils
diff --git a/plugin/Utils/PointerHash.cpp b/plugin/Utils/PointerHash.cpp
new file mode 100644
index 0000000..51b8e8a
--- /dev/null
+++ b/plugin/Utils/PointerHash.cpp
@@ -0,0 +1,25 @@
+/*
+This file is part of Fire-IE.
+
+Fire-IE is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Fire-IE is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Fire-IE.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+// PointerHash.cpp : Hasher and Equality comparator definition for pointer types
+//
+
+#include <StdAfx.h>
+
+#include "PointerHash.h"
+
+std::hash<size_t> Utils::size_t_hasher;
diff --git a/plugin/Utils/PointerHash.h b/plugin/Utils/PointerHash.h
new file mode 100644
index 0000000..36344c8
--- /dev/null
+++ b/plugin/Utils/PointerHash.h
@@ -0,0 +1,39 @@
+/*
+This file is part of Fire-IE.
+
+Fire-IE is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Fire-IE is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Fire-IE.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// PointerHash.h : Hasher and Equality comparator definition for pointer types
+//
+
+#include <xhash>
+
+namespace Utils {
+	extern std::hash<size_t> size_t_hasher;
+
+	template<class T>
+	class PointerHasher: public std::unary_function<T*, size_t> {
+	public:
+		size_t operator()(T* pointer) const { return size_t_hasher(reinterpret_cast<size_t>(pointer)); }
+	};
+
+	template<class T>
+	class PointerEqualTo: public std::binary_function<T*, T*, bool> {
+	public:
+		bool operator()(T* ptr1, T* ptr2) const { return ptr1 == ptr2; }
+	};
+} // namespace Utils
diff --git a/plugin/Utils/TLD.cpp b/plugin/Utils/TLD.cpp
new file mode 100644
index 0000000..e79a1e8
--- /dev/null
+++ b/plugin/Utils/TLD.cpp
@@ -0,0 +1,49 @@
+/*
+This file is part of Fire-IE.
+
+Fire-IE is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Fire-IE is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Fire-IE.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+// TLD.cpp : Effective Top-Level-Domain Service impl.
+//
+
+#include "StdAfx.h"
+
+#include "TLD.h"
+#include "regdom-libs/dkim-regdom.h"
+#include "regdom-libs/tld-canon.h"
+
+namespace Utils {
+	const regdom::tldnode* rootTLDNode = NULL;
+}
+
+using namespace Utils;
+
+TLD::TLDInit TLD::init;
+
+TLD::TLDInit::TLDInit()
+{
+	rootTLDNode = regdom::readTldTree(tldString);
+}
+
+TLD::TLDInit::~TLDInit()
+{
+	freeTldTree(rootTLDNode);
+}
+
+CString TLD::getEffectiveDomain(const CString& domain)
+{
+	const wchar_t* utf8Result = regdom::getRegisteredDomain(domain, rootTLDNode);
+	return utf8Result ? utf8Result : domain;
+}
diff --git a/plugin/Utils/TLD.h b/plugin/Utils/TLD.h
new file mode 100644
index 0000000..93f9350
--- /dev/null
+++ b/plugin/Utils/TLD.h
@@ -0,0 +1,46 @@
+/*
+This file is part of Fire-IE.
+
+Fire-IE is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Fire-IE is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Fire-IE.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// TLD.h : Effective Top-Level-Domain Service
+//
+
+namespace Utils {
+	class TLD {
+	public:
+		/* 
+		 * get effective domain from full-qualified domain
+		 * guaranteed to return something if domain is valid
+		 * (no error-checking at caller side is needed)
+		 * Return values:
+		 * 1) <tld> if ingoingDomain is a TLD
+		 * 2) the registered domain name if TLD is known
+		 * 3) just <domain>.<tld> if <tld> is unknown
+		 *    This case was added to support new TLDs in outdated reg-dom libs
+		 *    by a certain likelihood. This fallback method is implemented in the
+		 *    last conversion step and can be simply commented out. 
+		 */
+		static CString getEffectiveDomain(const CString& domain);
+	private:
+		static class TLDInit {
+		public:
+			TLDInit();
+			~TLDInit();
+		} init;
+	};
+} // namespace Utils
diff --git a/plugin/Utils/URL.cpp b/plugin/Utils/URL.cpp
new file mode 100644
index 0000000..39df1a8
--- /dev/null
+++ b/plugin/Utils/URL.cpp
@@ -0,0 +1,198 @@
+/*
+This file is part of Fire-IE.
+
+Fire-IE is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Fire-IE is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Fire-IE.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+// URL.cpp : URL utilities
+//
+
+#include "StdAfx.h"
+#include "URL.h"
+#include "TLD.h"
+#include "re/RegExp.h"
+#include "re/strutils.h"
+#include <algorithm>
+
+using namespace Utils;
+using namespace re;
+using namespace re::strutils;
+using namespace std;
+
+namespace Utils {
+
+CString GetHostFromUrl(const CString& strUrl)
+{
+	return URLTokenizer(strUrl.GetString()).domain.c_str();
+}
+
+CString GetProtocolFromUrl(const CString& strUrl)
+{
+	CString protocol = URLTokenizer(strUrl.GetString()).protocol.c_str();
+	if (protocol.GetLength() == 0)
+		protocol = _T("http");
+	return protocol;
+}
+
+CString GetPathFromUrl(const CString& strUrl)
+{
+	return URLTokenizer(strUrl.GetString()).getPathWithoutFile().c_str();
+}
+
+CString GetURLRelative(const CString& baseURL, const CString& relativeURL)
+{
+	return URLTokenizer(baseURL.GetString()).getRelativeURL(relativeURL.GetString()).c_str();
+}
+
+bool IsThirdPartyRequest(const CString& request, const CString& referer)
+{
+	CString host1 = GetHostFromUrl(request).MakeLower();
+	CString host2 = GetHostFromUrl(referer).MakeLower();
+	return TLD::getEffectiveDomain(host1) != TLD::getEffectiveDomain(host2);
+}
+
+bool IsSubDomain(const CString& subdomain, const CString& domain)
+{
+	if (subdomain == domain) return true;
+
+	// sub domain test by prepending dot('.') to domain
+	const TCHAR* iter1 = subdomain.GetString();
+	const TCHAR* iter1end = iter1 + subdomain.GetLength();
+
+	CString dotDomain = _T(".") + domain;
+	const TCHAR* iter2 = dotDomain.GetString();
+	const TCHAR* iter2end = iter2 + dotDomain.GetLength();
+
+	const TCHAR* pos = find_end(iter1, iter1end, iter2, iter2end);
+
+	if (pos == iter1end) return false;
+	return pos + dotDomain.GetLength() == iter1end;
+}
+
+} // namespace Utils
+
+const RegExp URLTokenizer::tokenizerRegExp = L"/^(?=[^&])(?:([^:\\/?#]+):)?(?:\\/\\/(?:([^\\/\\:@?#]*)(?:\\:([^\\/@?#]*))?@)?([^\\/\\:?#]*)(?:\\:([^\\/?#]+))?)?([^?#]*)(?:\\?([^#]*))?(?:#(.*))?/";
+
+bool URLTokenizer::tokenize(const wstring& url)
+{
+	RegExpMatch* match = tokenizerRegExp.exec(url);
+	if (match)
+	{
+		protocol = match->substrings[1];
+		username = match->substrings[2];
+		password = match->substrings[3];
+		domain   = match->substrings[4];
+		port     = match->substrings[5];
+		path     = match->substrings[6];
+		query    = match->substrings[7];
+		anchor   = match->substrings[8];
+		delete match;
+		return true;
+	}
+	else
+	{
+		protocol = username = password = domain = port = path = query = anchor = L"";
+		return false;
+	}
+}
+
+wstring URLTokenizer::assemble() const
+{
+	wstring result;
+	if (protocol.length())
+		result.append(protocol).append(1, L':');
+	wstring authority = getAuthority();
+	if (authority.length() || toLowerCase(protocol) == L"file") // special case for file uris
+		result.append(L"//").append(authority);
+	result.append(path);
+	if (query.length())
+		result.append(1, L'?').append(query);
+	if (anchor.length())
+		result.append(1, L'#').append(anchor);
+
+	return result;
+}
+
+wstring URLTokenizer::getAuthority() const
+{
+	wstring authority;
+	if (username.length() || password.length())
+	{
+		authority.append(username);
+		if (password.length())
+			authority.append(1, L':').append(password);
+		authority.append(1, L'@');
+	}
+	authority.append(domain);
+	if (port.length())
+		authority.append(1, L':').append(port);
+	return authority;
+}
+
+wstring URLTokenizer::getPathWithoutFile() const
+{
+	size_t pos = path.rfind(L'/');
+	if (pos != wstring::npos)
+	{
+		// pos can't be wstring::npos here
+		return path.substr(0, pos + 1);
+	}
+	else
+	{
+		return L"/";
+	}
+}
+
+wstring URLTokenizer::getRelativeURL(const wstring& url) const
+{
+	URLTokenizer relTokens(url);
+	if (relTokens.protocol.length())
+	{
+		// complete url, return immediately
+		// test url: https://addons.mozilla.org/zh-CN/firefox/
+		return url;
+	}
+
+	if (relTokens.getAuthority().length())
+	{
+		// same protocol semi-complete url, return immediately
+		// test url: http://www.windowsazure.com/zh-cn/
+		relTokens.protocol = this->protocol;
+		return relTokens.assemble();
+	}
+
+	if (startsWithChar(relTokens.path, L'/'))
+	{
+		// root url
+		// test url: https://mail.qq.com/cgi-bin/loginpage?
+		relTokens.protocol = this->protocol;
+		relTokens.username = this->username;
+		relTokens.password = this->password;
+		relTokens.domain = this->domain;
+		relTokens.port = this->port;
+		return relTokens.assemble();
+	}
+	else
+	{
+		// relative url
+		// test url: http://www.update.microsoft.com/windowsupdate/v6/thanks.aspx?ln=zh-cn&&thankspage=5
+		relTokens.protocol = this->protocol;
+		relTokens.username = this->username;
+		relTokens.password = this->password;
+		relTokens.domain = this->domain;
+		relTokens.port = this->port;
+		relTokens.path = this->getPathWithoutFile() + relTokens.path;
+		return relTokens.assemble();
+	}
+}
diff --git a/plugin/Utils/URL.h b/plugin/Utils/URL.h
new file mode 100644
index 0000000..6333730
--- /dev/null
+++ b/plugin/Utils/URL.h
@@ -0,0 +1,64 @@
+/*
+This file is part of Fire-IE.
+
+Fire-IE is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Fire-IE is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Fire-IE.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// URL.h : URL utilities
+//
+
+#include <string>
+
+namespace re {
+	class RegExp;
+}
+
+namespace Utils {
+	CString GetHostFromUrl(const CString& strUrl);
+	CString GetProtocolFromUrl(const CString& strUrl);
+	CString GetPathFromUrl(const CString& strUrl);
+	CString GetURLRelative(const CString& baseURL, const CString& relativeURL);
+	bool IsThirdPartyRequest(const CString& request, const CString& referer);
+	bool IsSubDomain(const CString& subdomain, const CString& domain);
+
+	// URL tokenizer, using w3c recommended tokenizing style
+	// See http://www.ietf.org/rfc/rfc2396.txt
+	class URLTokenizer {
+	public:
+		std::wstring protocol;
+		std::wstring username;
+		std::wstring password;
+		std::wstring domain;
+		std::wstring port;
+		std::wstring path;
+		std::wstring query;
+		std::wstring anchor;
+
+		URLTokenizer() {}
+		URLTokenizer(const std::wstring& url) { tokenize(url); }
+		bool tokenize(const std::wstring& url);
+		// put tokens together to form a URL
+		std::wstring assemble() const;
+		// get authority part of the url (username:password@domain:port)
+		std::wstring getAuthority() const;
+		// get the path part without file name
+		std::wstring getPathWithoutFile() const;
+
+		std::wstring getRelativeURL(const std::wstring& url) const;
+	private:
+		static const re::RegExp tokenizerRegExp;
+	};
+} // namespace Utils
diff --git a/plugin/abp/AdBlockPlus.cpp b/plugin/abp/AdBlockPlus.cpp
new file mode 100644
index 0000000..7441f1d
--- /dev/null
+++ b/plugin/abp/AdBlockPlus.cpp
@@ -0,0 +1,576 @@
+/*
+This file is part of Fire-IE.
+
+Fire-IE is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Fire-IE is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Fire-IE.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// AdBlockPlus.cpp : necessary ABP control routines
+//
+#include "StdAfx.h"
+
+#include "AdBlockPlus.h"
+#include "Matcher.h"
+#include "FilterClasses.h"
+#include "re/RegExp.h"
+#include "re/strutils.h"
+#include "URL.h"
+#include "IEHostWindow.h"
+#include <map>
+#include <unordered_set>
+
+using namespace abp;
+using namespace std;
+using namespace re;
+using namespace strutils;
+
+CombinedMatcher AdBlockPlus::regexpMatcher;
+ElemHideMatcher AdBlockPlus::elemhideMatcher;
+
+wstring AdBlockPlus::s_strFilterFile = L"";
+wstring AdBlockPlus::s_strLoadingFile = L"";
+
+bool AdBlockPlus::s_bEnabled = false;
+bool AdBlockPlus::s_bLoading = false;
+
+unsigned int AdBlockPlus::s_loadStartTick = 0;
+unsigned int AdBlockPlus::s_loadTicks = 0;
+
+// do not process files larger than 20MB
+const ULONGLONG AdBlockPlus::FILE_SIZE_LIMIT = 20 * (1 << 20);
+
+// synchronization
+ReaderWriterMutex AdBlockPlus::s_mutex;
+
+const vector<wstring> AdBlockPlus::vEmpty;
+
+void AdBlockPlus::clearFilters()
+{
+	disable();
+	s_strFilterFile.clear();
+	WriterLock wl(s_mutex);
+	clearFiltersInternal();
+}
+
+void AdBlockPlus::clearFiltersInternal(bool reload)
+{
+	// do the clean up
+	regexpMatcher.clear();
+	elemhideMatcher.clear();
+	if (!reload) // keep filters during reload to speed up
+		Filter::clearKnownFilters();
+}
+
+void AdBlockPlus::enable()
+{
+	// protection: dangerous to enable while still loading
+	if (s_bLoading)
+		return;
+	s_bEnabled = true;
+}
+
+void AdBlockPlus::disable()
+{
+	s_bEnabled = false;
+}
+
+void AdBlockPlus::reloadFilterFile()
+{
+	loadFilterFile(s_strFilterFile);
+}
+
+void AdBlockPlus::loadFilterFile(const wstring& pathname)
+{
+	s_loadStartTick = GetTickCount();
+	disable();
+	s_strLoadingFile = pathname;
+	s_bLoading = true;
+	wstring* pstr = new wstring(pathname);
+	AfxBeginThread(asyncLoader, reinterpret_cast<void*>(pstr));
+}
+
+void AdBlockPlus::filterLoadedCallback(bool loaded)
+{
+	s_bLoading = false;
+	if (loaded)
+		s_strFilterFile = s_strLoadingFile;
+	s_loadTicks = GetTickCount() - s_loadStartTick;
+}
+
+bool AdBlockPlus::shouldLoad(const wstring& location, ContentType_T contentType,
+							 const wstring& docLocation, bool thirdParty)
+{
+	if (!s_bEnabled) return true;
+
+	Utils::URLTokenizer tokens(docLocation);
+
+	ReaderLock rl(s_mutex);
+
+	// Check document whitelist rules
+	RegExpFilter* docFilter = regexpMatcher.matchesAny(docLocation, DOCUMENT, tokens.domain, false);
+	if (docFilter && docFilter->isException())
+		return true;
+
+	// Check regular filters
+	RegExpFilter* filter = regexpMatcher.matchesAny(location, contentType, tokens.domain, thirdParty);
+	return !filter || filter->isException();
+}
+
+bool AdBlockPlus::shouldSendDNTHeader(const wstring& location)
+{
+	if (!s_bEnabled) return false;
+
+	ReaderLock rl(s_mutex);
+
+	RegExpFilter* filter = regexpMatcher.matchesAny(location, DONOTTRACK, L"", false);
+	return filter && !filter->isException();
+}
+
+int AdBlockPlus::getNumberOfFilters()
+{
+	return (int)Filter::getKnownFilters().size();
+}
+
+int AdBlockPlus::getNumberOfActiveFilters()
+{
+	return regexpMatcher.getNumberOfFilters() + elemhideMatcher.getNumberOfFilters();
+}
+
+bool AdBlockPlus::getElemHideStyles(const wstring& location, vector<wstring>& out)
+{
+	if (!s_bEnabled) return false;
+
+	// Don't need any lock here -- access is from main thread only
+
+	// Check whether we are allowed to hide elements on this page
+	Utils::URLTokenizer tokens(location);
+	// Check document exception rules
+	RegExpFilter* docFilter = regexpMatcher.matchesAny(location, DOCUMENT, tokens.domain, false);
+	if (docFilter && docFilter->isException())
+		return false;
+	// Check elemhide exception rules
+	docFilter = regexpMatcher.matchesAny(location, ELEMHIDE, tokens.domain, false);
+	if (docFilter && docFilter->isException())
+		return false;
+
+	// Query elemhideMatcher to get the list of style text
+	out = elemhideMatcher.generateCSSContentForDomain(tokens.domain);
+	return true;
+}
+
+const vector<wstring>& AdBlockPlus::getGlobalElemHideStyles()
+{
+	if (!s_bEnabled) return vEmpty;
+
+	return elemhideMatcher.getGeneralCSSContent();
+}
+
+// pattern.ini parsing
+namespace abp {
+	class INIParser {
+	public:
+		enum Section {
+			OTHER,
+			FILTER,
+			PATTERN,
+			SUBSCRIPTION,
+			SUBSCRIPTION_FILTERS,
+			SUBSCRIPTION_PATTERNS,
+			USER_PATTERNS
+		};
+
+		INIParser() : wantObj(false), subscriptionDisabled(false),
+			curSection(OTHER) {}
+		void process(const wstring& line, bool eof);
+		unordered_set<ActiveFilter*, ActiveFilter::Hasher, ActiveFilter::EqualTo> filters;
+
+		static map<wstring, Section> sectionMapper;
+	private:
+		class SectionMapperInit {
+		public:
+			SectionMapperInit()
+			{
+				RegExp re = L"/_/";
+#define DEFSECTION(section) sectionMapper[replace(toLowerCase(L#section), re, L" ")] = section
+				DEFSECTION(OTHER);
+				DEFSECTION(FILTER);
+				DEFSECTION(PATTERN);
+				DEFSECTION(SUBSCRIPTION);
+				DEFSECTION(SUBSCRIPTION_FILTERS);
+				DEFSECTION(SUBSCRIPTION_PATTERNS);
+				DEFSECTION(USER_PATTERNS);
+			}
+		};
+		static SectionMapperInit init;
+
+		bool wantObj;
+		bool subscriptionDisabled;
+		Section curSection;
+		map<wstring, wstring> curObj;
+		vector<wstring> curList;
+		unordered_set<Filter*, Filter::Hasher, Filter::EqualTo> persistedFilters;
+	};
+
+	map<wstring, INIParser::Section> INIParser::sectionMapper;
+	INIParser::SectionMapperInit INIParser::init;
+
+	void INIParser::process(const wstring& line, bool eof)
+	{
+		static const RegExp re1 = L"/^(\\w+)=(.*)$/";
+		static const RegExp re2 = L"/^\\s*\\[(.+)\\]\\s*$/";
+		static const RegExp re3 = L"/\\\\\\[/g";
+
+		static const wstring strDisabled = L"disabled";
+		static const wstring strTrue = L"true";
+		static const wstring strLeftBracket = L"[";
+
+		RegExpMatch* match = NULL;
+		if (wantObj && (match = re1.exec(line)))
+		{
+			curObj[match->substrings[1]] = match->substrings[2];
+			delete match;
+		}
+		else if (eof || (match = re2.exec(line)))
+		{
+			wstring strSection;
+			if (match)
+			{
+				strSection = toLowerCase(match->substrings[1]);
+				delete match;
+			}
+			if (wantObj ? curObj.size() : curList.size())
+			{
+				// Process current object before going to next section
+				switch (curSection)
+				{
+				case FILTER:
+				case PATTERN:
+					// create the filter, with certain properties set up
+					// do not insert it into the filters set
+					// if it's active, it'll be inserted in some subscription we'll later parse
+					persistedFilters.insert(Filter::fromObject(curObj));
+					break;
+				case SUBSCRIPTION:
+					// not supported, just record whether the whole subscription is disabled or not
+					{
+						auto iter = curObj.find(strDisabled);
+						subscriptionDisabled =
+							iter != curObj.end() && iter->second == strTrue;
+					}
+					break;
+				case SUBSCRIPTION_FILTERS:
+				case SUBSCRIPTION_PATTERNS:
+				case USER_PATTERNS:
+					if (!subscriptionDisabled)
+					{
+						for (size_t i = 0; i < curList.size(); i++)
+						{
+							const wstring& text = curList[i];
+							Filter* filter = Filter::fromText(text);
+							// need to reset the disabled property since we don't clear
+							// the global filter list between reloads
+							ActiveFilter* activeFilter = filter->toActiveFilter();
+							if (activeFilter)
+							{
+								// Only reset disabled property for those not persisted yet
+								if (persistedFilters.find(filter) == persistedFilters.end())
+									activeFilter->setDisabled(false);
+								// just put the filter in INIParser::filters
+								filters.insert(activeFilter);
+							}
+						}
+					}
+				}
+			}
+
+			if (eof) return;
+
+			auto iter = sectionMapper.find(strSection);
+			if (iter != sectionMapper.end())
+			{
+				curSection = iter->second;
+				switch (curSection)
+				{
+				case FILTER:
+				case PATTERN:
+				case SUBSCRIPTION:
+					wantObj = true;
+					curObj.clear();
+					break;
+				case SUBSCRIPTION_FILTERS:
+				case SUBSCRIPTION_PATTERNS:
+				case USER_PATTERNS:
+				default:
+					wantObj = false;
+					curList.clear();
+				}
+			}
+		}
+		else if (!wantObj && line.length())
+		{
+			curList.push_back(replace(line, re3, strLeftBracket));
+		}
+	}
+}
+
+unsigned int AdBlockPlus::asyncLoader(void* ppathname)
+{
+	wstring* pstr = reinterpret_cast<wstring*>(ppathname);
+	wstring pathname = *pstr;
+	delete pstr;
+
+	bool loaded = false;
+
+	// then load stuff
+	CFile file;
+	if (file.Open(pathname.c_str(), CFile::modeRead | CFile::shareDenyWrite))
+	{
+		wstring content;
+		bool success = readFile(file, content);
+		file.Close();
+		if (success)
+		{
+			WriterLock wl(s_mutex);
+			clearFiltersInternal(true);
+
+			INIParser parser;
+			
+			// split content into lines, process with INIParser one by one
+			size_t lastPos = 0;
+			wchar_t lastCh = 0;
+			for (size_t i = 0; i < content.length(); i++)
+			{
+				wchar_t ch = content[i];
+				// accept CR, LF and CRLF sequence
+				if (ch == L'\r' || (ch == L'\n' && lastCh != L'\r'))
+				{
+					parser.process(content.substr(lastPos, i - lastPos), false);
+				}
+				if (ch == L'\r' || ch == L'\n')
+					lastPos = i + 1;
+				lastCh = ch;
+			}
+			if (lastPos < content.length())
+				parser.process(content.substr(lastPos, content.length() - lastPos), false);
+			parser.process(L"", true);
+
+			// put everything in INIParser::filters into the matcher
+			for (auto iter = parser.filters.begin(); iter != parser.filters.end(); ++iter)
+			{
+				ActiveFilter* filter = *iter;
+				if (!filter || filter->isDisabled()) continue;
+
+				RegExpFilter* regexpFilter = filter->toRegExpFilter();
+				if (regexpFilter)
+				{
+					regexpMatcher.add(regexpFilter);
+					continue;
+				}
+
+				ElemHideFilter* elemhideFilter = filter->toElemHideFilter();
+				if (elemhideFilter)
+					elemhideMatcher.add(elemhideFilter);
+			}
+			// generate the general filter list for elemhideMatcher to improve speed
+			elemhideMatcher.generateGeneralFilters();
+			loaded = true;
+		}
+	}
+
+	// Notify main thread about load completion
+	CIEHostWindow* pWindow = CIEHostWindow::GetAnyUtilsWindow();
+	if (pWindow)
+		pWindow->RunAsync([=]
+		{
+			filterLoadedCallback(loaded);
+			pWindow->SendMessage(UserMessage::WM_USER_MESSAGE,
+				loaded ? UserMessage::WPARAM_ABP_FILTER_LOADED : UserMessage::WPARAM_ABP_LOAD_FAILURE, 0);
+		});
+	else
+		filterLoadedCallback(loaded);
+
+	return 0;
+}
+
+bool AdBlockPlus::readFile(CFile& file, wstring& content)
+try
+{
+	// File encoding signatures
+	static const WORD SIG_UNICODE = 0xFEFF; // Unicode (little endian)
+	static const WORD SIG_UNICODE_BIG_ENDIAN = 0xFFFE; // Unicode big endian
+	static const DWORD SIG_UTF8 = 0xBFBBEF; /*EF BB BF*/ // UTF-8
+
+	// Read the signature from file
+	WORD signature = 0;
+	if (file.GetLength() >= 2)
+	{
+		file.Read(&signature, 2);
+		file.SeekToBegin();
+	}
+	// Use different ways to open files with different encodings
+	bool success = false;
+	if (signature == SIG_UNICODE)
+		success = readUnicode(file, content);
+	else if (signature == SIG_UNICODE_BIG_ENDIAN)
+		success = readUnicodeBigEndian(file, content);
+	else if(signature == (SIG_UTF8 & 0xffff))
+	{
+		if (file.GetLength() >= 3) {
+			DWORD sig = 0;
+			file.Read(&sig, 3);
+			file.SeekToBegin();
+			if (sig == SIG_UTF8)
+				success = readUTF8(file, content);
+			else
+			{
+				success = readUTF8OrANSI(file, content);
+			}
+		} else success = readUTF8OrANSI(file, content);
+	}
+	else 
+		success = readUTF8OrANSI(file, content);
+	
+	return success;
+}
+catch (...)
+{
+	TRACE(L"Failed to load filter file.\n");
+	return false;
+}
+
+bool AdBlockPlus::readUTF8OrANSI(CFile& file, wstring& content)
+{
+	// try twice, first with UTF8, then fallback to ANSI
+	bool success = readUTF8(file, content, false);
+	if (!success)
+	{
+		file.SeekToBegin();
+		success = readANSI(file, content);
+	}
+	return success;
+}
+
+bool AdBlockPlus::readANSI(CFile& file, wstring& content)
+{
+	ULONGLONG contentLength = file.GetLength();
+	// Do not process files larger than 10MB
+	if (contentLength == 0)
+	{
+		content = L"";
+		return true;
+	}
+	if (contentLength > FILE_SIZE_LIMIT)
+		contentLength = FILE_SIZE_LIMIT;
+	char* buffer = new char[(size_t)contentLength];
+	file.Read(buffer, (unsigned int)contentLength);
+
+	// We need a code page convertion here
+	// Calculate the size of buffer needed
+	int newContentLength = MultiByteToWideChar(CP_ACP, 0, 
+		buffer, (int)contentLength, NULL, 0);
+	if (!newContentLength)
+	{
+		delete[] buffer;
+		return false;
+	}
+	content.resize(newContentLength);
+
+	// Real convertion
+	int size = MultiByteToWideChar(CP_ACP, 0, 
+		buffer, (int)contentLength, &content[0], newContentLength);
+	delete[] buffer;
+	return 0 != size;
+}
+
+bool AdBlockPlus::readUTF8(CFile& file, wstring& content, bool skipBOM)
+{
+	ULONGLONG contentLength = (file.GetLength() - (skipBOM ? 3 : 0));
+	if (contentLength <= 0)
+	{
+		content = L"";
+		return true;
+	}
+	if (contentLength > FILE_SIZE_LIMIT)
+		contentLength = FILE_SIZE_LIMIT;
+	if (skipBOM) file.Seek(3, CFile::begin);
+
+	char* buffer = new char[(size_t)contentLength];
+	file.Read(buffer, (unsigned int)contentLength);
+
+	// We need a code page convertion here
+	// Calculate the size of buffer needed
+	int newContentLength = MultiByteToWideChar(CP_UTF8, 0, 
+		buffer, (int)contentLength, NULL, 0);
+	if (!newContentLength)
+	{
+		delete[] buffer;
+		return false;
+	}
+	content.resize(newContentLength);
+
+	// Real convertion
+	int size = MultiByteToWideChar(CP_UTF8, 0, 
+		buffer, (int)contentLength, &content[0], newContentLength);
+	delete[] buffer;
+	return 0 != size;
+}
+
+bool AdBlockPlus::readUnicode(CFile& file, wstring& content)
+{
+	ASSERT(sizeof(wchar_t) == 2); // required by UTF16
+
+	ULONGLONG contentLength = (file.GetLength() - 2) / sizeof(wchar_t);
+	if (contentLength <= 0)
+	{
+		content = L"";
+		return true;
+	}
+	if (contentLength > FILE_SIZE_LIMIT)
+		contentLength = FILE_SIZE_LIMIT;
+	content.resize((size_t)contentLength);
+	file.Seek(2, CFile::begin);
+
+	// Directly put the contents into the wstring
+	file.Read(&content[0], (unsigned int)(contentLength * sizeof(wchar_t)));
+	
+	return true;
+}
+
+bool AdBlockPlus::readUnicodeBigEndian(CFile& file, wstring& content)
+{
+	ASSERT(sizeof(wchar_t) == 2); // required by UTF16
+
+	ULONGLONG contentLength = (file.GetLength() - 2) / sizeof(wchar_t);
+	if (contentLength <= 0)
+	{
+		content = L"";
+		return true;
+	}
+	if (contentLength > FILE_SIZE_LIMIT)
+		contentLength = FILE_SIZE_LIMIT;
+	content.resize((size_t)contentLength);
+	file.Seek(2, CFile::begin);
+
+	// Directly put the contents into the wstring
+	file.Read(&content[0], (unsigned int)(contentLength * sizeof(wchar_t)));
+
+	// reverse the bytes in each character
+	for (int i = 0; i < (int)contentLength; i++) {
+		unsigned int ch = content[i];
+		content[i] = (wchar_t)((ch >> 8) | (ch << 8));
+	}
+
+	return true;
+}
diff --git a/plugin/abp/AdBlockPlus.h b/plugin/abp/AdBlockPlus.h
new file mode 100644
index 0000000..7e53f77
--- /dev/null
+++ b/plugin/abp/AdBlockPlus.h
@@ -0,0 +1,102 @@
+/*
+This file is part of Fire-IE.
+
+Fire-IE is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Fire-IE is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Fire-IE.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// AdBlockPlus.h : necessary ABP control routines
+//
+
+#include <string>
+#include "FilterContentType.h"
+#include "Matcher.h"
+#include "ElemHideMatcher.h"
+#include "RAIILock.h"
+
+class CFile;
+
+namespace abp {
+
+class AdBlockPlus {
+public:
+	// main control routines, should only be called from main thread
+	static void loadFilterFile(const std::wstring& pathname);
+	static void reloadFilterFile();
+	static void clearFilters();
+	static void enable();
+	static void disable();
+
+	// performance monitoring
+	static int getNumberOfFilters();
+	static int getNumberOfActiveFilters();
+	static unsigned int getLoadTicks() { return s_loadTicks; }
+
+	static bool isEnabled() { return s_bEnabled; }
+	static bool isLoading() { return s_bLoading; }
+	static const std::wstring& getLoadedFile() { return s_strFilterFile; }
+
+	// query routines
+	// Should we load the resource?
+	static bool shouldLoad(const std::wstring& location, ContentType_T contentType,
+						   const std::wstring& docLocation, bool thirdParty);
+	// Should we emit DNT header for the url?
+	static bool shouldSendDNTHeader(const std::wstring& location);
+
+	// Retrieve CSS style texts for element hiding filters (excluding general styles)
+	static bool getElemHideStyles(const std::wstring& location, std::vector<std::wstring>& out);
+	// Retrieve global CSS style texts for element hiding filters
+	static const std::vector<std::wstring>& getGlobalElemHideStyles();
+#ifdef MATCHER_PERF
+	static void showPerfInfo() { regexpMatcher.showPerfInfo(); }
+#endif
+private:
+	static bool s_bEnabled;
+	static bool s_bLoading;
+
+	static unsigned int s_loadStartTick;
+	static unsigned int s_loadTicks;
+
+	static std::wstring s_strFilterFile;
+	static std::wstring s_strLoadingFile;
+
+	static CombinedMatcher regexpMatcher;
+	static ElemHideMatcher elemhideMatcher;
+
+	static void clearFiltersInternal(bool reload = false);
+
+	// asynchronous filter loading
+	static unsigned int asyncLoader(void* ppathname);
+
+	// should be called on main thread
+	static void filterLoadedCallback(bool loaded);
+
+	// file reading utilities
+	static bool readFile(CFile& file, std::wstring& content);
+	static bool readUTF8OrANSI(CFile& file, std::wstring& content);
+	static bool readANSI(CFile& file, std::wstring& content);
+	static bool readUTF8(CFile& file, std::wstring& content, bool skipBOM = true);
+	static bool readUnicode(CFile& file, std::wstring& content);
+	static bool readUnicodeBigEndian(CFile& file, std::wstring& content);
+
+	static const ULONGLONG FILE_SIZE_LIMIT;
+
+	// used internally for synchronization
+	static ReaderWriterMutex s_mutex;
+
+	static const std::vector<std::wstring> vEmpty;
+};
+
+} // namespace abp
diff --git a/plugin/abp/ElemHideMatcher.cpp b/plugin/abp/ElemHideMatcher.cpp
new file mode 100644
index 0000000..ce938af
--- /dev/null
+++ b/plugin/abp/ElemHideMatcher.cpp
@@ -0,0 +1,257 @@
+/*
+This file is part of Fire-IE.
+
+Fire-IE is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Fire-IE is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Fire-IE.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+// ElemHideMatcher.cpp : Matcher for element hiding filters
+//
+
+#include "StdAfx.h"
+
+#include "ElemHideMatcher.h"
+#include "FilterClasses.h"
+#include "re/strutils.h"
+
+using namespace abp;
+using namespace std;
+using namespace re::strutils;
+
+const size_t ElemHideMatcher::maxCacheEntries = 1000;
+const wstring ElemHideMatcher::hidingStyle = L"{display:none!important;}";
+// Due to IE's 4096 selectors limit per <style> or <link rel="stylesheet">
+const int ElemHideMatcher::selectorGrouping = 4000;
+
+namespace abp {
+	// Hash function based on ElemHideFilter::selector
+	class ElemHideSelectorHasher : public unary_function<ElemHideFilter*, size_t> {
+	public:
+		size_t operator()(ElemHideFilter* filter) const
+		{
+			return hasher(filter->getSelector());
+		}
+	private:
+		static const hash<wstring> hasher;
+	};
+
+	const hash<wstring> ElemHideSelectorHasher::hasher;
+
+	// Equality function based on ElemHideFilter::selector
+	class ElemHideSelectorEqualTo : public binary_function<ElemHideFilter*, ElemHideFilter*, bool> {
+	public:
+		bool operator()(ElemHideFilter* filterLeft, ElemHideFilter* filterRight) const
+		{
+			return filterLeft == filterRight || filterLeft->getSelector() == filterRight->getSelector();
+		}
+	};
+
+	struct ElemHideMatcher::FilterSetInternal {
+		unordered_set<ElemHideFilter*, ElemHideSelectorHasher, ElemHideSelectorEqualTo> selectors;
+	};
+} // namespace abp
+
+// Add an ElemHideFilter
+void ElemHideMatcher::add(ElemHideFilter* filter)
+{
+	if (generated) return;
+
+	if (filter->isException())
+	{
+		exceptionFiltersBySelector[filter->getSelector()].push_back(filter);
+	}
+	else
+	{
+		const map<wstring, bool>& domains = filter->getDomains();
+		if (!domains.size())
+			filtersByDomain[L""].push_back(filter);
+		else
+		{
+			for (auto iter = domains.begin(); iter != domains.end(); ++iter)
+			{
+				if (iter->second)
+					filtersByDomain[iter->first].push_back(filter);
+			}
+		}
+	}
+	m_nFilters++;
+}
+
+// Clear all filters
+void ElemHideMatcher::clear()
+{
+	resultCache.clear();
+	filtersByDomain.clear();
+	exceptionFiltersBySelector.clear();
+	generalFilters.clear();
+	generalCSSContent.clear();
+	generated = false;
+	m_nFilters = 0;
+}
+
+// Usually called at the end of the insertion step to optimize matching speed
+// Should not add any more filters after calling this and before calling clear()
+void ElemHideMatcher::generateGeneralFilters()
+{
+	if (generated) return;
+
+	auto iter = filtersByDomain.find(L"");
+	if (iter != filtersByDomain.end())
+	{
+		TList<ElemHideFilter*>& filters = iter->second;
+		vector<ElemHideFilter*> newFilters;
+		for (unsigned int i = 0; i < filters.size(); i++)
+		{
+			ElemHideFilter* filter = filters[i];
+			if (filter->getDomains().size() ||
+				exceptionFiltersBySelector.find(filter->getSelector()) != exceptionFiltersBySelector.end())
+			{
+				// not active on all domains, keep in list
+				newFilters.push_back(filter);
+			}
+			else
+			{
+				// put in general filters list
+				generalFilters.push_back(filter);
+			}
+		}
+		// replace original filters for "" domain
+		filters = std::move(newFilters);
+	}
+	generalCSSContent = generateCSSContent(generalFilters);
+	generated = true;
+}
+
+vector<wstring> ElemHideMatcher::generateCSSContent(const vector<ElemHideFilter*>& filters) const
+{
+	vector<wstring> result;
+	// Due to IE's 4096 selectors limit per <style> or <link rel="stylesheet">
+	// We have to group them into separate <style> blocks
+	for (int i = 0; i < (int)filters.size(); i += selectorGrouping)
+	{
+		int end = i + selectorGrouping;
+		if (end > (int)filters.size()) end = (int)filters.size();
+		result.push_back(generateSingleCSSContent(filters, i, end));
+	}
+	return result;
+}
+
+wstring ElemHideMatcher::generateSingleCSSContent(const vector<ElemHideFilter*>& filters, size_t begin, size_t end) const
+{
+	wstring result;
+	size_t length = 0;
+	// calculate needed size for the string, avoiding reallocations
+	for (size_t i = begin; i < end; i++)
+	{
+		length += filters[i]->getSelector().size() + hidingStyle.size();
+	}
+	// assemble the selectors and styles together
+	result.reserve(length);
+	for (size_t i = begin; i < end; i++)
+	{
+		result.append(filters[i]->getSelector()).append(hidingStyle);
+	}
+	return result;
+}
+
+vector<wstring> ElemHideMatcher::generateCSSContentForDomain(const wstring& domain)
+{
+	return generateCSSContent(getFiltersForDomain(domain));
+}
+
+// Retrieve all filters active on a particular domain
+vector<ElemHideFilter*> ElemHideMatcher::getFiltersForDomain(const wstring& aDomain)
+{
+	wstring domain = toUpperCase(aDomain);
+	vector<ElemHideFilter*> result;
+
+	if (queryResultCache(domain, result))
+		return result;
+
+	FilterSetInternal filterSet;
+	getFilterSetForDomain(domain, filterSet);
+
+	result.assign(filterSet.selectors.begin(), filterSet.selectors.end());
+
+	putResultCache(domain, result);
+	return result;
+}
+
+void ElemHideMatcher::getFilterSetForDomain(const wstring& aDomain, FilterSetInternal& filterSet) const
+{
+	auto& selectors = filterSet.selectors;
+	wstring domain = aDomain;
+	while (true)
+	{
+		auto iter = filtersByDomain.find(domain);
+		if (iter != filtersByDomain.end())
+		{
+			const TList<ElemHideFilter*>& filters = iter->second;
+			for (unsigned int i = 0; i < filters.size(); i++)
+			{
+				ElemHideFilter* filter = filters[i];
+				auto iterSelector = selectors.find(filter);
+				if (iterSelector != selectors.end())
+					continue; // already have same selector
+
+				if (!filter->isActiveOnDomain(aDomain))
+					continue; // not active
+
+				auto iterExcept = exceptionFiltersBySelector.find(filter->getSelector());
+				if (iterExcept != exceptionFiltersBySelector.end())
+				{
+					const TList<ElemHideFilter*>& exceptionFilters = iterExcept->second;
+					bool bContinue = false;
+					for (unsigned int i = 0; i < exceptionFilters.size(); i++)
+					{
+						if (exceptionFilters[i]->isActiveOnDomain(aDomain))
+						{
+							bContinue = true;
+							break;
+						}
+					}
+					if (bContinue) continue; // met an exception filter
+				}
+
+				// passes all tests, add to the result
+				selectors.insert(filter);
+			}
+		}
+
+		if (!domain.length()) break;
+
+		size_t nextDot = domain.find(L'.');
+		if (nextDot != wstring::npos)
+			domain = domain.substr(nextDot + 1);
+		else domain.clear();
+	}
+}
+
+bool ElemHideMatcher::queryResultCache(const wstring& key, vector<ElemHideFilter*>& result) const
+{
+	auto iter = resultCache.find(key);
+	if (iter != resultCache.end())
+	{
+		result = iter->second;
+		return true;
+	}
+	return false;
+}
+
+void ElemHideMatcher::putResultCache(const wstring& key, const vector<ElemHideFilter*>& result)
+{
+	if (resultCache.size() >= maxCacheEntries)
+		resultCache.clear(); // TODO: use LRU cache instead
+
+	resultCache[key] = result;
+}
diff --git a/plugin/abp/ElemHideMatcher.h b/plugin/abp/ElemHideMatcher.h
new file mode 100644
index 0000000..df3801f
--- /dev/null
+++ b/plugin/abp/ElemHideMatcher.h
@@ -0,0 +1,73 @@
+/*
+This file is part of Fire-IE.
+
+Fire-IE is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Fire-IE is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Fire-IE.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// ElemHideMatcher.h : Matcher for element hiding filters
+//
+
+#include "TList.h"
+#include <string>
+#include <vector>
+#include <unordered_map>
+#include <unordered_set>
+
+namespace abp {
+	class ElemHideFilter;
+
+	class ElemHideMatcher {
+	public:
+		ElemHideMatcher() { generated = false; m_nFilters = 0; }
+		void add(ElemHideFilter* filter);
+		void clear();
+		void generateGeneralFilters();
+		// generates list of CSS content for a particular domain (without general filters)
+		std::vector<std::wstring> generateCSSContentForDomain(const std::wstring& domain);
+		// get the general CSS content that applys to every page
+		const std::vector<std::wstring>& getGeneralCSSContent() const { return generalCSSContent; }
+
+		int getNumberOfFilters() const { return m_nFilters; }
+	private:
+		struct FilterSetInternal;
+		std::vector<ElemHideFilter*> getFiltersForDomain(const std::wstring& domain);
+		void getFilterSetForDomain(const std::wstring& domain, FilterSetInternal& filterSet) const;
+
+		std::vector<std::wstring> generateCSSContent(const std::vector<ElemHideFilter*>& filters) const;
+		std::wstring generateSingleCSSContent(const std::vector<ElemHideFilter*>& filters, size_t begin, size_t end) const;
+
+		// worth implementing a cache
+		std::unordered_map<std::wstring, std::vector<ElemHideFilter*> > resultCache;
+		bool queryResultCache(const std::wstring& key, std::vector<ElemHideFilter*>& result) const;
+		void putResultCache(const std::wstring& key, const std::vector<ElemHideFilter*>& result);
+
+		// Keep track of number of filters
+		int m_nFilters;
+		// Filters grouped by active domain
+		std::unordered_map<std::wstring, TList<ElemHideFilter*> > filtersByDomain;
+		// Exception filters grouped by selector string
+		std::unordered_map<std::wstring, TList<ElemHideFilter*> > exceptionFiltersBySelector;
+		// Filters that will always match everywhere
+		std::vector<ElemHideFilter*> generalFilters;
+		// Converted into styles
+		std::vector<std::wstring> generalCSSContent;
+		bool generated;
+
+		static const size_t maxCacheEntries;
+		static const std::wstring hidingStyle;
+		static const int selectorGrouping;
+	};
+} // namespace abp
diff --git a/plugin/abp/FilterClasses.cpp b/plugin/abp/FilterClasses.cpp
new file mode 100644
index 0000000..3df7db2
--- /dev/null
+++ b/plugin/abp/FilterClasses.cpp
@@ -0,0 +1,637 @@
+/*
+This file is part of Fire-IE.
+
+Fire-IE is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Fire-IE is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Fire-IE.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+// FilterClasses.cpp : ABP filter classes implementation
+//
+
+#include "StdAfx.h"
+
+#include "FilterClasses.h"
+#include "re/strutils.h"
+#include <algorithm>
+
+using namespace abp;
+using namespace re;
+using namespace re::strutils;
+using namespace std;
+
+static const wstring strEmpty = L"";
+
+// Regular expression that element hiding filters should match
+const RegExp Filter::elemhideRegExp = L"/^([^\\/\\*\\|\\@\"!]*?)#(\\@)?(?:([\\w\\-]+|\\*)((?:\\([\\w\\-]+(?:[$^*]?=[^\\(\\)\"]*)?\\))*)|#([^{}]+))$/";
+
+// Regular expression that RegExp filters specified as RegExps should match
+const RegExp Filter::regexpRegExp = L"/^(@@)?\\/.*\\/(?:\\$~?[\\w\\-]+(?:=[^,\\s]+)?(?:,~?[\\w\\-]+(?:=[^,\\s]+)?)*)?$/";
+
+// Regular expression that options on a RegExp filter should match
+const RegExp Filter::optionsRegExp = L"/\\$(~?[\\w\\-]+(?:=[^,\\s]+)?(?:,~?[\\w\\-]+(?:=[^,\\s]+)?)*)$/";
+
+/**
+ * Cache for known filters, maps string representation to filter objects.
+ */
+Filter::FiltersHolder Filter::knownFiltersHolder;
+unordered_map<wstring, Filter*>& Filter::knownFilters = knownFiltersHolder.filters;
+
+// Automatically cleanup at program exit
+void Filter::FiltersHolder::clear()
+{
+	// not just a "clear" call, we should free the Filters themselves
+	for (auto iter = filters.begin(); iter != filters.end(); ++iter)
+		delete iter->second;
+	filters.clear();
+}
+
+void Filter::clearKnownFilters()
+{
+	knownFiltersHolder.clear();
+}
+
+/**
+ * Creates a filter of correct type from its text representation - does the basic parsing and
+ * calls the right constructor then.
+ */
+Filter* Filter::fromText(const wstring& text)
+{
+	unordered_map<wstring, Filter*>::iterator iter = knownFilters.find(text);
+	if (iter != knownFilters.end())
+		return iter->second;
+
+	Filter* ret = NULL;
+	RegExpMatch* match = (text.find(L'#') != wstring::npos ? elemhideRegExp.exec(text) : NULL);
+	if (match)
+	{
+		const vector<wstring>& substrings = match->substrings;
+		ret = ElemHideBase::fromText(text, substrings[1], 0 != substrings[2].length(), substrings[3],
+			substrings[4], substrings[5]);
+		delete match;
+	}
+	else if (startsWithChar(text, L'!'))
+	{
+		ret = new CommentFilter(text);
+	}
+	else
+	{
+		ret = RegExpFilter::fromText(text);
+	}
+
+	knownFilters[ret->text] = ret;
+	return ret;
+}
+
+namespace abp { namespace funcStatic { namespace Filter_fromObject {
+	static const wstring strText = L"text";
+	static const wstring strDisabled = L"disabled";
+	static const wstring strTrue = L"true";
+} } } // namespace abp::funcStatic::Filter_fromObject
+
+Filter* Filter::fromObject(const map<wstring, wstring>& obj)
+{
+	using namespace funcStatic::Filter_fromObject;
+
+	auto iter = obj.find(strText);
+	if (iter != obj.end())
+	{
+		Filter* filter = Filter::fromText(iter->second);
+		if (filter)
+		{
+			ActiveFilter* af = filter->toActiveFilter();
+			if (af)
+			{
+				iter = obj.find(strDisabled);
+				if (iter != obj.end())
+					af->setDisabled(iter->second == strTrue);
+				else af->setDisabled(false);
+			}
+		}
+		return filter;
+	}
+	return NULL;
+}
+
+namespace abp { namespace funcStatic { namespace Filter_normalize {
+	// pre-compiled to speed up the process
+	static const RegExp re1 = L"/[^\\S ]/g";
+	static const RegExp re2 = L"/^\\s*!/";
+	static const RegExp re3 = L"/^\\s+/";
+	static const RegExp re4 = L"/\\s+$/";
+	static const RegExp re5 = L"/^(.*?)(#\\@?#?)(.*)$/";
+	static const RegExp re6 = L"/\\s/g";
+} } } // namespace abp::funcStatic::Filter_normalize
+
+/**
+ * Removes unnecessary whitespaces from filter text
+ */
+wstring Filter::normalize(const wstring& text)
+{
+	using namespace funcStatic::Filter_normalize;
+
+	// Remove line breaks and such
+	wstring res = replace(text, re1, strEmpty);
+	if (re2.test(res))
+	{
+		// Don't remove spaces inside comments
+		return replace(replace(res, re3, strEmpty), re4, strEmpty);
+	}
+	else if (elemhideRegExp.test(res))
+	{
+		// Special treatment for element hiding filters, right side is allowed to contain spaces
+		RegExpMatch* match = re5.exec(res);
+		if (match)
+		{
+			const wstring& domain = match->substrings[1];
+			const wstring& separator = match->substrings[2];
+			const wstring& selector = match->substrings[3];
+			res = replace(domain, re6, strEmpty) + separator
+				+ replace(replace(selector, re3, strEmpty), re4, strEmpty);
+			delete match;
+		}
+		return res;
+	}
+	else
+	{
+		return replace(res, re6, strEmpty);
+	}
+}
+
+const map<wstring, bool> ActiveFilter::s_mEmpty;
+
+void ActiveFilter::setDisabled(bool value)
+{
+	disabled = value;
+}
+
+namespace abp { namespace funcStatic { namespace ActiveFilter_generateDomains {
+	// pre-compiled to speed up the process
+	static const RegExp re1 = L"/\\.+$/";
+} } } // namespace abp::funcStatic::ActiveFilter_generateDomains
+
+void ActiveFilter::generateDomains(const wstring& domainSource)
+{
+	using namespace funcStatic::ActiveFilter_generateDomains;
+
+	if (domainSource.length())
+	{
+		map<wstring, bool> domains;
+
+		wstring ds = toUpperCase(domainSource);
+		vector<wstring> list = split(ds, wstring(1, domainSeparator));
+
+		bool hasIncludes = false;
+		for (size_t i = 0; i < list.size(); i++)
+		{
+			wstring domain = list[i];
+			if (ignoreTrailingDot)
+				domain = replace(domain, re1, strEmpty);
+			if (domain == strEmpty)
+				continue;
+
+			bool include;
+			if (startsWithChar(domain, L'~'))
+			{
+				include = false;
+				domain = domain.substr(1);
+			}
+			else
+			{
+				include = true;
+				hasIncludes = true;
+			}
+
+			domains[domain] = include;
+		}
+
+		if (domains.size())
+		{
+			domains[strEmpty] = !hasIncludes;
+			this->domains = new map<wstring, bool>(std::move(domains));
+		}
+	}
+}
+
+namespace abp { namespace funcStatic { namespace ActiveFilter_isActiveOnDomain {
+	// pre-compiled to speed up the process
+	static const RegExp re1 = L"/\\.+$/";
+} } } // namespace abp::funcStatic::ActiveFilter_isActiveOnDomain
+
+/**
+ * Checks whether this filter is active on a domain.
+ */
+bool ActiveFilter::isActiveOnDomain(const wstring& docDomain) const
+{
+	using namespace funcStatic::ActiveFilter_isActiveOnDomain;
+
+	// If no domains are set the rule matches everywhere
+	if (!domains) return true;
+
+	// If the document has no host name, match only if the filter isn't restricted to specific domains
+	if (!docDomain.length())
+		return domains->at(strEmpty);
+
+	wstring domain;
+	if (ignoreTrailingDot)
+		domain = replace(docDomain, re1, strEmpty);
+	else domain = docDomain;
+	domain = toUpperCase(domain);
+
+	while (true)
+	{
+		auto iter = domains->find(domain);
+		if (iter != domains->end())
+			return iter->second;
+
+		size_t nextDot = domain.find(L'.');
+		if (nextDot == wstring::npos)
+			break;
+		domain = domain.substr(nextDot + 1);
+	}
+	return domains->at(strEmpty);
+}
+
+namespace abp { namespace funcStatic { namespace ActiveFilter_isActiveOnlyOnDomain {
+	// pre-compiled to speed up the process
+	static const RegExp re1 = L"/\\.+$/";
+} } } // namespace abp::funcStatic::ActiveFilter_isActiveOnlyOnDomain
+
+/**
+ * Checks whether this filter is active only on a domain and its subdomains.
+ */
+bool ActiveFilter::isActiveOnlyOnDomain(const wstring& docDomain) const
+{
+	using namespace funcStatic::ActiveFilter_isActiveOnlyOnDomain;
+
+	if (!docDomain.length() || domains || domains->at(strEmpty))
+		return false;
+
+	wstring domain;
+	if (ignoreTrailingDot)
+		domain = replace(docDomain, re1, strEmpty);
+	else domain = docDomain;
+	domain = toUpperCase(domain);
+	wstring dotDomain = L"." + domain;
+
+	for (auto iter = domains->begin(); iter != domains->end(); ++iter)
+	{
+		if (iter->second && iter->first != domain &&
+			(iter->first.length() <= domain.length() ||
+			iter->first.rfind(dotDomain) != iter->first.length() - dotDomain.length()))
+		{
+			return false;
+		}
+	}
+
+	return true;
+}
+
+/**
+ * Maps type strings like "SCRIPT" or "OBJECT" to bit masks
+ */
+map<wstring, ContentType_T> RegExpFilter::typeMap;
+map<ContentType_T, wstring> RegExpFilter::reverseTypeMap;
+RegExpFilter::TypeMapInitializer RegExpFilter::typeMapInit;
+RegExpFilter::TypeMapInitializer::TypeMapInitializer()
+{
+#define DEFTYPEMAP(type) do { typeMap[L#type] = type; reverseTypeMap[type] = L#type; } while (false)
+	DEFTYPEMAP(OTHER);
+	DEFTYPEMAP(SCRIPT);
+	DEFTYPEMAP(IMAGE);
+	DEFTYPEMAP(STYLESHEET);
+	DEFTYPEMAP(OBJECT);
+	DEFTYPEMAP(SUBDOCUMENT);
+	DEFTYPEMAP(DOCUMENT);
+	DEFTYPEMAP(XBL);
+	DEFTYPEMAP(PING);
+	DEFTYPEMAP(XMLHTTPREQUEST);
+	DEFTYPEMAP(OBJECT_SUBREQUEST);
+	DEFTYPEMAP(DTD);
+	DEFTYPEMAP(MEDIA);
+	DEFTYPEMAP(FONT);
+	DEFTYPEMAP(BACKGROUND);
+	DEFTYPEMAP(POPUP);
+	DEFTYPEMAP(DONOTTRACK);
+	DEFTYPEMAP(ELEMHIDE);
+	DEFTYPEMAP(UNKNOWN_OTHER);
+}
+
+namespace abp { namespace funcStatic { namespace RegExpFilter_generateRegExp {
+	// pre-compiled to speed up the process
+	// Remove multiple wildcards
+	static const RegExp re1 = L"/\\*+/g";
+	static const wstring ws1 = L"*";
+
+	// remove anchors following separator placeholder
+	static const RegExp re2 = L"/\\^\\|$/";
+	static const wstring ws2 = L"^";
+
+	// escape special symbols
+	static const RegExp re3 = L"/\\W/g";
+	static const wstring ws3 = L"\\$&";
+
+	// replace wildcards by .*
+	static const RegExp re4 = L"/\\\\\\*/g";
+	static const wstring ws4 = L".*";
+
+	// process separator placeholders (all ANSI charaters but alphanumeric characters and _%.-)
+	static const RegExp re5 = L"/\\\\\\^/g";
+	static const wstring ws5 = L"(?:[\\x00-\\x24\\x26-\\x2C\\x2F\\x3A-\\x40\\x5B-\\x5E\\x60\\x7B-\\x80]|$)";
+
+	// process extended anchor at expression start
+	static const RegExp re6 = L"/^\\\\\\|\\\\\\|/";
+	static const wstring ws6 = L"^[\\w\\-]+:\\/+(?!\\/)(?:[^.\\/]+\\.)*?";
+
+	// process anchor at expression start
+	static const RegExp re7 = L"/^\\\\\\|/";
+	static const wstring ws7 = L"^";
+
+	// process anchor at expression end
+	static const RegExp re8 = L"/\\\\\\|$/";
+	static const wstring ws8 = L"$";
+} } } // namespace abp::funcStatic::RegExpFilter_generateRegExp
+
+/**
+ * Regular expression to be used when testing against this filter
+ */
+void RegExpFilter::generateRegExp(const wstring& regexpSource)
+{
+	using namespace funcStatic::RegExpFilter_generateRegExp;
+
+	// Remove multiple wildcards
+	wstring source = replace(regexpSource, re1, ws1);
+	// Remove leading wildcards
+	if (startsWithChar(source, L'*')) source = source.substr(1);
+	// Remove trailing wildcards
+	if (endsWithChar(source, L'*')) source = source.substr(0, source.length() - 1);
+
+	// remove anchors & other 6 operations (see above)
+	source = replace(source, re2, ws2);
+	source = replace(source, re3, ws3);
+	source = replace(source, re4, ws4);
+	source = replace(source, re5, ws5);
+	source = replace(source, re6, ws6);
+	source = replace(source, re7, ws7);
+	source = replace(source, re8, ws8);
+
+	// wrap to regexp syntax
+	source.insert(source.begin(), L'/');
+	source.push_back(L'/');
+	if (!matchCase) source.push_back(L'i');
+
+	// construct the RegExp object
+	regexp = source;
+}
+
+/**
+ * Tests whether the URL matches this filter
+ */
+bool RegExpFilter::matches(const wstring& location, ContentType_T contentType, const wstring& docDomain, bool thirdParty) const
+{
+	return (contentType & this->contentType)
+		&& (this->thirdParty == TriNull || (this->thirdParty == TriTrue) == thirdParty)
+		&& regexp.test(location)
+		&& isActiveOnDomain(docDomain);
+}
+
+namespace abp { namespace funcStatic { namespace RegExpFilter_fromText {
+	// pre-compiled to speed up the process
+	static const RegExp re1 = L"/-/";
+	static const RegExp re2 = L"/^\\|?[\\w\\-]+:/";
+
+	static const wstring strAtAt = L"@@";
+	static const wstring strComma = L",";
+	static const wstring strUnderscore = L"_";
+	static const wstring strMatchCase = L"MATCH_CASE";
+	static const wstring strDomain = L"DOMAIN";
+	static const wstring strThirdParty = L"THIRD_PARTY";
+	static const wstring strNotThirdParty = L"~THIRD_PARTY";
+	static const wstring strCollapse = L"COLLAPSE";
+	static const wstring strNotCollapse = L"~COLLAPSE";
+	static const wstring strSiteKey = L"SITEKEY";
+	static const wstring strBar = L"|";
+	static const wstring strDocument = L"DOCUMENT";
+} } } // namespace abp::funcStatic::RegExpFilter_fromText
+
+/**
+ * Creates a RegExp filter from its text representation
+ */
+Filter* RegExpFilter::fromText(const wstring& text)
+{
+	using namespace funcStatic::RegExpFilter_fromText;
+
+	bool blocking = true;
+	wstring regexpSource = text;
+	if (startsWith(text, strAtAt))
+	{
+		blocking = false;
+		regexpSource = regexpSource.substr(2);
+	}
+
+	ContentType_T contentType = 0;
+	bool contentTypeNull = true;
+	bool matchCase = false;
+	wstring domains;
+	vector<wstring> siteKeys;
+	TriBool thirdParty = TriNull;
+	TriBool collapse = TriNull;
+	vector<wstring> options;
+	RegExpMatch* match = regexpSource.find(L'$') != wstring::npos ? Filter::optionsRegExp.exec(regexpSource) : NULL;
+	if (match)
+	{
+		options = split(toUpperCase(match->substrings[1]), strComma);
+		regexpSource = match->input.substr(0, match->index);
+		delete match;
+
+		for (size_t i = 0; i < options.size(); i++)
+		{
+			wstring option = options[i];
+			wstring value;
+			size_t separatorIndex = option.find(L'=');
+			if (separatorIndex != wstring::npos)
+			{
+				value = option.substr(separatorIndex + 1);
+				option = option.substr(0, separatorIndex);
+			}
+			option = replace(option, re1, strUnderscore);
+			auto iter = typeMap.find(option);
+			if (iter != typeMap.end())
+			{
+				if (contentTypeNull)
+				{
+					contentType = 0;
+					contentTypeNull = false;
+				}
+				contentType |= iter->second;
+			}
+			else if (startsWithChar(option, L'~') && typeMap.end() != (iter = typeMap.find(option.substr(1))))
+			{
+				if (contentTypeNull)
+				{
+					contentType = DEFAULT_CONTENT_TYPE;
+					contentTypeNull = false;
+				}
+				contentType &= ~iter->second;
+			}
+			else if (option == strMatchCase)
+				matchCase = true;
+			else if (option == strDomain)
+				domains = value;
+			else if (option == strThirdParty)
+				thirdParty = TriTrue;
+			else if (option == strNotThirdParty)
+				thirdParty = TriFalse;
+			else if (option == strCollapse)
+				collapse = TriTrue;
+			else if (option == strNotCollapse)
+				collapse = TriFalse;
+			else if (option == strSiteKey)
+				siteKeys = split(value, strBar);
+		}
+	}
+
+	if (!blocking && (contentTypeNull || (contentType & DOCUMENT))
+		&& (!options.size() || find(options.begin(), options.end(), strDocument) == options.end())
+		&& !re2.test(regexpSource))
+	{
+		// Exception filters shouldn't apply to pages by default unless they start with a protocol name
+		if (contentTypeNull)
+		{
+			contentTypeNull = false;
+			contentType = DEFAULT_CONTENT_TYPE;
+		}
+		contentType &= ~DOCUMENT;
+	}
+	if (!blocking && siteKeys.size())
+	{
+		contentTypeNull = false;
+		contentType = DOCUMENT;
+	}
+	if (contentTypeNull)
+		contentType = DEFAULT_CONTENT_TYPE;
+
+	try
+	{
+		if (blocking)
+			return new BlockingFilter(text, regexpSource, contentType, matchCase, domains, thirdParty, collapse);
+		else
+			return new WhitelistFilter(text, regexpSource, contentType, matchCase, domains, thirdParty, std::move(siteKeys));
+	}
+	catch (const RegExpCompileError& e)
+	{
+		UNUSED(e); // for release builds
+		TRACE("RegExpCompileError thrown: %s\n", e.what());
+		return new InvalidFilter(text, L"RegExp Compile Error");
+	}
+	catch (...)
+	{
+		TRACE("Unknown exception thrown.");
+		return new InvalidFilter(text, L"Unknown Error");
+	}
+}
+
+const std::vector<std::wstring> WhitelistFilter::s_vEmpty;
+
+namespace abp { namespace funcStatic { namespace ElemHideBase_ElemHideBase {
+	// pre-compiled to speed up the process
+	static const RegExp re1 = L"/,~[^,]+/g";
+	static const RegExp re2 = L"/^~[^,]+,?/";
+} } } // namespace abp::funcStatic::ElemHideBase_ElemHideBase
+
+ElemHideBase::ElemHideBase(const wstring& text, const wstring& domains, const wstring& selector)
+	: ActiveFilter(text, toUpperCase(domains), L',', false), selector(selector)
+{
+	using namespace funcStatic::ElemHideBase_ElemHideBase;
+
+	if (domains.size())
+	{
+		selectorDomain = toLowerCase(replace(replace(domains, re1, strEmpty), re2, strEmpty));
+	}
+}
+
+namespace abp { namespace funcStatic { namespace ElemHideBase_fromText {
+	// pre-compiled to speed up the process
+	static const RegExp re1 = L"/\\([\\w\\-]+(?:[$^*]?=[^\\(\\)\"]*)?\\)/g";
+	static const RegExp re2 = L"/=/";
+
+	static const wstring strEqQuot = L"=\"";
+	static const wstring strStar = L"*";
+} } } // namespace abp::funcStatic::ElemHideBase_fromText
+
+/**
+ * Creates an element hiding filter from a pre-parsed text representation
+ */
+Filter* ElemHideBase::fromText(const wstring& text, const wstring& domain, bool isException,
+	const wstring& tagName, const wstring& attrRules, const wstring& selector)
+{
+	using namespace funcStatic::ElemHideBase_fromText;
+
+	wstring sel = selector;
+	if (!sel.length())
+	{
+		wstring tag = tagName;
+		if (tagName == strStar)
+			tag = strEmpty;
+
+		wstring id;
+		wstring additional = strEmpty;
+		if (attrRules.length())
+		{
+			RegExpMatch* match = strutils::match(attrRules, re1);
+			for (size_t i = 0; i < match->substrings.size(); i++)
+			{
+				wstring rule = match->substrings[i];
+				size_t separatorPos = rule.find(L'=');
+				if (separatorPos != wstring::npos && separatorPos > 0)
+				{
+					rule = replace(rule, re2, strEqQuot);
+					rule.push_back(L'"');
+					additional.push_back(L'[');
+					additional.append(rule);
+					additional.push_back(L']');
+				}
+				else
+				{
+					if (id.length())
+					{
+						delete match;
+						return new InvalidFilter(text, L"Duplicate ID");
+					}
+					else
+						id = rule;
+				}
+			}
+			delete match;
+		}
+
+		if (id.length())
+		{
+			sel = tag;
+			sel.push_back(L'.');
+			sel.append(id);
+			sel.append(additional);
+			sel.push_back(L',');
+			sel.append(tag);
+			sel.push_back(L'#');
+			sel.append(id);
+			sel.append(additional);
+		}
+		else if (tag.length() || additional.length())
+			sel = tag + additional;
+		else
+		{
+			return new InvalidFilter(text, L"No Criteria");
+		}
+	}
+	return new ElemHideFilter(text, domain, sel, isException);
+}
diff --git a/plugin/abp/FilterClasses.h b/plugin/abp/FilterClasses.h
new file mode 100644
index 0000000..60e2b25
--- /dev/null
+++ b/plugin/abp/FilterClasses.h
@@ -0,0 +1,351 @@
+/*
+This file is part of Fire-IE.
+
+Fire-IE is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Fire-IE is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Fire-IE.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// FilterClasses.h : ABP filter classes
+//   almost a direct port from the JS version, with lazy initialization removed (for multi-threading safety)
+//
+
+#include "re/RegExp.h"
+#include "TriBool.h"
+#include "FilterContentType.h"
+#include "PointerHash.h"
+#include <unordered_map>
+#include <map>
+#include <vector>
+
+namespace abp {
+	// Forward declaration
+	class ActiveFilter;
+	class RegExpFilter;
+	class ElemHideFilter;
+
+	/**
+	 * Abstract base class for filters
+	 */
+	class Filter {
+	public:
+		/*
+		 * @param {String} text   string representation of the filter
+		 * @constructor
+		 */
+		Filter(const std::wstring& text) : text(text) {}
+		virtual ~Filter() {}
+
+		const std::wstring& getText() const { return text; }
+		std::wstring toString() const { return text; }
+
+		// custom dynamic_cast routines to avoid RTTI
+		virtual ActiveFilter* toActiveFilter() { return NULL; }
+		virtual const ActiveFilter* toActiveFilter() const { return NULL; }
+		virtual RegExpFilter* toRegExpFilter() { return NULL; }
+		virtual const RegExpFilter* toRegExpFilter() const { return NULL; }
+		virtual ElemHideFilter* toElemHideFilter() { return NULL; }
+		virtual const ElemHideFilter* toElemHideFilter() const { return NULL; }
+
+		static const re::RegExp regexpRegExp;
+		static const re::RegExp optionsRegExp;
+		static const re::RegExp elemhideRegExp;
+
+		static Filter* fromText(const std::wstring& text);
+		static Filter* fromObject(const std::map<std::wstring, std::wstring>& obj);
+		static std::wstring normalize(const std::wstring& text);
+
+		static const std::unordered_map<std::wstring, Filter*>&
+			getKnownFilters() { return knownFilters; }
+		static void clearKnownFilters();
+
+		typedef Utils::PointerHasher<Filter> Hasher;
+		typedef Utils::PointerEqualTo<Filter> EqualTo;
+	private:
+		std::wstring text;
+
+		static struct FiltersHolder {
+			std::unordered_map<std::wstring, Filter*> filters;
+			void clear();
+			~FiltersHolder() { clear(); }
+		} knownFiltersHolder;
+		static std::unordered_map<std::wstring, Filter*>& knownFilters;
+	};
+
+	/**
+	 * Class for invalid filters
+	 * @augments Filter
+	 */
+	class InvalidFilter : public Filter {
+	public:
+		/*
+		 * @param {String} text see Filter()
+		 * @param {String} reason Reason why this filter is invalid
+		 * @constructor
+		 */
+		InvalidFilter(const std::wstring& text, const std::wstring& reason)
+			: Filter(text), reason(reason) {}
+	private:
+		std::wstring reason;
+	};
+
+	/**
+	 * Class for comments
+	 * @augments Filter
+	 */
+	class CommentFilter : public Filter {
+	public:
+		/*
+		 * @param {String} text see Filter()
+		 * @constructor
+		 */
+		CommentFilter(const std::wstring& text)
+			: Filter(text) {}
+	};
+
+	/**
+	 * Abstract base class for filters that can get hits
+	 * @augments Filter
+	 */
+	class ActiveFilter : public Filter {
+	public:
+		bool isDisabled() const { return disabled; }
+		void setDisabled(bool value);
+
+		bool isActiveOnDomain(const std::wstring& docDomain) const;
+		bool isActiveOnlyOnDomain(const std::wstring& docDomain) const;
+		const std::map<std::wstring, bool>& getDomains() const { return domains ? *domains : s_mEmpty; }
+
+		virtual bool isException() const { return false; }
+
+		virtual ActiveFilter* toActiveFilter() { return this; }
+		virtual const ActiveFilter* toActiveFilter() const { return this; }
+
+		typedef Utils::PointerHasher<ActiveFilter> Hasher;
+		typedef Utils::PointerEqualTo<ActiveFilter> EqualTo;
+	protected:
+		/*
+		 * @param {String} text see Filter()
+		 * @param {String} domains  (optional) Domains that the filter is restricted to separated by domainSeparator e.g. "foo.com|bar.com|~baz.com"
+		 * @constructor
+		 */
+		ActiveFilter(const std::wstring& text, const std::wstring& domains = L"", 
+					 wchar_t domainSeparator = L'|', bool ignoreTrailingDot = true)
+			: Filter(text), domainSeparator(domainSeparator), ignoreTrailingDot(ignoreTrailingDot), disabled(false)
+		{
+			this->domains = NULL;
+			generateDomains(domains);
+		}
+		
+		~ActiveFilter() { delete domains; }
+	private:
+		/**
+		 * Separator character used in domainSource property, must be overridden by subclasses
+		 * @type String
+		 */
+		wchar_t domainSeparator;
+
+		/**
+		 * Determines whether the trailing dot in domain names isn't important and
+		 * should be ignored, must be overridden by subclasses.
+		 * @type Boolean
+		 */
+		bool ignoreTrailingDot;
+
+		bool disabled;
+
+		// number of domains are not many, using std::map suffices
+		std::map<std::wstring, bool>* domains;
+		void generateDomains(const std::wstring& domainSource);
+
+		static const std::map<std::wstring, bool> s_mEmpty;
+	};
+
+	/**
+	 * Abstract base class for RegExp-based filters
+	 * @augments ActiveFilter
+	 */
+	class RegExpFilter : public ActiveFilter {
+	public:
+		static const ContentType_T DEFAULT_CONTENT_TYPE = 0x7FFFFFFFul & ~(ELEMHIDE | DONOTTRACK | POPUP);
+		/*
+		 * @param {String} text see Filter()
+		 * @param {String} regexpSource filter part that the regular expression should be build from
+		 * @param {Number} contentType  (optional) Content types the filter applies to, combination of values from RegExpFilter.typeMap
+		 * @param {Boolean} matchCase   (optional) Defines whether the filter should distinguish between lower and upper case letters
+		 * @param {String} domains      (optional) Domains that the filter is restricted to, e.g. "foo.com|bar.com|~baz.com"
+		 * @param {Boolean} thirdParty  (optional) Defines whether the filter should apply to third-party or first-party content only
+		 * @constructor
+		 */
+		RegExpFilter(const std::wstring& text, const std::wstring& regexpSource,
+			ContentType_T contentType = DEFAULT_CONTENT_TYPE, bool matchCase = false, const std::wstring& domains = L"",
+			TriBool thirdParty = TriNull)
+			: ActiveFilter(text, domains, L'|', true), contentType(contentType), matchCase(matchCase), thirdParty(thirdParty)
+		{
+			if (regexpSource.length() >= 2 && regexpSource.front() == L'/'
+				&& regexpSource.back() == L'/')
+			{
+				// The filter is a regular expression - convert it directly
+				regexp = regexpSource;
+			}
+			else
+			{
+				generateRegExp(regexpSource);
+			}
+		}
+
+		ContentType_T getContentType() { return contentType; }
+		bool matches(const std::wstring& location, ContentType_T contentType, const std::wstring& docDomain, bool thirdParty) const;
+
+		virtual RegExpFilter* toRegExpFilter() { return this; }
+		virtual const RegExpFilter* toRegExpFilter() const { return this; }
+
+		static Filter* fromText(const std::wstring& text);
+		static const std::map<std::wstring, ContentType_T>&
+			getTypeMap() { return typeMap; }
+		static const std::map<ContentType_T, std::wstring>&
+			getReverseTypeMap() { return reverseTypeMap; }
+	private:
+		re::RegExp regexp;
+		void generateRegExp(const std::wstring& regexpSource);
+
+		ContentType_T contentType;
+		// 3-value boolean, null: no restriction; false: first-party only; true: third-party only
+		TriBool thirdParty;
+		bool matchCase;
+
+		static std::map<std::wstring, ContentType_T> typeMap;
+		static std::map<ContentType_T, std::wstring> reverseTypeMap;
+		class TypeMapInitializer;
+		friend class TypeMapInitializer;
+		class TypeMapInitializer {
+		public:
+			TypeMapInitializer();
+		};
+		static TypeMapInitializer typeMapInit;
+	};
+
+	/**
+	 * Class for blocking filters
+	 * @augments RegExpFilter
+	 */
+	class BlockingFilter : public RegExpFilter {
+	public:
+		/*
+		 * @param {String} text see Filter()
+		 * @param {String} regexpSource see RegExpFilter()
+		 * @param {Number} contentType see RegExpFilter()
+		 * @param {Boolean} matchCase see RegExpFilter()
+		 * @param {String} domains see RegExpFilter()
+		 * @param {Boolean} thirdParty see RegExpFilter()
+		 * @param {Boolean} collapse  defines whether the filter should collapse blocked content, can be null
+		 * @constructor
+		 */
+		BlockingFilter(const std::wstring& text, const std::wstring& regexpSource,
+			ContentType_T contentType = DEFAULT_CONTENT_TYPE, bool matchCase = false, const std::wstring& domains = L"",
+			TriBool thirdParty = TriNull, TriBool collapse = TriNull)
+			: RegExpFilter(text, regexpSource, contentType, matchCase, domains, thirdParty),
+			  collapse(collapse) {}
+	private:
+		TriBool collapse;
+	};
+
+	/**
+	 * Class for whitelist filters
+	 * @augments RegExpFilter
+	 */
+	class WhitelistFilter : public RegExpFilter {
+	public:
+		/*
+		 * @param {String} text see Filter()
+		 * @param {String} regexpSource see RegExpFilter()
+		 * @param {Number} contentType see RegExpFilter()
+		 * @param {Boolean} matchCase see RegExpFilter()
+		 * @param {String} domains see RegExpFilter()
+		 * @param {Boolean} thirdParty see RegExpFilter()
+		 * @param {String[]} siteKeys public keys of websites that this filter should apply to
+		 * @constructor
+		 */
+		WhitelistFilter(const std::wstring& text, const std::wstring& regexpSource,
+			ContentType_T contentType = DEFAULT_CONTENT_TYPE, bool matchCase = false, const std::wstring& domains = L"",
+			TriBool thirdParty = TriNull, std::vector<std::wstring>&& siteKeys = std::vector<std::wstring>())
+			: RegExpFilter(text, regexpSource, contentType, matchCase, domains, thirdParty)
+		{
+			if (siteKeys.size())
+				this->siteKeys = new std::vector<std::wstring>(std::move(siteKeys));
+			else this->siteKeys = NULL;
+		}
+
+		~WhitelistFilter() { delete siteKeys; }
+
+		const std::vector<std::wstring>& getSiteKeys() { return siteKeys ? *siteKeys : s_vEmpty; }
+
+		virtual bool isException() const { return true; }
+	private:
+		std::vector<std::wstring>* siteKeys;
+
+		static const std::vector<std::wstring> s_vEmpty;
+	};
+
+	/**
+	 * Base class for element hiding filters
+	 * @augments ActiveFilter
+	 */
+	class ElemHideBase : public ActiveFilter {
+	public:
+		/*
+		 * @param {String} text see Filter()
+		 * @param {String} domains    (optional) Host names or domains the filter should be restricted to
+		 * @param {String} selector   CSS selector for the HTML elements that should be hidden
+		 * @constructor
+		 */
+		ElemHideBase(const std::wstring& text, const std::wstring& domains, const std::wstring& selector);
+
+		const std::wstring& getSelector() const { return selector; }
+		const std::wstring& getSelectorDomain() const { return selectorDomain; }
+
+		static Filter* fromText(const std::wstring& text, const std::wstring& domain, bool isException,
+								const std::wstring& tagName, const std::wstring& attrRules,
+								const std::wstring& selector);
+	private:
+		std::wstring selectorDomain;
+		std::wstring selector;
+	};
+
+	/**
+	 * Class for element hiding filters
+	 * really don't need RTTI here, so I'm combining the exception class with regular one
+	 * @augments ElemHideBase
+	 */
+	class ElemHideFilter : public ElemHideBase {
+	public:
+		/*
+		 * @param {String} text see Filter()
+		 * @param {String} domains  see ElemHideBase()
+		 * @param {String} selector see ElemHideBase()
+		 * @constructor
+		 */
+		ElemHideFilter(const std::wstring& text, const std::wstring& domains,
+			const std::wstring& selector, bool isException)
+			: ElemHideBase(text, domains, selector), exception(isException) {}
+
+		virtual bool isException() const { return exception; };
+
+		virtual ElemHideFilter* toElemHideFilter() { return this; }
+		virtual const ElemHideFilter* toElemHideFilter() const { return this; }
+	private:
+		bool exception;
+	};
+
+} // namespace abp
diff --git a/plugin/abp/FilterContentType.h b/plugin/abp/FilterContentType.h
new file mode 100644
index 0000000..39afd0c
--- /dev/null
+++ b/plugin/abp/FilterContentType.h
@@ -0,0 +1,50 @@
+/*
+This file is part of Fire-IE.
+
+Fire-IE is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Fire-IE is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Fire-IE.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// FilterContentType.h : content types in abp module
+//
+
+namespace abp {
+	typedef unsigned long ContentType_T;
+	enum ContentType : ContentType_T {
+		OTHER = 1,
+		SCRIPT = 2,
+		IMAGE = 4,
+		STYLESHEET = 8,
+		OBJECT = 16,
+		SUBDOCUMENT = 32,
+		DOCUMENT = 64,
+		XBL = 1,
+		PING = 1,
+		XMLHTTPREQUEST = 2048,
+		OBJECT_SUBREQUEST = 4096,
+		DTD = 1,
+		MEDIA = 16384,
+		FONT = 32768,
+
+		BACKGROUND = 4,    // Backwards compat, same as IMAGE
+
+		POPUP = 0x10000000,
+		DONOTTRACK = 0x20000000,
+		ELEMHIDE = 0x40000000,
+
+		/* we do not support identifying XBL, PING, XMLHTTPREQUEST and so on.. thus put them here with OTHER */
+		UNKNOWN_OTHER = OTHER | XBL | PING | XMLHTTPREQUEST | OBJECT_SUBREQUEST | DTD
+	};
+}
diff --git a/plugin/abp/Matcher.cpp b/plugin/abp/Matcher.cpp
new file mode 100644
index 0000000..3a0f5b3
--- /dev/null
+++ b/plugin/abp/Matcher.cpp
@@ -0,0 +1,415 @@
+/*
+This file is part of Fire-IE.
+
+Fire-IE is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Fire-IE is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Fire-IE.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+// Matcher.cpp : ABP filter matching engine implementation
+//
+
+#include "StdAfx.h"
+
+#include "FilterClasses.h"
+#include "Matcher.h"
+#include "re/strutils.h"
+
+using namespace abp;
+using namespace re;
+using namespace re::strutils;
+using namespace std;
+
+static const wstring strEmpty = L"";
+
+/**
+ * Adds a filter to the matcher
+ */
+void Matcher::add(RegExpFilter* filter)
+{
+	if (keywordByFilter.find(filter) != keywordByFilter.end())
+		return;
+
+	// Look for a suitable keyword
+	wstring keyword = findKeyword(filter);
+	FList& flist = filterByKeyword[keyword];
+	flist.push_back(filter);
+
+	keywordByFilter[filter] = keyword;
+}
+
+/**
+ * Removes a filter from the matcher
+ */
+void Matcher::remove(RegExpFilter* filter)
+{
+	auto iter = keywordByFilter.find(filter);
+	if (iter == keywordByFilter.end()) return;
+
+	wstring keyword = iter->second;
+	FList& flist = filterByKeyword[keyword];
+	flist.remove(filter);
+	if (flist.size() == 0)
+		filterByKeyword.erase(keyword);
+
+	keywordByFilter.erase(iter);
+}
+
+namespace abp { namespace funcStatic { namespace Matcher_findKeyword {
+	// pre-compiled to speed up the process
+	static const RegExp re1 = L"/[^a-z0-9%*][a-z0-9%]{3,}(?=[^a-z0-9%*])/g";
+
+	static const wstring strDoNotTrack = L"donottrack";
+	static const wstring strAtAt = L"@@";
+} } } // namespace abp::funcStatic::Matcher_findKeyword
+
+/**
+ * Chooses a keyword to be associated with the filter
+ */
+wstring Matcher::findKeyword(RegExpFilter* filter) const
+{
+	using namespace funcStatic::Matcher_findKeyword;
+
+	// For donottrack filters use "donottrack" as keyword if nothing else matches
+	wstring defaultResult = (filter->getContentType() & DONOTTRACK) ? strDoNotTrack : strEmpty;
+
+	wstring text = filter->getText();
+	if (Filter::regexpRegExp.test(text))
+		return defaultResult;
+
+	// Remove options
+	RegExpMatch* match = Filter::optionsRegExp.exec(text);
+	if (match)
+	{
+		text = match->input.substr(0, match->index);
+		delete match;
+	}
+
+	// Remove whitelist marker
+	if (startsWith(text, strAtAt))
+		text = text.substr(2);
+
+	RegExpMatch* candidateMatch = strutils::match(toLowerCase(text), re1);
+	if (!candidateMatch)
+		return defaultResult;
+
+	const std::vector<wstring>& candidates = candidateMatch->substrings;
+	const unordered_map<wstring, FList>& hash = filterByKeyword;
+	wstring result = defaultResult;
+	int resultCount = 0xFFFFFF;
+	int resultLength = 0;
+	for (size_t i = 0; i < candidates.size(); i++)
+	{
+		wstring candidate = candidates[i].substr(1);
+		auto iter = hash.find(candidate);
+		int count = (iter != hash.end()) ? (int)iter->second.size() : 0;
+		if (count < resultCount || (count == resultCount && (int)candidate.length() > resultLength))
+		{
+			result = candidate;
+			resultCount = count;
+			resultLength = (int)candidate.length();
+		}
+	}
+	delete candidateMatch;
+
+	return result;
+}
+
+/**
+ * Checks whether a particular filter is being matched against.
+ */
+bool Matcher::hasFilter(RegExpFilter* filter) const
+{
+	return keywordByFilter.find(filter) != keywordByFilter.end();
+}
+
+
+/**
+ * Returns the keyword used for a filter, null for unknown filters.
+ */
+wstring Matcher::getKeywordForFilter(RegExpFilter* filter) const
+{
+	auto iter = keywordByFilter.find(filter);
+	if (iter != keywordByFilter.end())
+		return iter->second;
+	return strEmpty;
+}
+
+/**
+ * Checks whether the entries for a particular keyword match a URL
+ */
+RegExpFilter* Matcher::checkEntryMatch(const wstring& keyword, const wstring& location,
+	ContentType_T contentType, const wstring& docDomain, bool thirdParty) const
+{
+	auto iter = filterByKeyword.find(keyword);
+	if (iter == filterByKeyword.end()) return NULL;
+
+	const FList& flist = iter->second;
+	for (unsigned int i = 0; i < flist.size(); i++)
+	{
+		RegExpFilter* filter = flist[i];
+		if (filter->matches(location, contentType, docDomain, thirdParty))
+			return filter;
+	}
+	return NULL;
+}
+
+namespace abp { namespace funcStatic { namespace Matcher_matchesAny {
+	// pre-compiled to speed up the process
+	static const RegExp re1 = L"/[a-z0-9%]{3,}/g";
+
+	static const wstring strDoNotTrack = L"donottrack";
+} } } // namespace abp::funcStatic::Matcher_matchesAny
+
+/**
+ * Tests whether the URL matches any of the known filters
+ */
+RegExpFilter* Matcher::matchesAny(const wstring& location, ContentType_T contentType,
+	const wstring& docDomain, bool thirdParty) const
+{
+	using namespace funcStatic::Matcher_matchesAny;
+
+	RegExpMatch* candidateMatch = match(toLowerCase(location), re1);
+	vector<wstring> candidates;
+	if (candidateMatch) candidates = std::move(candidateMatch->substrings);
+	delete candidateMatch;
+
+	RegExpFilter* res = NULL;
+	if (contentType & DONOTTRACK)
+	{
+		res = checkEntryMatch(strDoNotTrack, location, contentType, docDomain, thirdParty);
+		if (res) return res;
+	}
+	for (size_t i = 0; i < candidates.size(); i++)
+	{
+		res = checkEntryMatch(candidates[i], location, contentType, docDomain, thirdParty);
+		if (res) return res;
+	}
+	if ((contentType & DONOTTRACK) == 0)
+	{
+		res = checkEntryMatch(strEmpty, location, contentType, docDomain, thirdParty);
+	}
+	return res;
+}
+
+const size_t CombinedMatcher::maxCacheEntries = 10000;
+
+bool CombinedMatcher::queryResultCache(const wstring& key, RegExpFilter*& result) const
+{
+	Lock lock(mtCache);
+	auto iter = resultCache.find(key);
+	if (iter == resultCache.end()) return false;
+	result = iter->second;
+	return true;
+}
+
+void CombinedMatcher::putResultCache(const wstring& key, RegExpFilter* result)
+{
+	Lock lock(mtCache);
+	if (cacheEntries >= maxCacheEntries)
+		resultCache.clear();
+	resultCache[key] = result;
+	cacheEntries = resultCache.size();
+}
+
+void CombinedMatcher::clear()
+{
+	blacklist.clear();
+	whitelist.clear();
+	keys.clear();
+	resultCache.clear();
+	cacheEntries = 0;
+}
+
+void CombinedMatcher::add(RegExpFilter* filter)
+{
+	if (!filter) return;
+	if (filter->isException())
+	{
+		// can safely cast to WhitelistFilter
+		WhitelistFilter* wf = static_cast<WhitelistFilter*>(filter);
+		const vector<wstring>& siteKeys = wf->getSiteKeys();
+		if (siteKeys.size())
+		{
+			for (size_t i = 0; i < siteKeys.size(); i++)
+			{
+				keys[siteKeys[i]] = filter->getText();
+			}
+		}
+		else
+			whitelist.add(filter);
+	}
+	else
+		blacklist.add(filter);
+
+	if (cacheEntries > 0)
+	{
+		resultCache.clear();
+		cacheEntries = 0;
+	}
+}
+
+void CombinedMatcher::remove(RegExpFilter* filter)
+{
+	if (filter->isException())
+	{
+		// can safely cast to WhitelistFilter
+		WhitelistFilter* wf = static_cast<WhitelistFilter*>(filter);
+		const vector<wstring>& siteKeys = wf->getSiteKeys();
+		if (siteKeys.size())
+		{
+			for (size_t i = 0; i < siteKeys.size(); i++)
+			{
+				keys.erase(siteKeys[i]);
+			}
+		}
+		else
+			whitelist.remove(filter);
+	}
+	else
+		blacklist.remove(filter);
+
+	if (cacheEntries > 0)
+	{
+		resultCache.clear();
+		cacheEntries = 0;
+	}
+}
+
+wstring CombinedMatcher::findKeyword(RegExpFilter* filter) const
+{
+	if (filter->isException())
+		return whitelist.findKeyword(filter);
+	else
+		return blacklist.findKeyword(filter);
+}
+
+bool CombinedMatcher::hasFilter(RegExpFilter* filter) const
+{
+	if (filter->isException())
+		return whitelist.hasFilter(filter);
+	else
+		return blacklist.hasFilter(filter);
+}
+
+wstring CombinedMatcher::getKeywordForFilter(RegExpFilter* filter) const
+{
+	if (filter->isException())
+		return whitelist.getKeywordForFilter(filter);
+	else
+		return blacklist.getKeywordForFilter(filter);
+}
+
+RegExpFilter* CombinedMatcher::checkCandidateInternal(const wstring& keyword, const wstring& location,
+	ContentType_T contentType, const wstring& docDomain, bool thirdParty,
+	RegExpFilter*& blacklistHit) const
+{
+	RegExpFilter* whitelistHit = whitelist.checkEntryMatch(keyword, location, contentType,
+		docDomain, thirdParty);
+	if (whitelistHit) return whitelistHit;
+
+	if (!blacklistHit)
+		blacklistHit = blacklist.checkEntryMatch(keyword, location, contentType, docDomain, thirdParty);
+	return NULL;
+}
+
+namespace abp { namespace funcStatic { namespace CombinedMatcher_matchesAnyInternal {
+	// pre-compiled to speed up the process
+	static const RegExp re1 = L"/[a-z0-9%]{3,}/g";
+
+	static const wstring strDoNotTrack = L"donottrack";
+} } } // namespace abp::funcStatic::CombinedMatcher_matchesAnyInternal
+
+/**
+ * Optimized filter matching testing both whitelist and blacklist matchers
+ * simultaneously. For parameters see Matcher.matchesAny().
+ */
+RegExpFilter* CombinedMatcher::matchesAnyInternal(const wstring& location, ContentType_T contentType,
+	const wstring& docDomain, bool thirdParty) const
+{
+	using namespace funcStatic::CombinedMatcher_matchesAnyInternal;
+
+	RegExpMatch* candidateMatch = match(toLowerCase(location), re1);
+	vector<wstring> candidates;
+	if (candidateMatch) candidates = std::move(candidateMatch->substrings);
+	delete candidateMatch;
+
+	RegExpFilter* blacklistHit = NULL;
+	RegExpFilter* result = NULL;
+	if (contentType & DONOTTRACK)
+	{
+		result = checkCandidateInternal(strDoNotTrack, location, contentType,
+			docDomain, thirdParty, blacklistHit);
+		if (result) return result;
+	}
+	for (size_t i = 0; i < candidates.size(); i++)
+	{
+		result = checkCandidateInternal(candidates[i], location, contentType,
+			docDomain, thirdParty, blacklistHit);
+		if (result) return result;
+	}
+	if ((contentType & DONOTTRACK) == 0)
+	{
+		result = checkCandidateInternal(strEmpty, location, contentType,
+			docDomain, thirdParty, blacklistHit);
+		if (result) return result;
+	}
+	return blacklistHit;
+}
+
+RegExpFilter* CombinedMatcher::matchesAny(const wstring& location, ContentType_T contentType,
+	const wstring& docDomain, bool thirdParty)
+{
+	wstring key = location;
+	key.push_back(L' ');
+	key.append(RegExpFilter::getReverseTypeMap().at(contentType));
+	key.push_back(L' ');
+	key.append(docDomain);
+	key.push_back(L' ');
+	key.append(thirdParty ? L"true" : L"false");
+
+	RegExpFilter* result;
+	if (queryResultCache(key, result)) return result;
+#ifdef MATCHER_PERF
+	DWORD startTick = GetTickCount();
+#endif
+
+	result = matchesAnyInternal(location, contentType, docDomain, thirdParty);
+
+#ifdef MATCHER_PERF
+	// we only need the correct value at the end of the program,
+	// so no locking is needed
+	InterlockedExchangeAdd(&matchTicks, GetTickCount() - startTick);
+	InterlockedIncrement(&matchCount);
+	InterlockedExchangeAdd(&matchURLLen, (unsigned int)location.length());
+#endif
+	
+	putResultCache(key, result);
+	return result;
+}
+
+RegExpFilter* CombinedMatcher::matchesByKey(const wstring& location, const wstring& key,
+	const wstring& docDomain) const
+{
+	wstring ukey = toUpperCase(key);
+	auto iter = keys.find(ukey);
+	if (iter != keys.end())
+	{
+		const unordered_map<wstring, Filter*>& knownFilters = Filter::getKnownFilters();
+		auto iterKnownFilter = knownFilters.find(iter->second);
+		if (iterKnownFilter != knownFilters.end())
+		{
+			return iterKnownFilter->second->toRegExpFilter();
+		}
+	}
+	return NULL;
+}
diff --git a/plugin/abp/Matcher.h b/plugin/abp/Matcher.h
new file mode 100644
index 0000000..96bb86c
--- /dev/null
+++ b/plugin/abp/Matcher.h
@@ -0,0 +1,129 @@
+/*
+This file is part of Fire-IE.
+
+Fire-IE is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Fire-IE is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Fire-IE.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// Matcher.h : ABP filter matching engine
+//
+
+#include <string>
+#include <unordered_map>
+#include <vector>
+#include "FilterClasses.h"
+#include "TList.h"
+#include "RAIILock.h"
+
+// enable performance monitoring
+//#define MATCHER_PERF
+
+namespace abp {
+	/**
+	 * Blacklist/whitelist filter matching
+	 */
+	class Matcher {
+	public:
+		Matcher() { clear(); }
+
+		void clear() { filterByKeyword.clear(); keywordByFilter.clear(); }
+		void add(RegExpFilter* filter);
+		void remove(RegExpFilter* filter);
+		std::wstring findKeyword(RegExpFilter* filter) const;
+		bool hasFilter(RegExpFilter* filter) const;
+		std::wstring getKeywordForFilter(RegExpFilter* filter) const;
+
+		RegExpFilter* checkEntryMatch(const std::wstring& keyword, const std::wstring& location,
+			ContentType_T contentType, const std::wstring& docDomain, bool thirdParty) const;
+		RegExpFilter* matchesAny(const std::wstring& location, ContentType_T contentType,
+			const std::wstring& docDomain, bool thirdParty) const;
+
+		int getNumberOfFilters() const { return (int)keywordByFilter.size(); }
+	private:
+		typedef TList<RegExpFilter*> FList;
+		std::unordered_map<std::wstring, FList> filterByKeyword;
+		std::unordered_map<RegExpFilter*, std::wstring, Filter::Hasher, Filter::EqualTo> keywordByFilter;
+	};
+
+
+	/**
+	 * Combines a matcher for blocking and exception rules, automatically sorts
+	 * rules into two Matcher instances.
+	 */
+	class CombinedMatcher {
+	public:
+		CombinedMatcher()
+		{
+			cacheEntries = 0;
+#ifdef MATCHER_PERF
+			matchTicks = 0;
+			matchURLLen = 0;
+			matchCount = 0;
+#endif
+		}
+
+#ifdef MATCHER_PERF
+		void showPerfInfo()
+		{
+			CString msg;
+			msg.Format(_T("Match Count: %d\nAverage Time: %.6fms\nAverage Len: %.1f\n"), matchCount, (double)matchTicks / max(matchCount, 1), (double)matchURLLen / max(matchCount, 1));
+			MessageBox(NULL, msg, _T("Matcher Performance"), MB_OK);
+		}
+#endif
+
+		void clear();
+		void add(RegExpFilter* filter);
+		void remove(RegExpFilter* filter);
+		std::wstring findKeyword(RegExpFilter* filter) const;
+		bool hasFilter(RegExpFilter* filter) const;
+		std::wstring getKeywordForFilter(RegExpFilter* filter) const;
+
+		RegExpFilter* matchesAny(const std::wstring& location, ContentType_T contentType,
+			const std::wstring& docDomain, bool thirdParty);
+		RegExpFilter* matchesByKey(const std::wstring& location, const std::wstring& key,
+			const std::wstring& docDomain) const;
+
+		int getNumberOfFilters() const { return blacklist.getNumberOfFilters() + whitelist.getNumberOfFilters(); }
+	private:
+		Matcher blacklist;
+		Matcher whitelist;
+
+		std::unordered_map<std::wstring, std::wstring> keys;
+		
+		// Result cache is worth implementing dispite the fact that it's not naturally thread-safe.
+		// In most cases, result cache is accessed only twice for each URL, thus overhead should be minimal.
+		// TODO: implement result cache with minimal locking overhead
+		std::unordered_map<std::wstring, RegExpFilter*> resultCache;
+		size_t cacheEntries;
+		Mutex mtCache;
+
+		bool queryResultCache(const std::wstring& key, RegExpFilter*& result) const;
+		void putResultCache(const std::wstring& key, RegExpFilter* result);
+
+		RegExpFilter* checkCandidateInternal(const std::wstring& keyword, const std::wstring& location,
+			ContentType_T contentType, const std::wstring& docDomain, bool thirdParty,
+			RegExpFilter*& blacklistHit) const;
+		RegExpFilter* matchesAnyInternal(const std::wstring& location, ContentType_T contentType,
+			const std::wstring& docDomain, bool thirdParty) const;
+
+		static const size_t maxCacheEntries;
+#ifdef MATCHER_PERF
+		// For performance monitoring
+		volatile unsigned int matchTicks;
+		volatile unsigned int matchURLLen;
+		volatile unsigned int matchCount;
+#endif
+	};
+} // namespace abp
diff --git a/plugin/abp/RAIILock.cpp b/plugin/abp/RAIILock.cpp
new file mode 100644
index 0000000..bf51a2e
--- /dev/null
+++ b/plugin/abp/RAIILock.cpp
@@ -0,0 +1,184 @@
+/*
+This file is part of Fire-IE.
+
+Fire-IE is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Fire-IE is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Fire-IE.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+// RAIILock.cpp : RAII lock, mutex and condition mechanism implementation
+//
+
+#include "StdAfx.h"
+
+#include "RAIILock.h"
+#include <deque>
+
+using namespace abp;
+
+Mutex::Mutex()
+{
+	m_pcs = new CRITICAL_SECTION;
+	InitializeCriticalSectionAndSpinCount(m_pcs, 4096);
+}
+
+Mutex::~Mutex()
+{
+	DeleteCriticalSection(m_pcs);
+	delete m_pcs;
+}
+
+void Mutex::lock() const
+{
+	EnterCriticalSection(m_pcs);
+}
+
+void Mutex::unlock() const
+{
+	LeaveCriticalSection(m_pcs);
+}
+
+namespace abp {
+	class Monitor {
+	public:
+		Monitor() {}
+		~Monitor() { ASSERT(m_deqWaitSet.empty()); }
+
+		void wait(CRITICAL_SECTION* pcs);
+		void notify();
+		void notifyAll();
+	private:
+		Monitor(Monitor const&);
+		Monitor& operator=(Monitor const&);
+
+		HANDLE push();
+		HANDLE pop();
+
+		std::deque<HANDLE> m_deqWaitSet;
+	};
+}
+
+void Monitor::wait(CRITICAL_SECTION* pcs)
+{
+	HANDLE hWaitEvent = push();
+	LeaveCriticalSection(pcs);
+
+	// NOTE: Conceptually, releasing the lock and entering the wait
+	// state is done in one atomic step. Technically, that is not
+	// true here, because we first leave the critical section and
+	// then, in a separate line of code, call WaitForSingleObjectEx.
+	// The reason why this code is correct is that our thread is placed
+	// in the wait set *before* the lock is released. Therefore, if
+	// we get preempted right here and another thread notifies us, then
+	// that notification will *not* be missed: the wait operation below
+	// will find the event signalled.
+	DWORD dwWaitResult = WaitForSingleObjectEx(hWaitEvent, INFINITE, false);
+	EnterCriticalSection(pcs);
+	CloseHandle(hWaitEvent);
+}
+
+void Monitor::notify()
+{
+	HANDLE hWaitEvent = pop();
+	if (!hWaitEvent) return;
+	SetEvent(hWaitEvent);
+}
+
+void Monitor::notifyAll()
+{
+	for(auto iter = m_deqWaitSet.begin(); iter != m_deqWaitSet.end(); ++iter)
+	{
+		if (*iter) SetEvent(*iter);
+	}
+	m_deqWaitSet.clear();
+}
+
+HANDLE Monitor::push()
+{
+	HANDLE hWaitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
+	m_deqWaitSet.push_back(hWaitEvent);
+	return hWaitEvent;
+}
+
+HANDLE Monitor::pop()
+{
+	if (m_deqWaitSet.empty()) return NULL;
+	HANDLE hWaitEvent = m_deqWaitSet.front();
+	m_deqWaitSet.pop_front();
+	return hWaitEvent;
+}
+
+ReaderWriterMutex::ReaderWriterMutex()
+{
+	m_nReaderCount = 0;
+
+	m_pcs = new CRITICAL_SECTION;
+	InitializeCriticalSectionAndSpinCount(m_pcs, 4096);
+
+#ifdef NT6_CONDITION
+	m_pcv = new CONDITION_VARIABLE;
+	InitializeConditionVariable(m_pcv);
+#else
+	m_pMonitor = new Monitor();
+#endif
+}
+
+ReaderWriterMutex::~ReaderWriterMutex()
+{
+#ifdef NT6_CONDITION
+	delete m_pcv;
+#else
+	delete m_pMonitor;
+#endif
+	DeleteCriticalSection(m_pcs);
+	delete m_pcs;
+}
+
+void ReaderWriterMutex::lockReader() const
+{
+	EnterCriticalSection(m_pcs);
+	m_nReaderCount++;
+	LeaveCriticalSection(m_pcs);
+}
+
+void ReaderWriterMutex::unlockReader() const
+{
+	EnterCriticalSection(m_pcs);
+	m_nReaderCount--;
+	if (m_nReaderCount == 0)
+	{
+#ifdef NT6_CONDITION
+		WakeAllConditionVariable(m_pcv);
+#else
+		m_pMonitor->notifyAll();
+#endif
+	}
+	LeaveCriticalSection(m_pcs);
+}
+
+void ReaderWriterMutex::lockWriter() const
+{
+	EnterCriticalSection(m_pcs);
+	while (m_nReaderCount)
+	{
+#ifdef NT6_CONDITION
+		SleepConditionVariableCS(m_pcv, m_pcs, INFINITE);
+#else
+		m_pMonitor->wait(m_pcs);
+#endif
+	}
+}
+
+void ReaderWriterMutex::unlockWriter() const
+{
+	LeaveCriticalSection(m_pcs);
+}
diff --git a/plugin/abp/RAIILock.h b/plugin/abp/RAIILock.h
new file mode 100644
index 0000000..c7e5efb
--- /dev/null
+++ b/plugin/abp/RAIILock.h
@@ -0,0 +1,95 @@
+/*
+This file is part of Fire-IE.
+
+Fire-IE is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Fire-IE is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Fire-IE.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// RAIILock.h : RAII lock, mutex and condition mechanism
+//
+
+namespace abp
+{
+	class Lock;
+	class Mutex
+	{
+	public:
+		Mutex();
+		~Mutex();
+	private:
+		Mutex(const Mutex&);
+		Mutex& operator=(const Mutex&);
+		void lock() const;
+		void unlock() const;
+		friend class Lock;
+		CRITICAL_SECTION* m_pcs;
+	};
+
+	class ReaderLock;
+	class WriterLock;
+	class Monitor;
+	class ReaderWriterMutex {
+	public:
+		ReaderWriterMutex();
+		~ReaderWriterMutex();
+	private:
+		ReaderWriterMutex(const ReaderWriterMutex&);
+		ReaderWriterMutex& operator=(const ReaderWriterMutex&);
+		void lockReader() const;
+		void unlockReader() const;
+		void lockWriter() const;
+		void unlockWriter() const;
+		friend class ReaderLock;
+		friend class WriterLock;
+
+		CRITICAL_SECTION* m_pcs;
+#ifdef NT6_CONDITION
+		CONDITION_VARIABLE* m_pcv;
+#else
+		Monitor* m_pMonitor;
+#endif
+		mutable unsigned int m_nReaderCount;
+	};
+
+	class Lock {
+	public:
+		Lock(const Mutex& mutex) : mutex(mutex) { mutex.lock(); }
+		~Lock() { mutex.unlock(); }
+	private:
+		Lock(const Lock&);
+		Lock& operator=(const Lock&);
+		const Mutex& mutex;
+	};
+
+	class ReaderLock {
+	public:
+		ReaderLock(const ReaderWriterMutex& mutex) : mutex(mutex) { mutex.lockReader(); }
+		~ReaderLock() { mutex.unlockReader(); }
+	private:
+		ReaderLock(const ReaderLock&);
+		ReaderLock& operator=(const ReaderLock&);
+		const ReaderWriterMutex& mutex;
+	};
+
+	class WriterLock {
+	public:
+		WriterLock(const ReaderWriterMutex& mutex) : mutex(mutex) { mutex.lockWriter(); }
+		~WriterLock() { mutex.unlockWriter(); }
+	private:
+		WriterLock(const WriterLock&);
+		WriterLock& operator=(const WriterLock&);
+		const ReaderWriterMutex& mutex;
+	};
+} // namespace abp;
diff --git a/plugin/abp/TList.h b/plugin/abp/TList.h
new file mode 100644
index 0000000..21dbbdf
--- /dev/null
+++ b/plugin/abp/TList.h
@@ -0,0 +1,142 @@
+/*
+This file is part of Fire-IE.
+
+Fire-IE is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Fire-IE is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Fire-IE.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// TList.h : optimized for one-item lists
+// Warning: Do not use this for complex types.
+//          It is designed merely for primitive types (including pointers).
+//
+
+#include <vector>
+#include <algorithm>
+
+namespace abp {
+
+	template<class T>
+		class TList {
+		public:
+			TList() : count(0) { } 
+			explicit TList(const T& t) : t(t), count(1) { }
+			explicit TList(T&& t) : t(std::move(t)), count(1) { }
+			TList(const std::vector<T>& ts)
+			{
+				count = (unsigned int)ts.size();
+				if (count > 1) pts = new std::vector<T>(ts);
+				else if (count) t = ts[0];
+			}
+			TList(std::vector<T>&& ts)
+			{
+				count = (unsigned int)ts.size();
+				if (count > 1) pts = new std::vector<T>(std::move(ts));
+				else if (count) t = std::move(ts[0]);
+			}
+			TList(const TList& tl)
+			{
+				count = tl.count;
+				if (count > 1) pts = new std::vector<T>(*tl.pts);
+				else if (count) t = tl.t;
+			}
+			TList(TList&& tl)
+			{
+				count = tl.count;
+				if (count > 1) pts = tl.pts;
+				else if (count) t = tl.t;
+				tl.count = 0;
+				tl.pts = NULL;
+			}
+			TList& operator=(const std::vector<T>& ts)
+			{
+				return *this = TList(ts);
+			}
+			TList& operator=(std::vector<T>&& ts)
+			{
+				return *this = TList(std::move(ts));
+			}
+			TList& operator=(const TList& tl)
+			{
+				if (this == &tl) return *this;
+				if (count > 1) delete pts;
+				count = tl.count;
+				if (count > 1) pts = new std::vector<T>(*tl.pts);
+				else if (count) t = tl.t;
+				return *this;
+			}
+			TList& operator=(TList&& tl)
+			{
+				if (this == &tl) return *this;
+				if (count > 1) delete pts;
+				count = tl.count;
+				if (count > 1) pts = tl.pts;
+				else if (count) t = tl.t;
+				tl.count = 0;
+				tl.pts = NULL;
+				return *this;
+			}
+			unsigned int size() const { return count; }
+			const T& operator[] (unsigned int idx) const { return count > 1 ? (*pts)[idx] : t; }
+			T& operator[] (unsigned int idx) { return count > 1 ? (*pts)[idx] : t; }
+
+			void push_back(const T& t)
+			{
+				count++;
+				if (count == 1) this->t = t;
+				else if (count == 2)
+				{
+					std::vector<T>* pts = new std::vector<T>();
+					pts->push_back(std::move(this->t));
+					pts->push_back(t);
+					this->pts = pts;
+				}
+				else
+					this->pts->push_back(t);
+			}
+
+			void remove(const T& t)
+			{
+				if (count == 1)
+				{
+					if (this->t == t)
+					{
+						this->t = T();
+						count = 0;
+					}
+				}
+				else if (count > 1)
+				{
+					auto iter = std::find(pts->begin(), pts->end(), t);
+					if (iter != pts->end())
+					{
+						pts->erase(iter);
+						if (--count == 1)
+						{
+							T tmpt = std::move((*pts)[0]);
+							delete pts;
+							this->t = std::move(tmpt);
+						}
+					}
+				}
+			}
+			~TList() { if (count > 1) delete pts; }
+		private:
+			unsigned int count;
+			union {
+				T t;
+				std::vector<T>* pts;
+			};
+		};
+} // namespace abp
diff --git a/plugin/abp/TriBool.h b/plugin/abp/TriBool.h
new file mode 100644
index 0000000..10e63e8
--- /dev/null
+++ b/plugin/abp/TriBool.h
@@ -0,0 +1,27 @@
+/*
+This file is part of Fire-IE.
+
+Fire-IE is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Fire-IE is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Fire-IE.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// TriBool.h : Booleans that have a third meaning
+//
+
+namespace abp {
+	enum TriBool : int {
+		TriNull = 0, TriFalse = -1, TriTrue = 1
+	};
+}
diff --git a/plugin/jscre/ASCIICType.h b/plugin/jscre/ASCIICType.h
new file mode 100644
index 0000000..b4497f3
--- /dev/null
+++ b/plugin/jscre/ASCIICType.h
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2007, 2008 Apple Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1.  Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer. 
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution. 
+ * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
+ *     its contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#pragma once
+
+// The behavior of many of the functions in the <ctype.h> header is dependent
+// on the current locale. But in the WebKit project, all uses of those functions
+// are in code processing something that's not locale-specific. These equivalents
+// for some of the <ctype.h> functions are named more explicitly, not dependent
+// on the C library locale, and we should also optimize them as needed.
+
+// All functions return false or leave the character unchanged if passed a character
+// that is outside the range 0-7F. So they can be used on Unicode strings or
+// characters if the intent is to do processing only if the character is ASCII.
+
+inline bool isASCIIAlpha(char c) { return (c | 0x20) >= 'a' && (c | 0x20) <= 'z'; }
+inline bool isASCIIAlpha(unsigned short c) { return (c | 0x20) >= 'a' && (c | 0x20) <= 'z'; }
+inline bool isASCIIAlpha(int c) { return (c | 0x20) >= 'a' && (c | 0x20) <= 'z'; }
+
+inline bool isASCIIAlphanumeric(char c) { return c >= '0' && c <= '9' || (c | 0x20) >= 'a' && (c | 0x20) <= 'z'; }
+inline bool isASCIIAlphanumeric(unsigned short c) { return c >= '0' && c <= '9' || (c | 0x20) >= 'a' && (c | 0x20) <= 'z'; }
+inline bool isASCIIAlphanumeric(int c) { return c >= '0' && c <= '9' || (c | 0x20) >= 'a' && (c | 0x20) <= 'z'; }
+
+inline bool isASCIIDigit(char c) { return (c >= '0') & (c <= '9'); }
+inline bool isASCIIDigit(unsigned short c) { return (c >= '0') & (c <= '9'); }
+inline bool isASCIIDigit(int c) { return (c >= '0') & (c <= '9'); }
+
+inline bool isASCIIHexDigit(char c) { return c >= '0' && c <= '9' || (c | 0x20) >= 'a' && (c | 0x20) <= 'f'; }
+inline bool isASCIIHexDigit(unsigned short c) { return c >= '0' && c <= '9' || (c | 0x20) >= 'a' && (c | 0x20) <= 'f'; }
+inline bool isASCIIHexDigit(int c) { return c >= '0' && c <= '9' || (c | 0x20) >= 'a' && (c | 0x20) <= 'f'; }
+
+inline bool isASCIILower(char c) { return c >= 'a' && c <= 'z'; }
+inline bool isASCIILower(unsigned short c) { return c >= 'a' && c <= 'z'; }
+inline bool isASCIILower(int c) { return c >= 'a' && c <= 'z'; }
+
+inline bool isASCIIUpper(char c) { return c >= 'A' && c <= 'Z'; }
+inline bool isASCIIUpper(unsigned short c) { return c >= 'A' && c <= 'Z'; }
+inline bool isASCIIUpper(int c) { return c >= 'A' && c <= 'Z'; }
+
+/*
+    Statistics from a run of Apple's page load test for callers of isASCIISpace:
+
+        character          count
+        ---------          -----
+        non-spaces         689383
+    20  space              294720
+    0A  \n                 89059
+    09  \t                 28320
+    0D  \r                 0
+    0C  \f                 0
+    0B  \v                 0
+*/
+inline bool isASCIISpace(char c) { return c <= ' ' && (c == ' ' || (c <= 0xD && c >= 0x9)); }
+inline bool isASCIISpace(unsigned short c) { return c <= ' ' && (c == ' ' || (c <= 0xD && c >= 0x9)); }
+inline bool isASCIISpace(int c) { return c <= ' ' && (c == ' ' || (c <= 0xD && c >= 0x9)); }
+
+inline char toASCIILower(char c) { return c | ((c >= 'A' && c <= 'Z') << 5); }
+inline unsigned short toASCIILower(unsigned short c) { return c | ((c >= 'A' && c <= 'Z') << 5); }
+inline int toASCIILower(int c) { return c | ((c >= 'A' && c <= 'Z') << 5); }
+
+inline char toASCIIUpper(char c) { return static_cast<char>(c & ~((c >= 'a' && c <= 'z') << 5)); }
+inline unsigned short toASCIIUpper(unsigned short c) { return static_cast<unsigned short>(c & ~((c >= 'a' && c <= 'z') << 5)); }
+inline int toASCIIUpper(int c) { return static_cast<int>(c & ~((c >= 'a' && c <= 'z') << 5)); }
+
+inline int toASCIIHexValue(char c) { ASSERT(isASCIIHexDigit(c)); return c < 'A' ? c - '0' : (c - 'A' + 10) & 0xF; }
+inline int toASCIIHexValue(unsigned short c) { ASSERT(isASCIIHexDigit(c)); return c < 'A' ? c - '0' : (c - 'A' + 10) & 0xF; }
+inline int toASCIIHexValue(int c) { ASSERT(isASCIIHexDigit(c)); return c < 'A' ? c - '0' : (c - 'A' + 10) & 0xF; }
diff --git a/plugin/jscre/AUTHORS b/plugin/jscre/AUTHORS
new file mode 100644
index 0000000..dbac2a5
--- /dev/null
+++ b/plugin/jscre/AUTHORS
@@ -0,0 +1,12 @@
+Originally written by:  Philip Hazel
+Email local part:       ph10
+Email domain:           cam.ac.uk
+
+University of Cambridge Computing Service,
+Cambridge, England. Phone: +44 1223 334714.
+
+Copyright (c) 1997-2005 University of Cambridge. All rights reserved.
+
+Adapted for JavaScriptCore and WebKit by Apple Inc.
+
+Copyright (c) 2005, 2006, 2007 Apple Inc. All rights reserved.
diff --git a/plugin/jscre/COPYING b/plugin/jscre/COPYING
new file mode 100644
index 0000000..6ffdc24
--- /dev/null
+++ b/plugin/jscre/COPYING
@@ -0,0 +1,35 @@
+PCRE is a library of functions to support regular expressions whose syntax
+and semantics are as close as possible to those of the Perl 5 language.
+
+This is JavaScriptCore's variant of the PCRE library. While this library
+started out as a copy of PCRE, many of the features of PCRE have been
+removed.
+
+Copyright (c) 1997-2005 University of Cambridge. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+    * Neither the name of the University of Cambridge nor the name of Apple
+      Inc. nor the names of their contributors may be used to endorse or
+      promote products derived from this software without specific prior
+      written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
diff --git a/plugin/jscre/JSRegExp.h b/plugin/jscre/JSRegExp.h
new file mode 100644
index 0000000..0a8b172
--- /dev/null
+++ b/plugin/jscre/JSRegExp.h
@@ -0,0 +1,74 @@
+/* This is the public header file for JavaScriptCore's variant of the PCRE
+library. While this library started out as a copy of PCRE, many of the
+features of PCRE have been removed. This library now supports only the
+regular expression features required by the JavaScript language
+specification, and has only the functions needed by JavaScriptCore and the
+rest of WebKit.
+
+           Copyright (c) 1997-2005 University of Cambridge
+    Copyright (C) 2002, 2004, 2006, 2007 Apple Inc. All rights reserved.
+
+-----------------------------------------------------------------------------
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+    * Neither the name of the University of Cambridge nor the names of its
+      contributors may be used to endorse or promote products derived from
+      this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+-----------------------------------------------------------------------------
+*/
+
+#pragma once
+
+#include "stdint.h"
+
+namespace jscre {
+
+typedef uint16_t UChar;
+
+struct JSRegExp;
+typedef struct JSRegExp JscreRegExp;
+
+enum JSRegExpIgnoreCaseOption { JSRegExpDoNotIgnoreCase, JSRegExpIgnoreCase };
+enum JSRegExpMultilineOption { JSRegExpSingleLine, JSRegExpMultiline };
+
+/* jsRegExpExecute error codes */
+const int JSRegExpErrorNoMatch = -1;
+const int JSRegExpErrorHitLimit = -2;
+const int JSRegExpErrorNoMemory = -3;
+const int JSRegExpErrorInternal = -4;
+
+typedef void* malloc_t(size_t size);
+typedef void free_t(void* address);
+
+JSRegExp* jsRegExpCompile(const UChar* pattern, int patternLength,
+    JSRegExpIgnoreCaseOption, JSRegExpMultilineOption,
+    unsigned* numSubpatterns, const char** errorMessage,
+    malloc_t* allocate_function, free_t* free_function);
+
+int jsRegExpExecute(const JSRegExp*,
+    const UChar* subject, int subjectLength, int startOffset,
+    int* offsetsVector, int offsetsVectorLength);
+
+void jsRegExpFree(JSRegExp*, free_t*);
+
+} // namespace jscre
diff --git a/plugin/jscre/JSRegExp_chartables.c b/plugin/jscre/JSRegExp_chartables.c
new file mode 100644
index 0000000..c5fe2c5
--- /dev/null
+++ b/plugin/jscre/JSRegExp_chartables.c
@@ -0,0 +1,96 @@
+/*************************************************
+*      Perl-Compatible Regular Expressions       *
+*************************************************/
+
+/* This file is automatically written by the dftables auxiliary 
+program. If you edit it by hand, you might like to edit the Makefile to 
+prevent its ever being regenerated.
+
+This file contains the default tables for characters with codes less than
+128 (ASCII characters). These tables are used when no external tables are
+passed to PCRE. */
+
+const unsigned char kjs_pcre_default_tables[480] = {
+
+/* This table is a lower casing table. */
+
+  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
+  0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 
+  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 
+  0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 
+  0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 
+  0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 
+  0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 
+  0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 
+  0x40, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 
+  0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 
+  0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 
+  0x78, 0x79, 0x7A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 
+  0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 
+  0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 
+  0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 
+  0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,
+
+/* This table is a case flipping table. */
+
+  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
+  0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 
+  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 
+  0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 
+  0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 
+  0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 
+  0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 
+  0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 
+  0x40, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 
+  0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 
+  0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 
+  0x78, 0x79, 0x7A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 
+  0x60, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 
+  0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 
+  0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 
+  0x58, 0x59, 0x5A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,
+
+/* This table contains bit maps for various character classes.
+Each map is 32 bytes long and the bits run from the least
+significant end of each byte. The classes are: space, digit, word. */
+
+  0x00, 0x3E, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03, 
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03, 
+  0xFE, 0xFF, 0xFF, 0x87, 0xFE, 0xFF, 0xFF, 0x07, 
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+
+/* This table identifies various classes of character by individual bits:
+  0x01   white space character
+  0x08   hexadecimal digit
+  0x10   alphanumeric or '_'
+*/
+
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /*   0-  7 */
+  0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,  /*   8- 15 */
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /*  16- 23 */
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /*  24- 31 */
+  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /*    - '  */
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /*  ( - /  */
+  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,  /*  0 - 7  */
+  0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /*  8 - ?  */
+  0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x10,  /*  @ - G  */
+  0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,  /*  H - O  */
+  0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,  /*  P - W  */
+  0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x10,  /*  X - _  */
+  0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x10,  /*  ` - g  */
+  0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,  /*  h - o  */
+  0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,  /*  p - w  */
+  0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00}; /*  x -127 */
+
+
+/* End of chartables.c */
diff --git a/plugin/jscre/JSRegExp_compile.cpp b/plugin/jscre/JSRegExp_compile.cpp
new file mode 100644
index 0000000..d5e636c
--- /dev/null
+++ b/plugin/jscre/JSRegExp_compile.cpp
@@ -0,0 +1,2677 @@
+/* This is JavaScriptCore's variant of the PCRE library. While this library
+started out as a copy of PCRE, many of the features of PCRE have been
+removed. This library now supports only the regular expression features
+required by the JavaScript language specification, and has only the functions
+needed by JavaScriptCore and the rest of WebKit.
+
+                 Originally written by Philip Hazel
+           Copyright (c) 1997-2006 University of Cambridge
+    Copyright (C) 2002, 2004, 2006, 2007 Apple Inc. All rights reserved.
+    Copyright (C) 2007 Eric Seidel <eric@webkit.org>
+
+-----------------------------------------------------------------------------
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+    * Neither the name of the University of Cambridge nor the names of its
+      contributors may be used to endorse or promote products derived from
+      this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+-----------------------------------------------------------------------------
+*/
+
+/* This module contains the external function jsRegExpExecute(), along with
+supporting internal functions that are not used by other modules. */
+
+#include "config.h"
+
+#include "JSRegExp_internal.h"
+
+#include <string.h>
+#include "ASCIICType.h"
+
+/* Negative values for the firstchar and reqchar variables */
+
+#define REQ_UNSET (-2)
+#define REQ_NONE  (-1)
+
+/*************************************************
+*      Code parameters and static tables         *
+*************************************************/
+
+/* Maximum number of items on the nested bracket stacks at compile time. This
+applies to the nesting of all kinds of parentheses. It does not limit
+un-nested, non-capturing parentheses. This number can be made bigger if
+necessary - it is used to dimension one int and one unsigned char vector at
+compile time. */
+
+#define BRASTACK_SIZE 200
+
+namespace jscre {
+
+/* Table for handling escaped characters in the range '0'-'z'. Positive returns
+are simple data values; negative values are for special things like \d and so
+on. Zero means further processing is needed (for things like \x), or the escape
+is invalid. */
+
+static const short escapes[] = {
+     0,      0,      0,      0,      0,      0,      0,      0,   /* 0 - 7 */
+     0,      0,    ':',    ';',    '<',    '=',    '>',    '?',   /* 8 - ? */
+   '@',      0, -ESC_B,      0, -ESC_D,      0,      0,      0,   /* @ - G */
+     0,      0,      0,      0,      0,      0,      0,      0,   /* H - O */
+     0,      0,      0, -ESC_S,      0,      0,      0, -ESC_W,   /* P - W */
+     0,      0,      0,    '[',   '\\',    ']',    '^',    '_',   /* X - _ */
+   '`',      7, -ESC_b,      0, -ESC_d,      0,   '\f',      0,   /* ` - g */
+     0,      0,      0,      0,      0,      0,   '\n',      0,   /* h - o */
+     0,      0,    '\r', -ESC_s,   '\t',      0,  '\v', -ESC_w,   /* p - w */
+     0,      0,      0                                            /* x - z */
+};
+
+/* Error code numbers. They are given names so that they can more easily be
+tracked. */
+
+enum ErrorCode {
+    ERR0, ERR1, ERR2, ERR3, ERR4, ERR5, ERR6, ERR7, ERR8, ERR9,
+    ERR10, ERR11, ERR12, ERR13, ERR14, ERR15, ERR16, ERR17
+};
+
+/* The texts of compile-time error messages. These are "char *" because they
+are passed to the outside world. */
+
+static const char* errorText(ErrorCode code)
+{
+    static const char errorTexts[] =
+      /* 1 */
+      "\\ at end of pattern\0"
+      "\\c at end of pattern\0"
+      "character value in \\x{...} sequence is too large\0"
+      "numbers out of order in {} quantifier\0"
+      /* 5 */
+      "number too big in {} quantifier\0"
+      "missing terminating ] for character class\0"
+      "internal error: code overflow\0"
+      "range out of order in character class\0"
+      "nothing to repeat\0"
+      /* 10 */
+      "unmatched parentheses\0"
+      "internal error: unexpected repeat\0"
+      "unrecognized character after (?\0"
+      "failed to get memory\0"
+      "missing )\0"
+      /* 15 */
+      "reference to non-existent subpattern\0"
+      "regular expression too large\0"
+      "parentheses nested too deeply"
+    ;
+
+    int i = code;
+    const char* text = errorTexts;
+    while (i > 1)
+        i -= !*text++;
+    return text;
+}
+
+/* Structure for passing "static" information around between the functions
+doing the compiling. */
+
+struct CompileData {
+    CompileData() {
+        top_backref = 0;
+        backrefMap = 0;
+        req_varyopt = 0;
+        needOuterBracket = false;
+        numCapturingBrackets = 0;
+    }
+    int top_backref;            /* Maximum back reference */
+    unsigned backrefMap;       /* Bitmap of low back refs */
+    int req_varyopt;            /* "After variable item" flag for reqbyte */
+    bool needOuterBracket;
+    int numCapturingBrackets;
+};
+
+/* Definitions to allow mutual recursion */
+
+static bool compileBracket(int, int*, unsigned char**, const UChar**, const UChar*, ErrorCode*, int, int*, int*, CompileData&);
+static bool bracketIsAnchored(const unsigned char* code);
+static bool bracketNeedsLineStart(const unsigned char* code, unsigned captureMap, unsigned backrefMap);
+static int bracketFindFirstAssertedCharacter(const unsigned char* code, bool inassert);
+
+/*************************************************
+*            Handle escapes                      *
+*************************************************/
+
+/* This function is called when a \ has been encountered. It either returns a
+positive value for a simple escape such as \n, or a negative value which
+encodes one of the more complicated things such as \d. When UTF-8 is enabled,
+a positive value greater than 255 may be returned. On entry, ptr is pointing at
+the \. On exit, it is on the final character of the escape sequence.
+
+Arguments:
+  ptrptr         points to the pattern position pointer
+  errorcodeptr   points to the errorcode variable
+  bracount       number of previous extracting brackets
+  options        the options bits
+  isclass        true if inside a character class
+
+Returns:         zero or positive => a data character
+                 negative => a special escape sequence
+                 on error, errorptr is set
+*/
+
+static int checkEscape(const UChar** ptrptr, const UChar* patternEnd, ErrorCode* errorcodeptr, int bracount, bool isclass)
+{
+    const UChar* ptr = *ptrptr + 1;
+
+    /* If backslash is at the end of the pattern, it's an error. */
+    if (ptr == patternEnd) {
+        *errorcodeptr = ERR1;
+        *ptrptr = ptr;
+        return 0;
+    }
+    
+    int c = *ptr;
+    
+    /* Non-alphamerics are literals. For digits or letters, do an initial lookup in
+     a table. A non-zero result is something that can be returned immediately.
+     Otherwise further processing may be required. */
+    
+    if (c < '0' || c > 'z') { /* Not alphameric */
+    } else if (int escapeValue = escapes[c - '0']) {
+        c = escapeValue;
+        if (isclass) {
+            if (-c == ESC_b)
+                c = '\b'; /* \b is backslash in a class */
+            else if (-c == ESC_B)
+                c = 'B'; /* and \B is a capital B in a class (in browsers event though ECMAScript 15.10.2.19 says it raises an error) */
+        }
+    /* Escapes that need further processing, or are illegal. */
+    
+    } else {
+        switch (c) {
+            case '1':
+            case '2':
+            case '3':
+            case '4':
+            case '5':
+            case '6':
+            case '7':
+            case '8':
+            case '9':
+                /* Escape sequences starting with a non-zero digit are backreferences,
+                 unless there are insufficient brackets, in which case they are octal
+                 escape sequences. Those sequences end on the first non-octal character
+                 or when we overflow 0-255, whichever comes first. */
+                
+                if (!isclass) {
+                    const UChar* oldptr = ptr;
+                    c -= '0';
+                    while ((ptr + 1 < patternEnd) && isASCIIDigit(ptr[1]) && c <= bracount)
+                        c = c * 10 + *(++ptr) - '0';
+                    if (c <= bracount) {
+                        c = -(ESC_REF + c);
+                        break;
+                    }
+                    ptr = oldptr;      /* Put the pointer back and fall through */
+                }
+                
+                /* Handle an octal number following \. If the first digit is 8 or 9,
+                 this is not octal. */
+                
+                if ((c = *ptr) >= '8')
+                    break;
+
+            /* \0 always starts an octal number, but we may drop through to here with a
+             larger first octal digit. */
+
+            case '0': {
+                c -= '0';
+                int i;
+                for (i = 1; i <= 2; ++i) {
+                    if (ptr + i >= patternEnd || ptr[i] < '0' || ptr[i] > '7')
+                        break;
+                    int cc = c * 8 + ptr[i] - '0';
+                    if (cc > 255)
+                        break;
+                    c = cc;
+                }
+                ptr += i - 1;
+                break;
+            }
+
+            case 'x': {
+                c = 0;
+                int i;
+                for (i = 1; i <= 2; ++i) {
+                    if (ptr + i >= patternEnd || !isASCIIHexDigit(ptr[i])) {
+                        c = 'x';
+                        i = 1;
+                        break;
+                    }
+                    int cc = ptr[i];
+                    if (cc >= 'a')
+                        cc -= 32;             /* Convert to upper case */
+                    c = c * 16 + cc - ((cc < 'A') ? '0' : ('A' - 10));
+                }
+                ptr += i - 1;
+                break;
+            }
+
+            case 'u': {
+                c = 0;
+                int i;
+                for (i = 1; i <= 4; ++i) {
+                    if (ptr + i >= patternEnd || !isASCIIHexDigit(ptr[i])) {
+                        c = 'u';
+                        i = 1;
+                        break;
+                    }
+                    int cc = ptr[i];
+                    if (cc >= 'a')
+                        cc -= 32;             /* Convert to upper case */
+                    c = c * 16 + cc - ((cc < 'A') ? '0' : ('A' - 10));
+                }
+                ptr += i - 1;
+                break;
+            }
+
+            case 'c':
+                if (++ptr == patternEnd) {
+                    *errorcodeptr = ERR2;
+                    return 0;
+                }
+                c = *ptr;
+                
+                /* A letter is upper-cased; then the 0x40 bit is flipped. This coding
+                 is ASCII-specific, but then the whole concept of \cx is ASCII-specific. */
+                c = toASCIIUpper(c) ^ 0x40;
+                break;
+            }
+    }
+    
+    *ptrptr = ptr;
+    return c;
+}
+
+/*************************************************
+*            Check for counted repeat            *
+*************************************************/
+
+/* This function is called when a '{' is encountered in a place where it might
+start a quantifier. It looks ahead to see if it really is a quantifier or not.
+It is only a quantifier if it is one of the forms {ddd} {ddd,} or {ddd,ddd}
+where the ddds are digits.
+
+Arguments:
+  p         pointer to the first char after '{'
+
+Returns:    true or false
+*/
+
+static bool isCountedRepeat(const UChar* p, const UChar* patternEnd)
+{
+    if (p >= patternEnd || !isASCIIDigit(*p))
+        return false;
+    p++;
+    while (p < patternEnd && isASCIIDigit(*p))
+        p++;
+    if (p < patternEnd && *p == '}')
+        return true;
+    
+    if (p >= patternEnd || *p++ != ',')
+        return false;
+    if (p < patternEnd && *p == '}')
+        return true;
+    
+    if (p >= patternEnd || !isASCIIDigit(*p))
+        return false;
+    p++;
+    while (p < patternEnd && isASCIIDigit(*p))
+        p++;
+    
+    return (p < patternEnd && *p == '}');
+}
+
+/*************************************************
+*         Read repeat counts                     *
+*************************************************/
+
+/* Read an item of the form {n,m} and return the values. This is called only
+after isCountedRepeat() has confirmed that a repeat-count quantifier exists,
+so the syntax is guaranteed to be correct, but we need to check the values.
+
+Arguments:
+  p              pointer to first char after '{'
+  minp           pointer to int for min
+  maxp           pointer to int for max
+                 returned as -1 if no max
+  errorcodeptr   points to error code variable
+
+Returns:         pointer to '}' on success;
+                 current ptr on error, with errorcodeptr set non-zero
+*/
+
+static const UChar* readRepeatCounts(const UChar* p, int* minp, int* maxp, ErrorCode* errorcodeptr)
+{
+    int min = 0;
+    int max = -1;
+    
+    /* Read the minimum value and do a paranoid check: a negative value indicates
+     an integer overflow. */
+    
+    while (isASCIIDigit(*p))
+        min = min * 10 + *p++ - '0';
+    if (min < 0 || min > 65535) {
+        *errorcodeptr = ERR5;
+        return p;
+    }
+    
+    /* Read the maximum value if there is one, and again do a paranoid on its size.
+     Also, max must not be less than min. */
+    
+    if (*p == '}')
+        max = min;
+    else {
+        if (*(++p) != '}') {
+            max = 0;
+            while (isASCIIDigit(*p))
+                max = max * 10 + *p++ - '0';
+            if (max < 0 || max > 65535) {
+                *errorcodeptr = ERR5;
+                return p;
+            }
+            if (max < min) {
+                *errorcodeptr = ERR4;
+                return p;
+            }
+        }
+    }
+    
+    /* Fill in the required variables, and pass back the pointer to the terminating
+     '}'. */
+    
+    *minp = min;
+    *maxp = max;
+    return p;
+}
+
+/*************************************************
+*      Find first significant op code            *
+*************************************************/
+
+/* This is called by several functions that scan a compiled expression looking
+for a fixed first character, or an anchoring op code etc. It skips over things
+that do not influence this.
+
+Arguments:
+  code         pointer to the start of the group
+Returns:       pointer to the first significant opcode
+*/
+
+static const unsigned char* firstSignificantOpcode(const unsigned char* code)
+{
+    while (*code == OP_BRANUMBER)
+        code += 3;
+    return code;
+}
+
+static const unsigned char* firstSignificantOpcodeSkippingAssertions(const unsigned char* code)
+{
+    while (true) {
+        switch (*code) {
+            case OP_ASSERT_NOT:
+                advanceToEndOfBracket(code);
+                code += 1 + LINK_SIZE;
+                break;
+            case OP_WORD_BOUNDARY:
+            case OP_NOT_WORD_BOUNDARY:
+                ++code;
+                break;
+            case OP_BRANUMBER:
+                code += 3;
+                break;
+            default:
+                return code;
+        }
+    }
+}
+
+/*************************************************
+*           Get othercase range                  *
+*************************************************/
+
+/* This function is passed the start and end of a class range, in UTF-8 mode
+with UCP support. It searches up the characters, looking for internal ranges of
+characters in the "other" case. Each call returns the next one, updating the
+start address.
+
+Arguments:
+  cptr        points to starting character value; updated
+  d           end value
+  ocptr       where to put start of othercase range
+  odptr       where to put end of othercase range
+
+Yield:        true when range returned; false when no more
+*/
+
+static bool getOthercaseRange(int* cptr, int d, int* ocptr, int* odptr)
+{
+    int c, othercase = 0;
+    
+    for (c = *cptr; c <= d; c++) {
+        if ((othercase = kjs_pcre_ucp_othercase(c)) >= 0)
+            break;
+    }
+    
+    if (c > d)
+        return false;
+    
+    *ocptr = othercase;
+    int next = othercase + 1;
+    
+    for (++c; c <= d; c++) {
+        if (kjs_pcre_ucp_othercase(c) != next)
+            break;
+        next++;
+    }
+    
+    *odptr = next - 1;
+    *cptr = c;
+    
+    return true;
+}
+
+/*************************************************
+ *       Convert character value to UTF-8         *
+ *************************************************/
+
+/* This function takes an integer value in the range 0 - 0x7fffffff
+ and encodes it as a UTF-8 character in 0 to 6 bytes.
+ 
+ Arguments:
+ cvalue     the character value
+ buffer     pointer to buffer for result - at least 6 bytes long
+ 
+ Returns:     number of characters placed in the buffer
+ */
+
+static int encodeUTF8(int cvalue, unsigned char *buffer)
+{
+    int i;
+    for (i = 0; i < kjs_pcre_utf8_table1_size; i++)
+        if (cvalue <= kjs_pcre_utf8_table1[i])
+            break;
+    buffer += i;
+    for (int j = i; j > 0; j--) {
+        *buffer-- = 0x80 | (cvalue & 0x3f);
+        cvalue >>= 6;
+    }
+    *buffer = kjs_pcre_utf8_table2[i] | cvalue;
+    return i + 1;
+}
+
+/*************************************************
+*           Compile one branch                   *
+*************************************************/
+
+/* Scan the pattern, compiling it into the code vector.
+
+Arguments:
+  options        the option bits
+  brackets       points to number of extracting brackets used
+  codeptr        points to the pointer to the current code point
+  ptrptr         points to the current pattern pointer
+  errorcodeptr   points to error code variable
+  firstbyteptr   set to initial literal character, or < 0 (REQ_UNSET, REQ_NONE)
+  reqbyteptr     set to the last literal character required, else < 0
+  cd             contains pointers to tables etc.
+
+Returns:         true on success
+                 false, with *errorcodeptr set non-zero on error
+*/
+
+static inline bool safelyCheckNextChar(const UChar* ptr, const UChar* patternEnd, UChar expected)
+{
+    return ((ptr + 1 < patternEnd) && ptr[1] == expected);
+}
+
+static bool
+compileBranch(int options, int* brackets, unsigned char** codeptr,
+               const UChar** ptrptr, const UChar* patternEnd, ErrorCode* errorcodeptr, int *firstbyteptr,
+               int* reqbyteptr, CompileData& cd)
+{
+    int repeat_type, op_type;
+    int repeat_min = 0, repeat_max = 0;      /* To please picky compilers */
+    int bravalue = 0;
+    int reqvary, tempreqvary;
+    int c;
+    unsigned char* code = *codeptr;
+    unsigned char* tempcode;
+    bool groupsetfirstbyte = false;
+    const UChar* ptr = *ptrptr;
+    const UChar* tempptr;
+    unsigned char* previous = NULL;
+    unsigned char classbits[32];
+    
+    bool class_utf8;
+    unsigned char* class_utf8data;
+    unsigned char utf8_char[6];
+    
+    /* Initialize no first byte, no required byte. REQ_UNSET means "no char
+     matching encountered yet". It gets changed to REQ_NONE if we hit something that
+     matches a non-fixed char first char; reqbyte just remains unset if we never
+     find one.
+     
+     When we hit a repeat whose minimum is zero, we may have to adjust these values
+     to take the zero repeat into account. This is implemented by setting them to
+     zerofirstbyte and zeroreqbyte when such a repeat is encountered. The individual
+     item types that can be repeated set these backoff variables appropriately. */
+    
+    int firstbyte = REQ_UNSET;
+    int reqbyte = REQ_UNSET;
+    int zeroreqbyte = REQ_UNSET;
+    int zerofirstbyte = REQ_UNSET;
+    
+    /* The variable req_caseopt contains either the REQ_IGNORE_CASE value or zero,
+     according to the current setting of the ignores-case flag. REQ_IGNORE_CASE is a bit
+     value > 255. It is added into the firstbyte or reqbyte variables to record the
+     case status of the value. This is used only for ASCII characters. */
+    
+    int req_caseopt = (options & IgnoreCaseOption) ? REQ_IGNORE_CASE : 0;
+    
+    /* Switch on next character until the end of the branch */
+    
+    for (;; ptr++) {
+        bool negate_class;
+        bool should_flip_negation; /* If a negative special such as \S is used, we should negate the whole class to properly support Unicode. */
+        int class_charcount;
+        int class_lastchar;
+        int skipbytes;
+        int subreqbyte;
+        int subfirstbyte;
+        int mclength;
+        unsigned char mcbuffer[8];
+        
+        /* Next byte in the pattern */
+        
+        c = ptr < patternEnd ? *ptr : 0;
+        
+        /* Fill in length of a previous callout, except when the next thing is
+         a quantifier. */
+        
+        bool is_quantifier = c == '*' || c == '+' || c == '?' || (c == '{' && isCountedRepeat(ptr + 1, patternEnd));
+        
+        switch (c) {
+            /* The branch terminates at end of string, |, or ). */
+                
+            case 0:
+                if (ptr < patternEnd)
+                    goto NORMAL_CHAR;
+                // End of string; fall through
+            case '|':
+            case ')':
+                *firstbyteptr = firstbyte;
+                *reqbyteptr = reqbyte;
+                *codeptr = code;
+                *ptrptr = ptr;
+                return true;
+                
+            /* Handle single-character metacharacters. In multiline mode, ^ disables
+             the setting of any following char as a first character. */
+
+            case '^':
+                if (options & MatchAcrossMultipleLinesOption) {
+                    if (firstbyte == REQ_UNSET)
+                        firstbyte = REQ_NONE;
+                    *code++ = OP_BOL;
+                } else
+                    *code++ = OP_CIRC;
+                previous = NULL;
+                break;
+
+            case '$':
+                previous = NULL;
+                if (options & MatchAcrossMultipleLinesOption)
+                  *code++ = OP_EOL;
+                else
+                  *code++ = OP_DOLL;
+                break;
+
+            /* There can never be a first char if '.' is first, whatever happens about
+             repeats. The value of reqbyte doesn't change either. */
+
+            case '.':
+                if (firstbyte == REQ_UNSET)
+                    firstbyte = REQ_NONE;
+                zerofirstbyte = firstbyte;
+                zeroreqbyte = reqbyte;
+                previous = code;
+                *code++ = OP_NOT_NEWLINE;
+                break;
+                
+            /* Character classes. If the included characters are all < 256, we build a
+             32-byte bitmap of the permitted characters, except in the special case
+             where there is only one such character. For negated classes, we build the
+             map as usual, then invert it at the end. However, we use a different opcode
+             so that data characters > 255 can be handled correctly.
+             
+             If the class contains characters outside the 0-255 range, a different
+             opcode is compiled. It may optionally have a bit map for characters < 256,
+             but those above are are explicitly listed afterwards. A flag byte tells
+             whether the bitmap is present, and whether this is a negated class or not.
+             */
+                
+            case '[': {
+                previous = code;
+                should_flip_negation = false;
+                
+                /* PCRE supports POSIX class stuff inside a class. Perl gives an error if
+                 they are encountered at the top level, so we'll do that too. */
+                
+                /* If the first character is '^', set the negation flag and skip it. */
+
+                if (ptr + 1 >= patternEnd) {
+                    *errorcodeptr = ERR6;
+                    return false;
+                }
+
+                if (ptr[1] == '^') {
+                    negate_class = true;
+                    ++ptr;
+                } else
+                    negate_class = false;
+                
+                /* Keep a count of chars with values < 256 so that we can optimize the case
+                 of just a single character (as long as it's < 256). For higher valued UTF-8
+                 characters, we don't yet do any optimization. */
+                
+                class_charcount = 0;
+                class_lastchar = -1;
+                
+                class_utf8 = false;                       /* No chars >= 256 */
+                class_utf8data = code + LINK_SIZE + 34;   /* For UTF-8 items */
+                
+                /* Initialize the 32-char bit map to all zeros. We have to build the
+                 map in a temporary bit of store, in case the class contains only 1
+                 character (< 256), because in that case the compiled code doesn't use the
+                 bit map. */
+                
+                memset(classbits, 0, 32 * sizeof(unsigned char));
+                
+                /* Process characters until ] is reached. The first pass
+                 through the regex checked the overall syntax, so we don't need to be very
+                 strict here. At the start of the loop, c contains the first byte of the
+                 character. */
+
+                while ((++ptr < patternEnd) && (c = *ptr) != ']') {
+                    /* Backslash may introduce a single character, or it may introduce one
+                     of the specials, which just set a flag. Escaped items are checked for
+                     validity in the pre-compiling pass. The sequence \b is a special case.
+                     Inside a class (and only there) it is treated as backspace. Elsewhere
+                     it marks a word boundary. Other escapes have preset maps ready to
+                     or into the one we are building. We assume they have more than one
+                     character in them, so set class_charcount bigger than one. */
+                    
+                    if (c == '\\') {
+                        c = checkEscape(&ptr, patternEnd, errorcodeptr, cd.numCapturingBrackets, true);
+                        if (c < 0) {
+                            class_charcount += 2;     /* Greater than 1 is what matters */
+                            switch (-c) {
+                                case ESC_d:
+                                    for (c = 0; c < 32; c++)
+                                        classbits[c] |= classBitmapForChar(c + cbit_digit);
+                                    continue;
+                                    
+                                case ESC_D:
+                                    should_flip_negation = true;
+                                    for (c = 0; c < 32; c++)
+                                        classbits[c] |= ~classBitmapForChar(c + cbit_digit);
+                                    continue;
+                                    
+                                case ESC_w:
+                                    for (c = 0; c < 32; c++)
+                                        classbits[c] |= classBitmapForChar(c + cbit_word);
+                                    continue;
+                                    
+                                case ESC_W:
+                                    should_flip_negation = true;
+                                    for (c = 0; c < 32; c++)
+                                        classbits[c] |= ~classBitmapForChar(c + cbit_word);
+                                    continue;
+                                    
+                                case ESC_s:
+                                    for (c = 0; c < 32; c++)
+                                         classbits[c] |= classBitmapForChar(c + cbit_space);
+                                    continue;
+                                    
+                                case ESC_S:
+                                    should_flip_negation = true;
+                                    for (c = 0; c < 32; c++)
+                                         classbits[c] |= ~classBitmapForChar(c + cbit_space);
+                                    continue;
+                                    
+                                    /* Unrecognized escapes are faulted if PCRE is running in its
+                                     strict mode. By default, for compatibility with Perl, they are
+                                     treated as literals. */
+                                    
+                                default:
+                                    c = *ptr;              /* The final character */
+                                    class_charcount -= 2;  /* Undo the default count from above */
+                            }
+                        }
+                        
+                        /* Fall through if we have a single character (c >= 0). This may be
+                         > 256 in UTF-8 mode. */
+                        
+                    }   /* End of backslash handling */
+                    
+                    /* A single character may be followed by '-' to form a range. However,
+                     Perl does not permit ']' to be the end of the range. A '-' character
+                     here is treated as a literal. */
+                    
+                    if ((ptr + 2 < patternEnd) && ptr[1] == '-' && ptr[2] != ']') {
+                        ptr += 2;
+                        
+                        int d = *ptr;
+                        
+                        /* The second part of a range can be a single-character escape, but
+                         not any of the other escapes. Perl 5.6 treats a hyphen as a literal
+                         in such circumstances. */
+                        
+                        if (d == '\\') {
+                            const UChar* oldptr = ptr;
+                            d = checkEscape(&ptr, patternEnd, errorcodeptr, cd.numCapturingBrackets, true);
+                            
+                            /* \X is literal X; any other special means the '-' was literal */
+                            if (d < 0) {
+                                ptr = oldptr - 2;
+                                goto LONE_SINGLE_CHARACTER;  /* A few lines below */
+                            }
+                        }
+                        
+                        /* The check that the two values are in the correct order happens in
+                         the pre-pass. Optimize one-character ranges */
+                        
+                        if (d == c)
+                            goto LONE_SINGLE_CHARACTER;  /* A few lines below */
+                        
+                        /* In UTF-8 mode, if the upper limit is > 255, or > 127 for caseless
+                         matching, we have to use an XCLASS with extra data items. Caseless
+                         matching for characters > 127 is available only if UCP support is
+                         available. */
+                        
+                        if ((d > 255 || ((options & IgnoreCaseOption) && d > 127))) {
+                            class_utf8 = true;
+                            
+                            /* With UCP support, we can find the other case equivalents of
+                             the relevant characters. There may be several ranges. Optimize how
+                             they fit with the basic range. */
+                            
+                            if (options & IgnoreCaseOption) {
+                                int occ, ocd;
+                                int cc = c;
+                                int origd = d;
+                                while (getOthercaseRange(&cc, origd, &occ, &ocd)) {
+                                    if (occ >= c && ocd <= d)
+                                        continue;  /* Skip embedded ranges */
+                                    
+                                    if (occ < c  && ocd >= c - 1)        /* Extend the basic range */
+                                    {                                  /* if there is overlap,   */
+                                        c = occ;                           /* noting that if occ < c */
+                                        continue;                          /* we can't have ocd > d  */
+                                    }                                  /* because a subrange is  */
+                                    if (ocd > d && occ <= d + 1)         /* always shorter than    */
+                                    {                                  /* the basic range.       */
+                                        d = ocd;
+                                        continue;
+                                    }
+                                    
+                                    if (occ == ocd)
+                                        *class_utf8data++ = XCL_SINGLE;
+                                    else {
+                                        *class_utf8data++ = XCL_RANGE;
+                                        class_utf8data += encodeUTF8(occ, class_utf8data);
+                                    }
+                                    class_utf8data += encodeUTF8(ocd, class_utf8data);
+                                }
+                            }
+                            
+                            /* Now record the original range, possibly modified for UCP caseless
+                             overlapping ranges. */
+                            
+                            *class_utf8data++ = XCL_RANGE;
+                            class_utf8data += encodeUTF8(c, class_utf8data);
+                            class_utf8data += encodeUTF8(d, class_utf8data);
+                            
+                            /* With UCP support, we are done. Without UCP support, there is no
+                             caseless matching for UTF-8 characters > 127; we can use the bit map
+                             for the smaller ones. */
+                            
+                            continue;    /* With next character in the class */
+                        }
+                        
+                        /* We use the bit map for all cases when not in UTF-8 mode; else
+                         ranges that lie entirely within 0-127 when there is UCP support; else
+                         for partial ranges without UCP support. */
+                        
+                        for (; c <= d; c++) {
+                            classbits[c/8] |= (1 << (c&7));
+                            if (options & IgnoreCaseOption) {
+                                int uc = flipCase(c);
+                                classbits[uc/8] |= (1 << (uc&7));
+                            }
+                            class_charcount++;                /* in case a one-char range */
+                            class_lastchar = c;
+                        }
+                        
+                        continue;   /* Go get the next char in the class */
+                    }
+                    
+                    /* Handle a lone single character - we can get here for a normal
+                     non-escape char, or after \ that introduces a single character or for an
+                     apparent range that isn't. */
+                    
+                LONE_SINGLE_CHARACTER:
+                    
+                    /* Handle a character that cannot go in the bit map */
+                    
+                    if ((c > 255 || ((options & IgnoreCaseOption) && c > 127))) {
+                        class_utf8 = true;
+                        *class_utf8data++ = XCL_SINGLE;
+                        class_utf8data += encodeUTF8(c, class_utf8data);
+                        
+                        if (options & IgnoreCaseOption) {
+                            int othercase;
+                            if ((othercase = kjs_pcre_ucp_othercase(c)) >= 0) {
+                                *class_utf8data++ = XCL_SINGLE;
+                                class_utf8data += encodeUTF8(othercase, class_utf8data);
+                            }
+                        }
+                    } else {
+                        /* Handle a single-byte character */
+                        classbits[c/8] |= (1 << (c&7));
+                        if (options & IgnoreCaseOption) {
+                            c = flipCase(c);
+                            classbits[c/8] |= (1 << (c&7));
+                        }
+                        class_charcount++;
+                        class_lastchar = c;
+                    }
+                }
+                
+                /* If class_charcount is 1, we saw precisely one character whose value is
+                 less than 256. In non-UTF-8 mode we can always optimize. In UTF-8 mode, we
+                 can optimize the negative case only if there were no characters >= 128
+                 because OP_NOT and the related opcodes like OP_NOTSTAR operate on
+                 single-bytes only. This is an historical hangover. Maybe one day we can
+                 tidy these opcodes to handle multi-byte characters.
+                 
+                 The optimization throws away the bit map. We turn the item into a
+                 1-character OP_CHAR[NC] if it's positive, or OP_NOT if it's negative. Note
+                 that OP_NOT does not support multibyte characters. In the positive case, it
+                 can cause firstbyte to be set. Otherwise, there can be no first char if
+                 this item is first, whatever repeat count may follow. In the case of
+                 reqbyte, save the previous value for reinstating. */
+                
+                if (class_charcount == 1 && (!class_utf8 && (!negate_class || class_lastchar < 128))) {
+                    zeroreqbyte = reqbyte;
+                    
+                    /* The OP_NOT opcode works on one-byte characters only. */
+                    
+                    if (negate_class) {
+                        if (firstbyte == REQ_UNSET)
+                            firstbyte = REQ_NONE;
+                        zerofirstbyte = firstbyte;
+                        *code++ = OP_NOT;
+                        *code++ = class_lastchar;
+                        break;
+                    }
+                    
+                    /* For a single, positive character, get the value into c, and
+                     then we can handle this with the normal one-character code. */
+                    
+                    c = class_lastchar;
+                    goto NORMAL_CHAR;
+                }       /* End of 1-char optimization */
+                
+                /* The general case - not the one-char optimization. If this is the first
+                 thing in the branch, there can be no first char setting, whatever the
+                 repeat count. Any reqbyte setting must remain unchanged after any kind of
+                 repeat. */
+                
+                if (firstbyte == REQ_UNSET) firstbyte = REQ_NONE;
+                zerofirstbyte = firstbyte;
+                zeroreqbyte = reqbyte;
+                
+                /* If there are characters with values > 255, we have to compile an
+                 extended class, with its own opcode. If there are no characters < 256,
+                 we can omit the bitmap. */
+                
+                if (class_utf8 && !should_flip_negation) {
+                    *class_utf8data++ = XCL_END;    /* Marks the end of extra data */
+                    *code++ = OP_XCLASS;
+                    code += LINK_SIZE;
+                    *code = negate_class? XCL_NOT : 0;
+                    
+                    /* If the map is required, install it, and move on to the end of
+                     the extra data */
+                    
+                    if (class_charcount > 0) {
+                        *code++ |= XCL_MAP;
+                        memcpy(code, classbits, 32);
+                        code = class_utf8data;
+                    }
+                    
+                    /* If the map is not required, slide down the extra data. */
+                    
+                    else {
+                        int len = class_utf8data - (code + 33);
+                        memmove(code + 1, code + 33, len);
+                        code += len + 1;
+                    }
+                    
+                    /* Now fill in the complete length of the item */
+                    
+                    putLinkValue(previous + 1, code - previous);
+                    break;   /* End of class handling */
+                }
+                
+                /* If there are no characters > 255, negate the 32-byte map if necessary,
+                 and copy it into the code vector. If this is the first thing in the branch,
+                 there can be no first char setting, whatever the repeat count. Any reqbyte
+                 setting must remain unchanged after any kind of repeat. */
+                
+                *code++ = (negate_class == should_flip_negation) ? OP_CLASS : OP_NCLASS;
+                if (negate_class)
+                    for (c = 0; c < 32; c++)
+                        code[c] = ~classbits[c];
+                else
+                    memcpy(code, classbits, 32);
+                code += 32;
+                break;
+            }
+                
+            /* Various kinds of repeat; '{' is not necessarily a quantifier, but this
+             has been tested above. */
+
+            case '{':
+                if (!is_quantifier)
+                    goto NORMAL_CHAR;
+                ptr = readRepeatCounts(ptr + 1, &repeat_min, &repeat_max, errorcodeptr);
+                if (*errorcodeptr)
+                    goto FAILED;
+                goto REPEAT;
+                
+            case '*':
+                repeat_min = 0;
+                repeat_max = -1;
+                goto REPEAT;
+                
+            case '+':
+                repeat_min = 1;
+                repeat_max = -1;
+                goto REPEAT;
+                
+            case '?':
+                repeat_min = 0;
+                repeat_max = 1;
+                
+            REPEAT:
+                if (!previous) {
+                    *errorcodeptr = ERR9;
+                    goto FAILED;
+                }
+                
+                if (repeat_min == 0) {
+                    firstbyte = zerofirstbyte;    /* Adjust for zero repeat */
+                    reqbyte = zeroreqbyte;        /* Ditto */
+                }
+                
+                /* Remember whether this is a variable length repeat */
+                
+                reqvary = (repeat_min == repeat_max) ? 0 : REQ_VARY;
+                
+                op_type = 0;                    /* Default single-char op codes */
+                
+                /* Save start of previous item, in case we have to move it up to make space
+                 for an inserted OP_ONCE for the additional '+' extension. */
+                /* FIXME: Probably don't need this because we don't use OP_ONCE. */
+                
+                tempcode = previous;
+                
+                /* If the next character is '+', we have a possessive quantifier. This
+                 implies greediness, whatever the setting of the PCRE_UNGREEDY option.
+                 If the next character is '?' this is a minimizing repeat, by default,
+                 but if PCRE_UNGREEDY is set, it works the other way round. We change the
+                 repeat type to the non-default. */
+                
+                if (safelyCheckNextChar(ptr, patternEnd, '?')) {
+                    repeat_type = 1;
+                    ptr++;
+                } else
+                    repeat_type = 0;
+                
+                /* If previous was a character match, abolish the item and generate a
+                 repeat item instead. If a char item has a minumum of more than one, ensure
+                 that it is set in reqbyte - it might not be if a sequence such as x{3} is
+                 the first thing in a branch because the x will have gone into firstbyte
+                 instead.  */
+                
+                if (*previous == OP_CHAR || *previous == OP_CHAR_IGNORING_CASE) {
+                    /* Deal with UTF-8 characters that take up more than one byte. It's
+                     easier to write this out separately than try to macrify it. Use c to
+                     hold the length of the character in bytes, plus 0x80 to flag that it's a
+                     length rather than a small character. */
+                    
+                    if (code[-1] & 0x80) {
+                        unsigned char *lastchar = code - 1;
+                        while((*lastchar & 0xc0) == 0x80)
+                            lastchar--;
+                        c = code - lastchar;            /* Length of UTF-8 character */
+                        memcpy(utf8_char, lastchar, c); /* Save the char */
+                        c |= 0x80;                      /* Flag c as a length */
+                    }
+                    else {
+                        c = code[-1];
+                        if (repeat_min > 1)
+                            reqbyte = c | req_caseopt | cd.req_varyopt;
+                    }
+                    
+                    goto OUTPUT_SINGLE_REPEAT;   /* Code shared with single character types */
+                }
+                
+                else if (*previous == OP_ASCII_CHAR || *previous == OP_ASCII_LETTER_IGNORING_CASE) {
+                    c = previous[1];
+                    if (repeat_min > 1)
+                        reqbyte = c | req_caseopt | cd.req_varyopt;
+                    goto OUTPUT_SINGLE_REPEAT;
+                }
+                
+                /* If previous was a single negated character ([^a] or similar), we use
+                 one of the special opcodes, replacing it. The code is shared with single-
+                 character repeats by setting opt_type to add a suitable offset into
+                 repeat_type. OP_NOT is currently used only for single-byte chars. */
+                
+                else if (*previous == OP_NOT) {
+                    op_type = OP_NOTSTAR - OP_STAR;  /* Use "not" opcodes */
+                    c = previous[1];
+                    goto OUTPUT_SINGLE_REPEAT;
+                }
+                
+                /* If previous was a character type match (\d or similar), abolish it and
+                 create a suitable repeat item. The code is shared with single-character
+                 repeats by setting op_type to add a suitable offset into repeat_type. */
+                
+                else if (*previous <= OP_NOT_NEWLINE) {
+                    op_type = OP_TYPESTAR - OP_STAR;  /* Use type opcodes */
+                    c = *previous;
+                    
+                OUTPUT_SINGLE_REPEAT:
+                    int prop_type = -1;
+                    int prop_value = -1;
+                    
+                    unsigned char* oldcode = code;
+                    code = previous;                  /* Usually overwrite previous item */
+                    
+                    /* If the maximum is zero then the minimum must also be zero; Perl allows
+                     this case, so we do too - by simply omitting the item altogether. */
+                    
+                    if (repeat_max == 0)
+                        goto END_REPEAT;
+                    
+                    /* Combine the op_type with the repeat_type */
+                    
+                    repeat_type += op_type;
+                    
+                    /* A minimum of zero is handled either as the special case * or ?, or as
+                     an UPTO, with the maximum given. */
+                    
+                    if (repeat_min == 0) {
+                        if (repeat_max == -1)
+                            *code++ = OP_STAR + repeat_type;
+                        else if (repeat_max == 1)
+                            *code++ = OP_QUERY + repeat_type;
+                        else {
+                            *code++ = OP_UPTO + repeat_type;
+                            put2ByteValueAndAdvance(code, repeat_max);
+                        }
+                    }
+                    
+                    /* A repeat minimum of 1 is optimized into some special cases. If the
+                     maximum is unlimited, we use OP_PLUS. Otherwise, the original item it
+                     left in place and, if the maximum is greater than 1, we use OP_UPTO with
+                     one less than the maximum. */
+                    
+                    else if (repeat_min == 1) {
+                        if (repeat_max == -1)
+                            *code++ = OP_PLUS + repeat_type;
+                        else {
+                            code = oldcode;                 /* leave previous item in place */
+                            if (repeat_max == 1)
+                                goto END_REPEAT;
+                            *code++ = OP_UPTO + repeat_type;
+                            put2ByteValueAndAdvance(code, repeat_max - 1);
+                        }
+                    }
+                    
+                    /* The case {n,n} is just an EXACT, while the general case {n,m} is
+                     handled as an EXACT followed by an UPTO. */
+                    
+                    else {
+                        *code++ = OP_EXACT + op_type;  /* NB EXACT doesn't have repeat_type */
+                        put2ByteValueAndAdvance(code, repeat_min);
+                        
+                        /* If the maximum is unlimited, insert an OP_STAR. Before doing so,
+                         we have to insert the character for the previous code. For a repeated
+                         Unicode property match, there are two extra bytes that define the
+                         required property. In UTF-8 mode, long characters have their length in
+                         c, with the 0x80 bit as a flag. */
+                        
+                        if (repeat_max < 0) {
+                            if (c >= 128) {
+                                memcpy(code, utf8_char, c & 7);
+                                code += c & 7;
+                            } else {
+                                *code++ = c;
+                                if (prop_type >= 0) {
+                                    *code++ = prop_type;
+                                    *code++ = prop_value;
+                                }
+                            }
+                            *code++ = OP_STAR + repeat_type;
+                        }
+                        
+                        /* Else insert an UPTO if the max is greater than the min, again
+                         preceded by the character, for the previously inserted code. */
+                        
+                        else if (repeat_max != repeat_min) {
+                            if (c >= 128) {
+                                memcpy(code, utf8_char, c & 7);
+                                code += c & 7;
+                            } else
+                                *code++ = c;
+                            if (prop_type >= 0) {
+                                *code++ = prop_type;
+                                *code++ = prop_value;
+                            }
+                            repeat_max -= repeat_min;
+                            *code++ = OP_UPTO + repeat_type;
+                            put2ByteValueAndAdvance(code, repeat_max);
+                        }
+                    }
+                    
+                    /* The character or character type itself comes last in all cases. */
+                    
+                    if (c >= 128) {
+                        memcpy(code, utf8_char, c & 7);
+                        code += c & 7;
+                    } else
+                        *code++ = c;
+                    
+                    /* For a repeated Unicode property match, there are two extra bytes that
+                     define the required property. */
+                    
+                    if (prop_type >= 0) {
+                        *code++ = prop_type;
+                        *code++ = prop_value;
+                    }
+                }
+                
+                /* If previous was a character class or a back reference, we put the repeat
+                 stuff after it, but just skip the item if the repeat was {0,0}. */
+                
+                else if (*previous == OP_CLASS ||
+                         *previous == OP_NCLASS ||
+                         *previous == OP_XCLASS ||
+                         *previous == OP_REF)
+                {
+                    if (repeat_max == 0) {
+                        code = previous;
+                        goto END_REPEAT;
+                    }
+                    
+                    if (repeat_min == 0 && repeat_max == -1)
+                        *code++ = OP_CRSTAR + repeat_type;
+                    else if (repeat_min == 1 && repeat_max == -1)
+                        *code++ = OP_CRPLUS + repeat_type;
+                    else if (repeat_min == 0 && repeat_max == 1)
+                        *code++ = OP_CRQUERY + repeat_type;
+                    else {
+                        *code++ = OP_CRRANGE + repeat_type;
+                        put2ByteValueAndAdvance(code, repeat_min);
+                        if (repeat_max == -1)
+                            repeat_max = 0;  /* 2-byte encoding for max */
+                        put2ByteValueAndAdvance(code, repeat_max);
+                    }
+                }
+                
+                /* If previous was a bracket group, we may have to replicate it in certain
+                 cases. */
+                
+                else if (*previous >= OP_BRA) {
+                    int ketoffset = 0;
+                    int len = code - previous;
+                    unsigned char* bralink = NULL;
+                    
+                    /* If the maximum repeat count is unlimited, find the end of the bracket
+                     by scanning through from the start, and compute the offset back to it
+                     from the current code pointer. There may be an OP_OPT setting following
+                     the final KET, so we can't find the end just by going back from the code
+                     pointer. */
+                    
+                    if (repeat_max == -1) {
+                        const unsigned char* ket = previous;
+                        advanceToEndOfBracket(ket);
+                        ketoffset = code - ket;
+                    }
+                    
+                    /* The case of a zero minimum is special because of the need to stick
+                     OP_BRAZERO in front of it, and because the group appears once in the
+                     data, whereas in other cases it appears the minimum number of times. For
+                     this reason, it is simplest to treat this case separately, as otherwise
+                     the code gets far too messy. There are several special subcases when the
+                     minimum is zero. */
+                    
+                    if (repeat_min == 0) {
+                        /* If the maximum is also zero, we just omit the group from the output
+                         altogether. */
+                        
+                        if (repeat_max == 0) {
+                            code = previous;
+                            goto END_REPEAT;
+                        }
+                        
+                        /* If the maximum is 1 or unlimited, we just have to stick in the
+                         BRAZERO and do no more at this point. However, we do need to adjust
+                         any OP_RECURSE calls inside the group that refer to the group itself or
+                         any internal group, because the offset is from the start of the whole
+                         regex. Temporarily terminate the pattern while doing this. */
+                        
+                        if (repeat_max <= 1) {
+                            *code = OP_END;
+                            memmove(previous+1, previous, len);
+                            code++;
+                            *previous++ = OP_BRAZERO + repeat_type;
+                        }
+                        
+                        /* If the maximum is greater than 1 and limited, we have to replicate
+                         in a nested fashion, sticking OP_BRAZERO before each set of brackets.
+                         The first one has to be handled carefully because it's the original
+                         copy, which has to be moved up. The remainder can be handled by code
+                         that is common with the non-zero minimum case below. We have to
+                         adjust the value of repeat_max, since one less copy is required. */
+                        
+                        else {
+                            *code = OP_END;
+                            memmove(previous + 2 + LINK_SIZE, previous, len);
+                            code += 2 + LINK_SIZE;
+                            *previous++ = OP_BRAZERO + repeat_type;
+                            *previous++ = OP_BRA;
+                            
+                            /* We chain together the bracket offset fields that have to be
+                             filled in later when the ends of the brackets are reached. */
+                            
+                            int offset = (!bralink) ? 0 : previous - bralink;
+                            bralink = previous;
+                            putLinkValueAllowZeroAndAdvance(previous, offset);
+                        }
+                        
+                        repeat_max--;
+                    }
+                    
+                    /* If the minimum is greater than zero, replicate the group as many
+                     times as necessary, and adjust the maximum to the number of subsequent
+                     copies that we need. If we set a first char from the group, and didn't
+                     set a required char, copy the latter from the former. */
+                    
+                    else {
+                        if (repeat_min > 1) {
+                            if (groupsetfirstbyte && reqbyte < 0)
+                                reqbyte = firstbyte;
+                            for (int i = 1; i < repeat_min; i++) {
+                                memcpy(code, previous, len);
+                                code += len;
+                            }
+                        }
+                        if (repeat_max > 0)
+                            repeat_max -= repeat_min;
+                    }
+                    
+                    /* This code is common to both the zero and non-zero minimum cases. If
+                     the maximum is limited, it replicates the group in a nested fashion,
+                     remembering the bracket starts on a stack. In the case of a zero minimum,
+                     the first one was set up above. In all cases the repeat_max now specifies
+                     the number of additional copies needed. */
+                    
+                    if (repeat_max >= 0) {
+                        for (int i = repeat_max - 1; i >= 0; i--) {
+                            *code++ = OP_BRAZERO + repeat_type;
+                            
+                            /* All but the final copy start a new nesting, maintaining the
+                             chain of brackets outstanding. */
+                            
+                            if (i != 0) {
+                                *code++ = OP_BRA;
+                                int offset = (!bralink) ? 0 : code - bralink;
+                                bralink = code;
+                                putLinkValueAllowZeroAndAdvance(code, offset);
+                            }
+                            
+                            memcpy(code, previous, len);
+                            code += len;
+                        }
+                        
+                        /* Now chain through the pending brackets, and fill in their length
+                         fields (which are holding the chain links pro tem). */
+                        
+                        while (bralink) {
+                            int offset = code - bralink + 1;
+                            unsigned char* bra = code - offset;
+                            int oldlinkoffset = getLinkValueAllowZero(bra + 1);
+                            bralink = (!oldlinkoffset) ? 0 : bralink - oldlinkoffset;
+                            *code++ = OP_KET;
+                            putLinkValueAndAdvance(code, offset);
+                            putLinkValue(bra + 1, offset);
+                        }
+                    }
+                    
+                    /* If the maximum is unlimited, set a repeater in the final copy. We
+                     can't just offset backwards from the current code point, because we
+                     don't know if there's been an options resetting after the ket. The
+                     correct offset was computed above. */
+                    
+                    else
+                        code[-ketoffset] = OP_KETRMAX + repeat_type;
+                }
+                
+                /* Else there's some kind of shambles */
+                
+                else {
+                    *errorcodeptr = ERR11;
+                    goto FAILED;
+                }
+                
+                /* In all case we no longer have a previous item. We also set the
+                 "follows varying string" flag for subsequently encountered reqbytes if
+                 it isn't already set and we have just passed a varying length item. */
+                
+            END_REPEAT:
+                previous = NULL;
+                cd.req_varyopt |= reqvary;
+                break;
+                
+            /* Start of nested bracket sub-expression, or comment or lookahead or
+             lookbehind or option setting or condition. First deal with special things
+             that can come after a bracket; all are introduced by ?, and the appearance
+             of any of them means that this is not a referencing group. They were
+             checked for validity in the first pass over the string, so we don't have to
+             check for syntax errors here.  */
+                
+            case '(':
+                skipbytes = 0;
+                
+                if (*(++ptr) == '?') {
+                    switch (*(++ptr)) {
+                        case ':':                 /* Non-extracting bracket */
+                            bravalue = OP_BRA;
+                            ptr++;
+                            break;
+                            
+                        case '=':                 /* Positive lookahead */
+                            bravalue = OP_ASSERT;
+                            ptr++;
+                            break;
+                            
+                        case '!':                 /* Negative lookahead */
+                            bravalue = OP_ASSERT_NOT;
+                            ptr++;
+                            break;
+                            
+                        /* Character after (? not specially recognized */
+                            
+                        default:
+                            *errorcodeptr = ERR12;
+                            goto FAILED;
+                        }
+                }
+                
+                /* Else we have a referencing group; adjust the opcode. If the bracket
+                 number is greater than EXTRACT_BASIC_MAX, we set the opcode one higher, and
+                 arrange for the true number to follow later, in an OP_BRANUMBER item. */
+                
+                else {
+                    if (++(*brackets) > EXTRACT_BASIC_MAX) {
+                        bravalue = OP_BRA + EXTRACT_BASIC_MAX + 1;
+                        code[1 + LINK_SIZE] = OP_BRANUMBER;
+                        put2ByteValue(code + 2 + LINK_SIZE, *brackets);
+                        skipbytes = 3;
+                    }
+                    else
+                        bravalue = OP_BRA + *brackets;
+                }
+                
+                /* Process nested bracketed re. Assertions may not be repeated, but other
+                 kinds can be. We copy code into a non-variable in order to be able
+                 to pass its address because some compilers complain otherwise. Pass in a
+                 new setting for the ims options if they have changed. */
+                
+                previous = (bravalue >= OP_BRAZERO) ? code : 0;
+                *code = bravalue;
+                tempcode = code;
+                tempreqvary = cd.req_varyopt;     /* Save value before bracket */
+                
+                if (!compileBracket(
+                                   options,
+                                   brackets,                     /* Extracting bracket count */
+                                   &tempcode,                    /* Where to put code (updated) */
+                                   &ptr,                         /* Input pointer (updated) */
+                                   patternEnd,
+                                   errorcodeptr,                 /* Where to put an error message */
+                                   skipbytes,                    /* Skip over OP_BRANUMBER */
+                                   &subfirstbyte,                /* For possible first char */
+                                   &subreqbyte,                  /* For possible last char */
+                                   cd))                          /* Tables block */
+                    goto FAILED;
+                
+                /* At the end of compiling, code is still pointing to the start of the
+                 group, while tempcode has been updated to point past the end of the group
+                 and any option resetting that may follow it. The pattern pointer (ptr)
+                 is on the bracket. */
+                
+                /* Handle updating of the required and first characters. Update for normal
+                 brackets of all kinds, and conditions with two branches (see code above).
+                 If the bracket is followed by a quantifier with zero repeat, we have to
+                 back off. Hence the definition of zeroreqbyte and zerofirstbyte outside the
+                 main loop so that they can be accessed for the back off. */
+                
+                zeroreqbyte = reqbyte;
+                zerofirstbyte = firstbyte;
+                groupsetfirstbyte = false;
+                
+                if (bravalue >= OP_BRA) {
+                    /* If we have not yet set a firstbyte in this branch, take it from the
+                     subpattern, remembering that it was set here so that a repeat of more
+                     than one can replicate it as reqbyte if necessary. If the subpattern has
+                     no firstbyte, set "none" for the whole branch. In both cases, a zero
+                     repeat forces firstbyte to "none". */
+                    
+                    if (firstbyte == REQ_UNSET) {
+                        if (subfirstbyte >= 0) {
+                            firstbyte = subfirstbyte;
+                            groupsetfirstbyte = true;
+                        }
+                        else
+                            firstbyte = REQ_NONE;
+                        zerofirstbyte = REQ_NONE;
+                    }
+                    
+                    /* If firstbyte was previously set, convert the subpattern's firstbyte
+                     into reqbyte if there wasn't one, using the vary flag that was in
+                     existence beforehand. */
+                    
+                    else if (subfirstbyte >= 0 && subreqbyte < 0)
+                        subreqbyte = subfirstbyte | tempreqvary;
+                    
+                    /* If the subpattern set a required byte (or set a first byte that isn't
+                     really the first byte - see above), set it. */
+                    
+                    if (subreqbyte >= 0)
+                        reqbyte = subreqbyte;
+                }
+                
+                /* For a forward assertion, we take the reqbyte, if set. This can be
+                 helpful if the pattern that follows the assertion doesn't set a different
+                 char. For example, it's useful for /(?=abcde).+/. We can't set firstbyte
+                 for an assertion, however because it leads to incorrect effect for patterns
+                 such as /(?=a)a.+/ when the "real" "a" would then become a reqbyte instead
+                 of a firstbyte. This is overcome by a scan at the end if there's no
+                 firstbyte, looking for an asserted first char. */
+                
+                else if (bravalue == OP_ASSERT && subreqbyte >= 0)
+                    reqbyte = subreqbyte;
+                
+                /* Now update the main code pointer to the end of the group. */
+                
+                code = tempcode;
+                
+                /* Error if hit end of pattern */
+                
+                if (ptr >= patternEnd || *ptr != ')') {
+                    *errorcodeptr = ERR14;
+                    goto FAILED;
+                }
+                break;
+                
+            /* Check \ for being a real metacharacter; if not, fall through and handle
+             it as a data character at the start of a string. Escape items are checked
+             for validity in the pre-compiling pass. */
+                
+            case '\\':
+                tempptr = ptr;
+                c = checkEscape(&ptr, patternEnd, errorcodeptr, cd.numCapturingBrackets, false);
+                
+                /* Handle metacharacters introduced by \. For ones like \d, the ESC_ values
+                 are arranged to be the negation of the corresponding OP_values. For the
+                 back references, the values are ESC_REF plus the reference number. Only
+                 back references and those types that consume a character may be repeated.
+                 We can test for values between ESC_b and ESC_w for the latter; this may
+                 have to change if any new ones are ever created. */
+                
+                if (c < 0) {
+                    /* For metasequences that actually match a character, we disable the
+                     setting of a first character if it hasn't already been set. */
+                    
+                    if (firstbyte == REQ_UNSET && -c > ESC_b && -c <= ESC_w)
+                        firstbyte = REQ_NONE;
+                    
+                    /* Set values to reset to if this is followed by a zero repeat. */
+                    
+                    zerofirstbyte = firstbyte;
+                    zeroreqbyte = reqbyte;
+                    
+                    /* Back references are handled specially */
+                    
+                    if (-c >= ESC_REF) {
+                        int number = -c - ESC_REF;
+                        previous = code;
+                        *code++ = OP_REF;
+                        put2ByteValueAndAdvance(code, number);
+                    }
+                    
+                    /* For the rest, we can obtain the OP value by negating the escape
+                     value */
+                    
+                    else {
+                        previous = (-c > ESC_b && -c <= ESC_w) ? code : NULL;
+                        *code++ = -c;
+                    }
+                    continue;
+                }
+                
+                /* Fall through. */
+                
+                /* Handle a literal character. It is guaranteed not to be whitespace or #
+                 when the extended flag is set. If we are in UTF-8 mode, it may be a
+                 multi-byte literal character. */
+                
+                default:
+            NORMAL_CHAR:
+                
+                previous = code;
+                
+                if (c < 128) {
+                    mclength = 1;
+                    mcbuffer[0] = c;
+                    
+                    if ((options & IgnoreCaseOption) && (c | 0x20) >= 'a' && (c | 0x20) <= 'z') {
+                        *code++ = OP_ASCII_LETTER_IGNORING_CASE;
+                        *code++ = c | 0x20;
+                    } else {
+                        *code++ = OP_ASCII_CHAR;
+                        *code++ = c;
+                    }
+                } else {
+                    mclength = encodeUTF8(c, mcbuffer);
+                    
+                    *code++ = (options & IgnoreCaseOption) ? OP_CHAR_IGNORING_CASE : OP_CHAR;
+                    for (c = 0; c < mclength; c++)
+                        *code++ = mcbuffer[c];
+                }
+                
+                /* Set the first and required bytes appropriately. If no previous first
+                 byte, set it from this character, but revert to none on a zero repeat.
+                 Otherwise, leave the firstbyte value alone, and don't change it on a zero
+                 repeat. */
+                
+                if (firstbyte == REQ_UNSET) {
+                    zerofirstbyte = REQ_NONE;
+                    zeroreqbyte = reqbyte;
+                    
+                    /* If the character is more than one byte long, we can set firstbyte
+                     only if it is not to be matched caselessly. */
+                    
+                    if (mclength == 1 || req_caseopt == 0) {
+                        firstbyte = mcbuffer[0] | req_caseopt;
+                        if (mclength != 1)
+                            reqbyte = code[-1] | cd.req_varyopt;
+                    }
+                    else
+                        firstbyte = reqbyte = REQ_NONE;
+                }
+                
+                /* firstbyte was previously set; we can set reqbyte only the length is
+                 1 or the matching is caseful. */
+                
+                else {
+                    zerofirstbyte = firstbyte;
+                    zeroreqbyte = reqbyte;
+                    if (mclength == 1 || req_caseopt == 0)
+                        reqbyte = code[-1] | req_caseopt | cd.req_varyopt;
+                }
+                
+                break;            /* End of literal character handling */
+        }
+    }                   /* end of big loop */
+    
+    /* Control never reaches here by falling through, only by a goto for all the
+     error states. Pass back the position in the pattern so that it can be displayed
+     to the user for diagnosing the error. */
+    
+FAILED:
+    *ptrptr = ptr;
+    return false;
+}
+
+/*************************************************
+*     Compile sequence of alternatives           *
+*************************************************/
+
+/* On entry, ptr is pointing past the bracket character, but on return
+it points to the closing bracket, or vertical bar, or end of string.
+The code variable is pointing at the byte into which the BRA operator has been
+stored. If the ims options are changed at the start (for a (?ims: group) or
+during any branch, we need to insert an OP_OPT item at the start of every
+following branch to ensure they get set correctly at run time, and also pass
+the new options into every subsequent branch compile.
+
+Argument:
+  options        option bits, including any changes for this subpattern
+  brackets       -> int containing the number of extracting brackets used
+  codeptr        -> the address of the current code pointer
+  ptrptr         -> the address of the current pattern pointer
+  errorcodeptr   -> pointer to error code variable
+  skipbytes      skip this many bytes at start (for OP_BRANUMBER)
+  firstbyteptr   place to put the first required character, or a negative number
+  reqbyteptr     place to put the last required character, or a negative number
+  cd             points to the data block with tables pointers etc.
+
+Returns:      true on success
+*/
+
+static bool
+compileBracket(int options, int* brackets, unsigned char** codeptr,
+    const UChar** ptrptr, const UChar* patternEnd, ErrorCode* errorcodeptr, int skipbytes,
+    int* firstbyteptr, int* reqbyteptr, CompileData& cd)
+{
+    const UChar* ptr = *ptrptr;
+    unsigned char* code = *codeptr;
+    unsigned char* last_branch = code;
+    unsigned char* start_bracket = code;
+    int firstbyte = REQ_UNSET;
+    int reqbyte = REQ_UNSET;
+    
+    /* Offset is set zero to mark that this bracket is still open */
+    
+    putLinkValueAllowZero(code + 1, 0);
+    code += 1 + LINK_SIZE + skipbytes;
+    
+    /* Loop for each alternative branch */
+    
+    while (true) {
+        /* Now compile the branch */
+        
+        int branchfirstbyte;
+        int branchreqbyte;
+        if (!compileBranch(options, brackets, &code, &ptr, patternEnd, errorcodeptr,
+                            &branchfirstbyte, &branchreqbyte, cd)) {
+            *ptrptr = ptr;
+            return false;
+        }
+        
+        /* If this is the first branch, the firstbyte and reqbyte values for the
+         branch become the values for the regex. */
+        
+        if (*last_branch != OP_ALT) {
+            firstbyte = branchfirstbyte;
+            reqbyte = branchreqbyte;
+        }
+        
+        /* If this is not the first branch, the first char and reqbyte have to
+         match the values from all the previous branches, except that if the previous
+         value for reqbyte didn't have REQ_VARY set, it can still match, and we set
+         REQ_VARY for the regex. */
+        
+        else {
+            /* If we previously had a firstbyte, but it doesn't match the new branch,
+             we have to abandon the firstbyte for the regex, but if there was previously
+             no reqbyte, it takes on the value of the old firstbyte. */
+            
+            if (firstbyte >= 0 && firstbyte != branchfirstbyte) {
+                if (reqbyte < 0)
+                    reqbyte = firstbyte;
+                firstbyte = REQ_NONE;
+            }
+            
+            /* If we (now or from before) have no firstbyte, a firstbyte from the
+             branch becomes a reqbyte if there isn't a branch reqbyte. */
+            
+            if (firstbyte < 0 && branchfirstbyte >= 0 && branchreqbyte < 0)
+                branchreqbyte = branchfirstbyte;
+            
+            /* Now ensure that the reqbytes match */
+            
+            if ((reqbyte & ~REQ_VARY) != (branchreqbyte & ~REQ_VARY))
+                reqbyte = REQ_NONE;
+            else
+                reqbyte |= branchreqbyte;   /* To "or" REQ_VARY */
+        }
+        
+        /* Reached end of expression, either ')' or end of pattern. Go back through
+         the alternative branches and reverse the chain of offsets, with the field in
+         the BRA item now becoming an offset to the first alternative. If there are
+         no alternatives, it points to the end of the group. The length in the
+         terminating ket is always the length of the whole bracketed item. If any of
+         the ims options were changed inside the group, compile a resetting op-code
+         following, except at the very end of the pattern. Return leaving the pointer
+         at the terminating char. */
+        
+        if (ptr >= patternEnd || *ptr != '|') {
+            int length = code - last_branch;
+            do {
+                int prev_length = getLinkValueAllowZero(last_branch + 1);
+                putLinkValue(last_branch + 1, length);
+                length = prev_length;
+                last_branch -= length;
+            } while (length > 0);
+            
+            /* Fill in the ket */
+            
+            *code = OP_KET;
+            putLinkValue(code + 1, code - start_bracket);
+            code += 1 + LINK_SIZE;
+            
+            /* Set values to pass back */
+            
+            *codeptr = code;
+            *ptrptr = ptr;
+            *firstbyteptr = firstbyte;
+            *reqbyteptr = reqbyte;
+            return true;
+        }
+        
+        /* Another branch follows; insert an "or" node. Its length field points back
+         to the previous branch while the bracket remains open. At the end the chain
+         is reversed. It's done like this so that the start of the bracket has a
+         zero offset until it is closed, making it possible to detect recursion. */
+        
+        *code = OP_ALT;
+        putLinkValue(code + 1, code - last_branch);
+        last_branch = code;
+        code += 1 + LINK_SIZE;
+        ptr++;
+    }
+    ASSERT_NOT_REACHED();
+}
+
+/*************************************************
+*          Check for anchored expression         *
+*************************************************/
+
+/* Try to find out if this is an anchored regular expression. Consider each
+alternative branch. If they all start OP_CIRC, or with a bracket
+all of whose alternatives start OP_CIRC (recurse ad lib), then
+it's anchored.
+
+Arguments:
+  code          points to start of expression (the bracket)
+  captureMap    a bitmap of which brackets we are inside while testing; this
+                 handles up to substring 31; all brackets after that share
+                 the zero bit
+  backrefMap    the back reference bitmap
+*/
+
+static bool branchIsAnchored(const unsigned char* code)
+{
+    const unsigned char* scode = firstSignificantOpcode(code);
+    int op = *scode;
+
+    /* Brackets */
+    if (op >= OP_BRA || op == OP_ASSERT)
+        return bracketIsAnchored(scode);
+
+    /* Check for explicit anchoring */    
+    return op == OP_CIRC;
+}
+
+static bool bracketIsAnchored(const unsigned char* code)
+{
+    do {
+        if (!branchIsAnchored(code + 1 + LINK_SIZE))
+            return false;
+        code += getLinkValue(code + 1);
+    } while (*code == OP_ALT);   /* Loop for each alternative */
+    return true;
+}
+
+/*************************************************
+*         Check for starting with ^ or .*        *
+*************************************************/
+
+/* This is called to find out if every branch starts with ^ or .* so that
+"first char" processing can be done to speed things up in multiline
+matching and for non-DOTALL patterns that start with .* (which must start at
+the beginning or after \n)
+
+Except when the .* appears inside capturing parentheses, and there is a
+subsequent back reference to those parentheses. By keeping a bitmap of the
+first 31 back references, we can catch some of the more common cases more
+precisely; all the greater back references share a single bit.
+
+Arguments:
+  code          points to start of expression (the bracket)
+  captureMap    a bitmap of which brackets we are inside while testing; this
+                 handles up to substring 31; all brackets after that share
+                 the zero bit
+  backrefMap    the back reference bitmap
+*/
+
+static bool branchNeedsLineStart(const unsigned char* code, unsigned captureMap, unsigned backrefMap)
+{
+    const unsigned char* scode = firstSignificantOpcode(code);
+    int op = *scode;
+    
+    /* Capturing brackets */
+    if (op > OP_BRA) {
+        int captureNum = op - OP_BRA;
+        if (captureNum > EXTRACT_BASIC_MAX)
+            captureNum = get2ByteValue(scode + 2 + LINK_SIZE);
+        int bracketMask = (captureNum < 32) ? (1 << captureNum) : 1;
+        return bracketNeedsLineStart(scode, captureMap | bracketMask, backrefMap);
+    }
+    
+    /* Other brackets */
+    if (op == OP_BRA || op == OP_ASSERT)
+        return bracketNeedsLineStart(scode, captureMap, backrefMap);
+    
+    /* .* means "start at start or after \n" if it isn't in brackets that
+     may be referenced. */
+    
+    if (op == OP_TYPESTAR || op == OP_TYPEMINSTAR)
+        return scode[1] == OP_NOT_NEWLINE && !(captureMap & backrefMap);
+
+    /* Explicit ^ */
+    return op == OP_CIRC || op == OP_BOL;
+}
+
+static bool bracketNeedsLineStart(const unsigned char* code, unsigned captureMap, unsigned backrefMap)
+{
+    do {
+        if (!branchNeedsLineStart(code + 1 + LINK_SIZE, captureMap, backrefMap))
+            return false;
+        code += getLinkValue(code + 1);
+    } while (*code == OP_ALT);  /* Loop for each alternative */
+    return true;
+}
+
+/*************************************************
+*       Check for asserted fixed first char      *
+*************************************************/
+
+/* During compilation, the "first char" settings from forward assertions are
+discarded, because they can cause conflicts with actual literals that follow.
+However, if we end up without a first char setting for an unanchored pattern,
+it is worth scanning the regex to see if there is an initial asserted first
+char. If all branches start with the same asserted char, or with a bracket all
+of whose alternatives start with the same asserted char (recurse ad lib), then
+we return that char, otherwise -1.
+
+Arguments:
+  code       points to start of expression (the bracket)
+  options    pointer to the options (used to check casing changes)
+  inassert   true if in an assertion
+
+Returns:     -1 or the fixed first char
+*/
+
+static int branchFindFirstAssertedCharacter(const unsigned char* code, bool inassert)
+{
+    const unsigned char* scode = firstSignificantOpcodeSkippingAssertions(code);
+    int op = *scode;
+    
+    if (op >= OP_BRA)
+        op = OP_BRA;
+    
+    switch (op) {
+        default:
+            return -1;
+            
+        case OP_BRA:
+        case OP_ASSERT:
+            return bracketFindFirstAssertedCharacter(scode, op == OP_ASSERT);
+
+        case OP_EXACT:
+            scode += 2;
+            /* Fall through */
+
+        case OP_CHAR:
+        case OP_CHAR_IGNORING_CASE:
+        case OP_ASCII_CHAR:
+        case OP_ASCII_LETTER_IGNORING_CASE:
+        case OP_PLUS:
+        case OP_MINPLUS:
+            if (!inassert)
+                return -1;
+            return scode[1];
+    }
+}
+
+static int bracketFindFirstAssertedCharacter(const unsigned char* code, bool inassert)
+{
+    int c = -1;
+    do {
+        int d = branchFindFirstAssertedCharacter(code + 1 + LINK_SIZE, inassert);
+        if (d < 0)
+            return -1;
+        if (c < 0)
+            c = d;
+        else if (c != d)
+            return -1;
+        code += getLinkValue(code + 1);
+    } while (*code == OP_ALT);
+    return c;
+}
+
+static inline int multiplyWithOverflowCheck(int a, int b)
+{
+    if (!a || !b)
+        return 0;
+    if (a > MAX_PATTERN_SIZE / b)
+        return -1;
+    return a * b;
+}
+
+static int calculateCompiledPatternLength(const UChar* pattern, int patternLength, JSRegExpIgnoreCaseOption ignoreCase,
+    CompileData& cd, ErrorCode& errorcode)
+{
+    /* Make a pass over the pattern to compute the
+     amount of store required to hold the compiled code. This does not have to be
+     perfect as long as errors are overestimates. */
+
+    if (patternLength > MAX_PATTERN_SIZE) {
+        errorcode = ERR16;
+        return -1;
+    }
+
+    int length = 1 + LINK_SIZE;      /* For initial BRA plus length */
+    int branch_extra = 0;
+    int lastitemlength = 0;
+    unsigned brastackptr = 0;
+    int brastack[BRASTACK_SIZE];
+    unsigned char bralenstack[BRASTACK_SIZE];
+    int bracount = 0;
+    
+    const UChar* ptr = (const UChar*)(pattern - 1);
+    const UChar* patternEnd = (const UChar*)(pattern + patternLength);
+    
+    while (++ptr < patternEnd) {
+        int minRepeats = 0, maxRepeats = 0;
+        int c = *ptr;
+
+        switch (c) {
+            /* A backslashed item may be an escaped data character or it may be a
+             character type. */
+
+            case '\\':
+                c = checkEscape(&ptr, patternEnd, &errorcode, cd.numCapturingBrackets, false);
+                if (errorcode != 0)
+                    return -1;
+                
+                lastitemlength = 1;     /* Default length of last item for repeats */
+                
+                if (c >= 0) {            /* Data character */
+                    length += 2;          /* For a one-byte character */
+                    
+                    if (c > 127) {
+                        int i;
+                        for (i = 0; i < kjs_pcre_utf8_table1_size; i++)
+                            if (c <= kjs_pcre_utf8_table1[i]) break;
+                        length += i;
+                        lastitemlength += i;
+                    }
+                    
+                    continue;
+                }
+                
+                /* Other escapes need one byte */
+                
+                length++;
+                
+                /* A back reference needs an additional 2 bytes, plus either one or 5
+                 bytes for a repeat. We also need to keep the value of the highest
+                 back reference. */
+                
+                if (c <= -ESC_REF) {
+                    int refnum = -c - ESC_REF;
+                    cd.backrefMap |= (refnum < 32) ? (1 << refnum) : 1;
+                    if (refnum > cd.top_backref)
+                        cd.top_backref = refnum;
+                    length += 2;   /* For single back reference */
+                    if (safelyCheckNextChar(ptr, patternEnd, '{') && isCountedRepeat(ptr + 2, patternEnd)) {
+                        ptr = readRepeatCounts(ptr + 2, &minRepeats, &maxRepeats, &errorcode);
+                        if (errorcode)
+                            return -1;
+                        if ((minRepeats == 0 && (maxRepeats == 1 || maxRepeats == -1)) ||
+                            (minRepeats == 1 && maxRepeats == -1))
+                            length++;
+                        else
+                            length += 5;
+                        if (safelyCheckNextChar(ptr, patternEnd, '?'))
+                            ptr++;
+                    }
+                }
+                continue;
+                
+            case '^':     /* Single-byte metacharacters */
+            case '.':
+            case '$':
+                length++;
+                lastitemlength = 1;
+                continue;
+                
+            case '*':            /* These repeats won't be after brackets; */
+            case '+':            /* those are handled separately */
+            case '?':
+                length++;
+                goto POSSESSIVE;
+                
+            /* This covers the cases of braced repeats after a single char, metachar,
+             class, or back reference. */
+
+            case '{':
+                if (!isCountedRepeat(ptr + 1, patternEnd))
+                    goto NORMAL_CHAR;
+                ptr = readRepeatCounts(ptr + 1, &minRepeats, &maxRepeats, &errorcode);
+                if (errorcode != 0)
+                    return -1;
+                
+                /* These special cases just insert one extra opcode */
+                
+                if ((minRepeats == 0 && (maxRepeats == 1 || maxRepeats == -1)) ||
+                    (minRepeats == 1 && maxRepeats == -1))
+                    length++;
+                
+                /* These cases might insert additional copies of a preceding character. */
+                
+                else {
+                    if (minRepeats != 1) {
+                        length -= lastitemlength;   /* Uncount the original char or metachar */
+                        if (minRepeats > 0)
+                            length += 3 + lastitemlength;
+                    }
+                    length += lastitemlength + ((maxRepeats > 0) ? 3 : 1);
+                }
+                
+                if (safelyCheckNextChar(ptr, patternEnd, '?'))
+                    ptr++;      /* Needs no extra length */
+
+            POSSESSIVE:                     /* Test for possessive quantifier */
+                if (safelyCheckNextChar(ptr, patternEnd, '+')) {
+                    ptr++;
+                    length += 2 + 2 * LINK_SIZE;   /* Allow for atomic brackets */
+                }
+                continue;
+                
+            /* An alternation contains an offset to the next branch or ket. If any ims
+             options changed in the previous branch(es), and/or if we are in a
+             lookbehind assertion, extra space will be needed at the start of the
+             branch. This is handled by branch_extra. */
+                
+            case '|':
+                if (brastackptr == 0)
+                    cd.needOuterBracket = true;
+                length += 1 + LINK_SIZE + branch_extra;
+                continue;
+                
+            /* A character class uses 33 characters provided that all the character
+             values are less than 256. Otherwise, it uses a bit map for low valued
+             characters, and individual items for others. Don't worry about character
+             types that aren't allowed in classes - they'll get picked up during the
+             compile. A character class that contains only one single-byte character
+             uses 2 or 3 bytes, depending on whether it is negated or not. Notice this
+             where we can. (In UTF-8 mode we can do this only for chars < 128.) */
+                
+            case '[': {
+                int class_optcount;
+                if (*(++ptr) == '^') {
+                    class_optcount = 10;  /* Greater than one */
+                    ptr++;
+                }
+                else
+                    class_optcount = 0;
+                
+                bool class_utf8 = false;
+                
+                for (; ptr < patternEnd && *ptr != ']'; ++ptr) {
+                    /* Check for escapes */
+                    
+                    if (*ptr == '\\') {
+                        c = checkEscape(&ptr, patternEnd, &errorcode, cd.numCapturingBrackets, true);
+                        if (errorcode != 0)
+                            return -1;
+                        
+                        /* Handle escapes that turn into characters */
+                        
+                        if (c >= 0)
+                            goto NON_SPECIAL_CHARACTER;
+                        
+                        /* Escapes that are meta-things. The normal ones just affect the
+                         bit map, but Unicode properties require an XCLASS extended item. */
+                        
+                        else
+                            class_optcount = 10;         /* \d, \s etc; make sure > 1 */
+                    }
+                    
+                    /* Anything else increments the possible optimization count. We have to
+                     detect ranges here so that we can compute the number of extra ranges for
+                     caseless wide characters when UCP support is available. If there are wide
+                     characters, we are going to have to use an XCLASS, even for single
+                     characters. */
+                    
+                    else {
+                        c = *ptr;
+                        
+                        /* Come here from handling \ above when it escapes to a char value */
+                        
+                    NON_SPECIAL_CHARACTER:
+                        class_optcount++;
+                        
+                        int d = -1;
+                        if (safelyCheckNextChar(ptr, patternEnd, '-')) {
+                            UChar const *hyptr = ptr++;
+                            if (safelyCheckNextChar(ptr, patternEnd, '\\')) {
+                                ptr++;
+                                d = checkEscape(&ptr, patternEnd, &errorcode, cd.numCapturingBrackets, true);
+                                if (errorcode != 0)
+                                    return -1;
+                            }
+                            else if ((ptr + 1 < patternEnd) && ptr[1] != ']')
+                                d = *++ptr;
+                            if (d < 0)
+                                ptr = hyptr;      /* go back to hyphen as data */
+                        }
+                        
+                        /* If d >= 0 we have a range. In UTF-8 mode, if the end is > 255, or >
+                         127 for caseless matching, we will need to use an XCLASS. */
+                        
+                        if (d >= 0) {
+                            class_optcount = 10;     /* Ensure > 1 */
+                            if (d < c) {
+                                errorcode = ERR8;
+                                return -1;
+                            }
+                            
+                            if ((d > 255 || (ignoreCase && d > 127))) {
+                                unsigned char buffer[6];
+                                if (!class_utf8)         /* Allow for XCLASS overhead */
+                                {
+                                    class_utf8 = true;
+                                    length += LINK_SIZE + 2;
+                                }
+                                
+                                /* If we have UCP support, find out how many extra ranges are
+                                 needed to map the other case of characters within this range. We
+                                 have to mimic the range optimization here, because extending the
+                                 range upwards might push d over a boundary that makes it use
+                                 another byte in the UTF-8 representation. */
+                                
+                                if (ignoreCase) {
+                                    int occ, ocd;
+                                    int cc = c;
+                                    int origd = d;
+                                    while (getOthercaseRange(&cc, origd, &occ, &ocd)) {
+                                        if (occ >= c && ocd <= d)
+                                            continue;   /* Skip embedded */
+                                        
+                                        if (occ < c  && ocd >= c - 1)  /* Extend the basic range */
+                                        {                            /* if there is overlap,   */
+                                            c = occ;                     /* noting that if occ < c */
+                                            continue;                    /* we can't have ocd > d  */
+                                        }                            /* because a subrange is  */
+                                        if (ocd > d && occ <= d + 1)   /* always shorter than    */
+                                        {                            /* the basic range.       */
+                                            d = ocd;
+                                            continue;
+                                        }
+                                        
+                                        /* An extra item is needed */
+                                        
+                                        length += 1 + encodeUTF8(occ, buffer) +
+                                        ((occ == ocd) ? 0 : encodeUTF8(ocd, buffer));
+                                    }
+                                }
+                                
+                                /* The length of the (possibly extended) range */
+                                
+                                length += 1 + encodeUTF8(c, buffer) + encodeUTF8(d, buffer);
+                            }
+                            
+                        }
+                        
+                        /* We have a single character. There is nothing to be done unless we
+                         are in UTF-8 mode. If the char is > 255, or 127 when caseless, we must
+                         allow for an XCL_SINGLE item, doubled for caselessness if there is UCP
+                         support. */
+                        
+                        else {
+                            if ((c > 255 || (ignoreCase && c > 127))) {
+                                unsigned char buffer[6];
+                                class_optcount = 10;     /* Ensure > 1 */
+                                if (!class_utf8)         /* Allow for XCLASS overhead */
+                                {
+                                    class_utf8 = true;
+                                    length += LINK_SIZE + 2;
+                                }
+                                length += (ignoreCase ? 2 : 1) * (1 + encodeUTF8(c, buffer));
+                            }
+                        }
+                    }
+                }
+                
+                if (ptr >= patternEnd) {   /* Missing terminating ']' */
+                    errorcode = ERR6;
+                    return -1;
+                }
+                
+                /* We can optimize when there was only one optimizable character.
+                 Note that this does not detect the case of a negated single character.
+                 In that case we do an incorrect length computation, but it's not a serious
+                 problem because the computed length is too large rather than too small. */
+
+                if (class_optcount == 1)
+                    goto NORMAL_CHAR;
+
+                /* Here, we handle repeats for the class opcodes. */
+                {
+                    length += 33;
+                    
+                    /* A repeat needs either 1 or 5 bytes. If it is a possessive quantifier,
+                     we also need extra for wrapping the whole thing in a sub-pattern. */
+                    
+                    if (safelyCheckNextChar(ptr, patternEnd, '{') && isCountedRepeat(ptr + 2, patternEnd)) {
+                        ptr = readRepeatCounts(ptr + 2, &minRepeats, &maxRepeats, &errorcode);
+                        if (errorcode != 0)
+                            return -1;
+                        if ((minRepeats == 0 && (maxRepeats == 1 || maxRepeats == -1)) ||
+                            (minRepeats == 1 && maxRepeats == -1))
+                            length++;
+                        else
+                            length += 5;
+                        if (safelyCheckNextChar(ptr, patternEnd, '+')) {
+                            ptr++;
+                            length += 2 + 2 * LINK_SIZE;
+                        } else if (safelyCheckNextChar(ptr, patternEnd, '?'))
+                            ptr++;
+                    }
+                }
+                continue;
+            }
+
+            /* Brackets may be genuine groups or special things */
+                
+            case '(': {
+                int branch_newextra = 0;
+                int bracket_length = 1 + LINK_SIZE;
+                bool capturing = false;
+                
+                /* Handle special forms of bracket, which all start (? */
+                
+                if (safelyCheckNextChar(ptr, patternEnd, '?')) {
+                    switch (c = (ptr + 2 < patternEnd ? ptr[2] : 0)) {
+                        /* Non-referencing groups and lookaheads just move the pointer on, and
+                         then behave like a non-special bracket, except that they don't increment
+                         the count of extracting brackets. Ditto for the "once only" bracket,
+                         which is in Perl from version 5.005. */
+                            
+                        case ':':
+                        case '=':
+                        case '!':
+                            ptr += 2;
+                            break;
+                            
+                        /* Else loop checking valid options until ) is met. Anything else is an
+                         error. If we are without any brackets, i.e. at top level, the settings
+                         act as if specified in the options, so massage the options immediately.
+                         This is for backward compatibility with Perl 5.004. */
+                            
+                        default:
+                            errorcode = ERR12;
+                            return -1;
+                    }
+                } else
+                    capturing = 1;
+                
+                /* Capturing brackets must be counted so we can process escapes in a
+                 Perlish way. If the number exceeds EXTRACT_BASIC_MAX we are going to need
+                 an additional 3 bytes of memory per capturing bracket. */
+                
+                if (capturing) {
+                    bracount++;
+                    if (bracount > EXTRACT_BASIC_MAX)
+                        bracket_length += 3;
+                }
+                
+                /* Save length for computing whole length at end if there's a repeat that
+                 requires duplication of the group. Also save the current value of
+                 branch_extra, and start the new group with the new value. If non-zero, this
+                 will either be 2 for a (?imsx: group, or 3 for a lookbehind assertion. */
+                
+                if (brastackptr >= sizeof(brastack)/sizeof(int)) {
+                    errorcode = ERR17;
+                    return -1;
+                }
+                
+                bralenstack[brastackptr] = branch_extra;
+                branch_extra = branch_newextra;
+                
+                brastack[brastackptr++] = length;
+                length += bracket_length;
+                continue;
+            }
+
+            /* Handle ket. Look for subsequent maxRepeats/minRepeats; for certain sets of values we
+             have to replicate this bracket up to that many times. If brastackptr is
+             0 this is an unmatched bracket which will generate an error, but take care
+             not to try to access brastack[-1] when computing the length and restoring
+             the branch_extra value. */
+
+            case ')': {
+                int duplength;
+                length += 1 + LINK_SIZE;
+                if (brastackptr > 0) {
+                    duplength = length - brastack[--brastackptr];
+                    branch_extra = bralenstack[brastackptr];
+                }
+                else
+                    duplength = 0;
+                
+                /* Leave ptr at the final char; for readRepeatCounts this happens
+                 automatically; for the others we need an increment. */
+                
+                if ((ptr + 1 < patternEnd) && (c = ptr[1]) == '{' && isCountedRepeat(ptr + 2, patternEnd)) {
+                    ptr = readRepeatCounts(ptr + 2, &minRepeats, &maxRepeats, &errorcode);
+                    if (errorcode)
+                        return -1;
+                } else if (c == '*') {
+                    minRepeats = 0;
+                    maxRepeats = -1;
+                    ptr++;
+                } else if (c == '+') {
+                    minRepeats = 1;
+                    maxRepeats = -1;
+                    ptr++;
+                } else if (c == '?') {
+                    minRepeats = 0;
+                    maxRepeats = 1;
+                    ptr++;
+                } else {
+                    minRepeats = 1;
+                    maxRepeats = 1;
+                }
+                
+                /* If the minimum is zero, we have to allow for an OP_BRAZERO before the
+                 group, and if the maximum is greater than zero, we have to replicate
+                 maxval-1 times; each replication acquires an OP_BRAZERO plus a nesting
+                 bracket set. */
+                
+                int repeatsLength;
+                if (minRepeats == 0) {
+                    length++;
+                    if (maxRepeats > 0) {
+                        repeatsLength = multiplyWithOverflowCheck(maxRepeats - 1, duplength + 3 + 2 * LINK_SIZE);
+                        if (repeatsLength < 0) {
+                            errorcode = ERR16;
+                            return -1;
+                        }
+                        length += repeatsLength;
+                        if (length > MAX_PATTERN_SIZE) {
+                            errorcode = ERR16;
+                            return -1;
+                        }
+                    }
+                }
+                
+                /* When the minimum is greater than zero, we have to replicate up to
+                 minval-1 times, with no additions required in the copies. Then, if there
+                 is a limited maximum we have to replicate up to maxval-1 times allowing
+                 for a BRAZERO item before each optional copy and nesting brackets for all
+                 but one of the optional copies. */
+                
+                else {
+                    repeatsLength = multiplyWithOverflowCheck(minRepeats - 1, duplength);
+                    if (repeatsLength < 0) {
+                        errorcode = ERR16;
+                        return -1;
+                    }
+                    length += repeatsLength;
+                    if (maxRepeats > minRepeats) { /* Need this test as maxRepeats=-1 means no limit */
+                        repeatsLength = multiplyWithOverflowCheck(maxRepeats - minRepeats, duplength + 3 + 2 * LINK_SIZE);
+                        if (repeatsLength < 0) {
+                            errorcode = ERR16;
+                            return -1;
+                        }
+                        length += repeatsLength - (2 + 2 * LINK_SIZE);
+                    }
+                    if (length > MAX_PATTERN_SIZE) {
+                        errorcode = ERR16;
+                        return -1;
+                    }
+                }
+                
+                /* Allow space for once brackets for "possessive quantifier" */
+                
+                if (safelyCheckNextChar(ptr, patternEnd, '+')) {
+                    ptr++;
+                    length += 2 + 2 * LINK_SIZE;
+                }
+                continue;
+            }
+
+            /* Non-special character. It won't be space or # in extended mode, so it is
+             always a genuine character. If we are in a \Q...\E sequence, check for the
+             end; if not, we have a literal. */
+                
+            default:
+            NORMAL_CHAR:
+                length += 2;          /* For a one-byte character */
+                lastitemlength = 1;   /* Default length of last item for repeats */
+
+                if (c > 127) {
+                    int i;
+                    for (i = 0; i < kjs_pcre_utf8_table1_size; i++)
+                        if (c <= kjs_pcre_utf8_table1[i])
+                            break;
+                    length += i;
+                    lastitemlength += i;
+                }
+                
+                continue;
+        }
+    }
+    
+    length += 2 + LINK_SIZE;    /* For final KET and END */
+
+    cd.numCapturingBrackets = bracount;
+    return length;
+}
+
+/*************************************************
+*        Compile a Regular Expression            *
+*************************************************/
+
+/* This function takes a string and returns a pointer to a block of store
+holding a compiled version of the expression. The original API for this
+function had no error code return variable; it is retained for backwards
+compatibility. The new function is given a new name.
+
+Arguments:
+  pattern       the regular expression
+  options       various option bits
+  errorcodeptr  pointer to error code variable (pcre_compile2() only)
+                  can be NULL if you don't want a code value
+  errorptr      pointer to pointer to error text
+  erroroffset   ptr offset in pattern where error was detected
+  tables        pointer to character tables or NULL
+
+Returns:        pointer to compiled data block, or NULL on error,
+                with errorptr and erroroffset set
+*/
+
+static inline JSRegExp* returnError(ErrorCode errorcode, const char** errorptr)
+{
+    *errorptr = errorText(errorcode);
+    return 0;
+}
+
+JSRegExp* jsRegExpCompile(const UChar* pattern, int patternLength,
+                JSRegExpIgnoreCaseOption ignoreCase, JSRegExpMultilineOption multiline,
+                unsigned* numSubpatterns, const char** errorptr,
+                malloc_t* allocate_function, free_t* free_function)
+{
+    /* We can't pass back an error message if errorptr is NULL; I guess the best we
+     can do is just return NULL, but we can set a code value if there is a code pointer. */
+    if (!errorptr)
+        return 0;
+    *errorptr = NULL;
+    
+    CompileData cd;
+    
+    ErrorCode errorcode = ERR0;
+    /* Call this once just to count the brackets. */
+    calculateCompiledPatternLength(pattern, patternLength, ignoreCase, cd, errorcode);
+    /* Call it again to compute the length. */
+    int length = calculateCompiledPatternLength(pattern, patternLength, ignoreCase, cd, errorcode);
+    if (errorcode)
+        return returnError(errorcode, errorptr);
+    
+    if (length > MAX_PATTERN_SIZE)
+        return returnError(ERR16, errorptr);
+    
+    size_t size = length + sizeof(JSRegExp);
+    JSRegExp* re = reinterpret_cast<JSRegExp*>((*allocate_function)(size));
+    
+    if (!re)
+        return returnError(ERR13, errorptr);
+    
+    re->options = (ignoreCase ? IgnoreCaseOption : 0) | (multiline ? MatchAcrossMultipleLinesOption : 0);
+    
+    /* The starting points of the name/number translation table and of the code are
+     passed around in the compile data block. */
+    
+    const unsigned char* codeStart = (const unsigned char*)(re + 1);
+    
+    /* Set up a starting, non-extracting bracket, then compile the expression. On
+     error, errorcode will be set non-zero, so we don't need to look at the result
+     of the function here. */
+    
+    const UChar* ptr = (const UChar*)pattern;
+    const UChar* patternEnd = pattern + patternLength;
+    unsigned char* code = (unsigned char*)codeStart;
+    int firstbyte, reqbyte;
+    int bracketCount = 0;
+    if (!cd.needOuterBracket)
+        compileBranch(re->options, &bracketCount, &code, &ptr, patternEnd, &errorcode, &firstbyte, &reqbyte, cd);
+    else {
+        *code = OP_BRA;
+        compileBracket(re->options, &bracketCount, &code, &ptr, patternEnd, &errorcode, 0, &firstbyte, &reqbyte, cd);
+    }
+    re->top_bracket = bracketCount;
+    re->top_backref = cd.top_backref;
+    
+    /* If not reached end of pattern on success, there's an excess bracket. */
+    
+    if (errorcode == 0 && ptr < patternEnd)
+        errorcode = ERR10;
+    
+    /* Fill in the terminating state and check for disastrous overflow, but
+     if debugging, leave the test till after things are printed out. */
+    
+    *code++ = OP_END;
+
+    ASSERT(code - codeStart <= length);
+    if (code - codeStart > length)
+        errorcode = ERR7;
+    
+    /* Give an error if there's back reference to a non-existent capturing
+     subpattern. */
+    
+    if (re->top_backref > re->top_bracket)
+        errorcode = ERR15;
+    
+    /* Failed to compile, or error while post-processing */
+    
+    if (errorcode != ERR0) {
+        (*free_function)(reinterpret_cast<void*>(re));
+        return returnError(errorcode, errorptr);
+    }
+    
+    /* If the anchored option was not passed, set the flag if we can determine that
+     the pattern is anchored by virtue of ^ characters or \A or anything else (such
+     as starting with .* when DOTALL is set).
+     
+     Otherwise, if we know what the first character has to be, save it, because that
+     speeds up unanchored matches no end. If not, see if we can set the
+     UseMultiLineFirstByteOptimizationOption flag. This is helpful for multiline matches when all branches
+     start with ^. and also when all branches start with .* for non-DOTALL matches.
+     */
+    
+    if (cd.needOuterBracket ? bracketIsAnchored(codeStart) : branchIsAnchored(codeStart))
+        re->options |= IsAnchoredOption;
+    else {
+        if (firstbyte < 0) {
+            firstbyte = (cd.needOuterBracket
+                    ? bracketFindFirstAssertedCharacter(codeStart, false)
+                    : branchFindFirstAssertedCharacter(codeStart, false))
+                | ((re->options & IgnoreCaseOption) ? REQ_IGNORE_CASE : 0);
+        }
+        if (firstbyte >= 0) {
+            int ch = firstbyte & 255;
+            if (ch < 127) {
+                re->first_byte = ((firstbyte & REQ_IGNORE_CASE) && flipCase(ch) == ch) ? ch : firstbyte;
+                re->options |= UseFirstByteOptimizationOption;
+            }
+        } else {
+            if (cd.needOuterBracket ? bracketNeedsLineStart(codeStart, 0, cd.backrefMap) : branchNeedsLineStart(codeStart, 0, cd.backrefMap))
+                re->options |= UseMultiLineFirstByteOptimizationOption;
+        }
+    }
+    
+    /* For an anchored pattern, we use the "required byte" only if it follows a
+     variable length item in the regex. Remove the caseless flag for non-caseable
+     bytes. */
+    
+    if (reqbyte >= 0 && (!(re->options & IsAnchoredOption) || (reqbyte & REQ_VARY))) {
+        int ch = reqbyte & 255;
+        if (ch < 127) {
+            re->req_byte = ((reqbyte & REQ_IGNORE_CASE) && flipCase(ch) == ch) ? (reqbyte & ~REQ_IGNORE_CASE) : reqbyte;
+            re->options |= UseRequiredByteOptimizationOption;
+        }
+    }
+    
+    if (numSubpatterns)
+        *numSubpatterns = re->top_bracket;
+    return re;
+}
+
+void jsRegExpFree(JSRegExp* re, free_t* free_function)
+{
+    (*free_function)(reinterpret_cast<void*>(re));
+}
+
+} // namespace jscre
diff --git a/plugin/jscre/JSRegExp_exec.cpp b/plugin/jscre/JSRegExp_exec.cpp
new file mode 100644
index 0000000..3771001
--- /dev/null
+++ b/plugin/jscre/JSRegExp_exec.cpp
@@ -0,0 +1,2085 @@
+/* This is JavaScriptCore's variant of the PCRE library. While this library
+started out as a copy of PCRE, many of the features of PCRE have been
+removed. This library now supports only the regular expression features
+required by the JavaScript language specification, and has only the functions
+needed by JavaScriptCore and the rest of WebKit.
+
+                 Originally written by Philip Hazel
+           Copyright (c) 1997-2006 University of Cambridge
+    Copyright (C) 2002, 2004, 2006, 2007 Apple Inc. All rights reserved.
+    Copyright (C) 2007 Eric Seidel <eric@webkit.org>
+
+-----------------------------------------------------------------------------
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+    * Neither the name of the University of Cambridge nor the names of its
+      contributors may be used to endorse or promote products derived from
+      this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+-----------------------------------------------------------------------------
+*/
+
+/* This module contains jsRegExpExecute(), the externally visible function
+that does pattern matching using an NFA algorithm, following the rules from
+the JavaScript specification. There are also some supporting functions. */
+
+#include "config.h"
+
+#include "JSRegExp_internal.h"
+
+#include "ASCIICType.h"
+
+#include <ctype.h>
+#include <limits.h>
+#include <string.h> /* for memcpy */
+
+#ifdef __GNUC__
+#define USE_COMPUTED_GOTO_FOR_MATCH_RECURSION
+//#define USE_COMPUTED_GOTO_FOR_MATCH_OPCODE_LOOP
+#endif
+
+/* Avoid warnings on Windows. */
+#undef min
+#undef max
+
+namespace jscre {
+
+#ifndef USE_COMPUTED_GOTO_FOR_MATCH_RECURSION
+typedef int ReturnLocation;
+#else
+typedef void* ReturnLocation;
+#endif
+
+/* Structure for building a chain of data for holding the values of
+the subject pointer at the start of each bracket, used to detect when
+an empty string has been matched by a bracket to break infinite loops. */ 
+struct BracketChainNode {
+    BracketChainNode* previousBracket;
+    const UChar* bracketStart;
+};
+
+struct MatchFrame {
+    ReturnLocation returnLocation;
+    struct MatchFrame* previousFrame;
+    
+    /* Function arguments that may change */
+    struct {
+        const UChar* subjectPtr;
+        const unsigned char* instructionPtr;
+        int offsetTop;
+        BracketChainNode* bracketChain;
+    } args;
+    
+    
+    /* PCRE uses "fake" recursion built off of gotos, thus
+     stack-based local variables are not safe to use.  Instead we have to
+     store local variables on the current MatchFrame. */
+    struct {
+        const unsigned char* data;
+        const unsigned char* startOfRepeatingBracket;
+        const UChar* subjectPtrAtStartOfInstruction; // Several instrutions stash away a subjectPtr here for later compare
+        const unsigned char* instructionPtrAtStartOfOnce;
+        
+        int repeatOthercase;
+        
+        int ctype;
+        int fc;
+        int fi;
+        int length;
+        int max;
+        int number;
+        int offset;
+        int saveOffset1;
+        int saveOffset2;
+        int saveOffset3;
+        
+        BracketChainNode bracketChainNode;
+    } locals;
+};
+
+/* Structure for passing "static" information around between the functions
+doing traditional NFA matching, so that they are thread-safe. */
+
+struct MatchData {
+  int*   offsetVector;         /* Offset vector */
+  int    offsetEnd;            /* One past the end */
+  int    offsetMax;            /* The maximum usable for return data */
+  bool   offsetOverflow;       /* Set if too many extractions */
+  const UChar*  startSubject;         /* Start of the subject string */
+  const UChar*  endSubject;           /* End of the subject string */
+  const UChar*  endMatchPtr;         /* Subject position at end match */
+  int    endOffsetTop;        /* Highwater mark at end of match */
+  bool   multiline;
+  bool   ignoreCase;
+};
+
+/* The maximum remaining length of subject we are prepared to search for a
+req_byte match. */
+
+#define REQ_BYTE_MAX 1000
+
+/* The below limit restricts the number of "recursive" match calls in order to
+avoid spending exponential time on complex regular expressions. */
+
+static const unsigned matchLimit = 100000;
+
+#ifdef DEBUG
+/*************************************************
+*        Debugging function to print chars       *
+*************************************************/
+
+/* Print a sequence of chars in printable format, stopping at the end of the
+subject if the requested.
+
+Arguments:
+  p           points to characters
+  length      number to print
+  isSubject  true if printing from within md.startSubject
+  md          pointer to matching data block, if isSubject is true
+*/
+
+static void pchars(const UChar* p, int length, bool isSubject, const MatchData& md)
+{
+    if (isSubject && length > md.endSubject - p)
+        length = md.endSubject - p;
+    while (length-- > 0) {
+        int c;
+        if (isprint(c = *(p++)))
+            printf("%c", c);
+        else if (c < 256)
+            printf("\\x%02x", c);
+        else
+            printf("\\x{%x}", c);
+    }
+}
+#endif
+
+/*************************************************
+*          Match a back-reference                *
+*************************************************/
+
+/* If a back reference hasn't been set, the length that is passed is greater
+than the number of characters left in the string, so the match fails.
+
+Arguments:
+  offset      index into the offset vector
+  subjectPtr        points into the subject
+  length      length to be matched
+  md          points to match data block
+
+Returns:      true if matched
+*/
+
+static bool matchRef(int offset, const UChar* subjectPtr, int length, const MatchData& md)
+{
+    const UChar* p = md.startSubject + md.offsetVector[offset];
+    
+#ifdef DEBUG
+    if (subjectPtr >= md.endSubject)
+        printf("matching subject <null>");
+    else {
+        printf("matching subject ");
+        pchars(subjectPtr, length, true, md);
+    }
+    printf(" against backref ");
+    pchars(p, length, false, md);
+    printf("\n");
+#endif
+    
+    /* Always fail if not enough characters left */
+    
+    if (length > md.endSubject - subjectPtr)
+        return false;
+    
+    /* Separate the caselesss case for speed */
+    
+    if (md.ignoreCase) {
+        while (length-- > 0) {
+            UChar c = *p++;
+            int othercase = kjs_pcre_ucp_othercase(c);
+            UChar d = *subjectPtr++;
+            if (c != d && othercase != d)
+                return false;
+        }
+    }
+    else {
+        while (length-- > 0)
+            if (*p++ != *subjectPtr++)
+                return false;
+    }
+    
+    return true;
+}
+
+#ifndef USE_COMPUTED_GOTO_FOR_MATCH_RECURSION
+
+/* Use numbered labels and switch statement at the bottom of the match function. */
+
+#define RMATCH_WHERE(num) num
+#define RRETURN_LABEL RRETURN_SWITCH
+
+#else
+
+/* Use GCC's computed goto extension. */
+
+/* For one test case this is more than 40% faster than the switch statement.
+We could avoid the use of the num argument entirely by using local labels,
+but using it for the GCC case as well as the non-GCC case allows us to share
+a bit more code and notice if we use conflicting numbers.*/
+
+#define RMATCH_WHERE(num) &&RRETURN_##num
+#define RRETURN_LABEL *stack.currentFrame->returnLocation
+
+#endif
+
+#define RECURSIVE_MATCH_COMMON(num) \
+    goto RECURSE;\
+    RRETURN_##num: \
+    stack.popCurrentFrame();
+
+#define RECURSIVE_MATCH(num, ra, rb) \
+    do { \
+        stack.pushNewFrame((ra), (rb), RMATCH_WHERE(num)); \
+        RECURSIVE_MATCH_COMMON(num) \
+    } while (0)
+
+#define RECURSIVE_MATCH_STARTNG_NEW_GROUP(num, ra, rb) \
+    do { \
+        stack.pushNewFrame((ra), (rb), RMATCH_WHERE(num)); \
+        startNewGroup(stack.currentFrame); \
+        RECURSIVE_MATCH_COMMON(num) \
+    } while (0)
+
+#define RRETURN goto RRETURN_LABEL
+
+#define RRETURN_NO_MATCH do { isMatch = false; RRETURN; } while (0)
+
+/*************************************************
+*         Match from current position            *
+*************************************************/
+
+/* On entry instructionPtr points to the first opcode, and subjectPtr to the first character
+in the subject string, while substringStart holds the value of subjectPtr at the start of the
+last bracketed group - used for breaking infinite loops matching zero-length
+strings. This function is called recursively in many circumstances. Whenever it
+returns a negative (error) response, the outer match() call must also return the
+same response.
+
+Arguments:
+   subjectPtr        pointer in subject
+   instructionPtr       position in code
+   offsetTop  current top pointer
+   md          pointer to "static" info for the match
+
+Returns:       1 if matched          )  these values are >= 0
+               0 if failed to match  )
+               a negative error value if aborted by an error condition
+                 (e.g. stopped by repeated call or recursion limit)
+*/
+
+static const unsigned FRAMES_ON_STACK = 16;
+
+struct MatchStack {
+    MatchStack()
+        : framesEnd(frames + FRAMES_ON_STACK)
+        , currentFrame(frames)
+        , size(1) // match() creates accesses the first frame w/o calling pushNewFrame
+    {
+        ASSERT((sizeof(frames) / sizeof(frames[0])) == FRAMES_ON_STACK);
+    }
+    
+    MatchFrame frames[FRAMES_ON_STACK];
+    MatchFrame* framesEnd;
+    MatchFrame* currentFrame;
+    unsigned size;
+    
+    inline bool canUseStackBufferForNextFrame()
+    {
+        return size < FRAMES_ON_STACK;
+    }
+    
+    inline MatchFrame* allocateNextFrame()
+    {
+        if (canUseStackBufferForNextFrame())
+            return currentFrame + 1;
+        return new MatchFrame;
+    }
+    
+    inline void pushNewFrame(const unsigned char* instructionPtr, BracketChainNode* bracketChain, ReturnLocation returnLocation)
+    {
+        MatchFrame* newframe = allocateNextFrame();
+        newframe->previousFrame = currentFrame;
+
+        newframe->args.subjectPtr = currentFrame->args.subjectPtr;
+        newframe->args.offsetTop = currentFrame->args.offsetTop;
+        newframe->args.instructionPtr = instructionPtr;
+        newframe->args.bracketChain = bracketChain;
+        newframe->returnLocation = returnLocation;
+        size++;
+
+        currentFrame = newframe;
+    }
+    
+    inline void popCurrentFrame()
+    {
+        MatchFrame* oldFrame = currentFrame;
+        currentFrame = currentFrame->previousFrame;
+        if (size > FRAMES_ON_STACK)
+            delete oldFrame;
+        size--;
+    }
+
+    void popAllFrames()
+    {
+        while (size)
+            popCurrentFrame();
+    }
+};
+
+static int matchError(int errorCode, MatchStack& stack)
+{
+    stack.popAllFrames();
+    return errorCode;
+}
+
+/* Get the next UTF-8 character, not advancing the pointer, incrementing length
+ if there are extra bytes. This is called when we know we are in UTF-8 mode. */
+
+static inline void getUTF8CharAndIncrementLength(int& c, const unsigned char* subjectPtr, int& len)
+{
+    c = *subjectPtr;
+    if ((c & 0xc0) == 0xc0) {
+        int gcaa = kjs_pcre_utf8_table4[c & 0x3f];  /* Number of additional bytes */
+        int gcss = 6 * gcaa;
+        c = (c & kjs_pcre_utf8_table3[gcaa]) << gcss;
+        for (int gcii = 1; gcii <= gcaa; gcii++) {
+            gcss -= 6;
+            c |= (subjectPtr[gcii] & 0x3f) << gcss;
+        }
+        len += gcaa;
+    }
+}
+
+static inline void startNewGroup(MatchFrame* currentFrame)
+{
+    /* At the start of a bracketed group, add the current subject pointer to the
+     stack of such pointers, to be re-instated at the end of the group when we hit
+     the closing ket. When match() is called in other circumstances, we don't add to
+     this stack. */
+    
+    currentFrame->locals.bracketChainNode.previousBracket = currentFrame->args.bracketChain;
+    currentFrame->locals.bracketChainNode.bracketStart = currentFrame->args.subjectPtr;
+    currentFrame->args.bracketChain = &currentFrame->locals.bracketChainNode;
+}
+
+// FIXME: "minimize" means "not greedy", we should invert the callers to ask for "greedy" to be less confusing
+static inline void repeatInformationFromInstructionOffset(short instructionOffset, bool& minimize, int& minimumRepeats, int& maximumRepeats)
+{
+    // Instruction offsets are based off of OP_CRSTAR, OP_STAR, OP_TYPESTAR, OP_NOTSTAR
+    static const char minimumRepeatsFromInstructionOffset[] = { 0, 0, 1, 1, 0, 0 };
+    static const int maximumRepeatsFromInstructionOffset[] = { INT_MAX, INT_MAX, INT_MAX, INT_MAX, 1, 1 };
+
+    ASSERT(instructionOffset >= 0);
+    ASSERT(instructionOffset <= (OP_CRMINQUERY - OP_CRSTAR));
+
+    minimize = (instructionOffset & 1); // this assumes ordering: Instruction, MinimizeInstruction, Instruction2, MinimizeInstruction2
+    minimumRepeats = minimumRepeatsFromInstructionOffset[instructionOffset];
+    maximumRepeats = maximumRepeatsFromInstructionOffset[instructionOffset];
+}
+
+static int match(const UChar* subjectPtr, const unsigned char* instructionPtr, int offsetTop, MatchData& md)
+{
+    bool isMatch = false;
+    int min;
+    bool minimize = false; /* Initialization not really needed, but some compilers think so. */
+    unsigned matchCount = 0;
+    
+    MatchStack stack;
+
+    /* The opcode jump table. */
+#ifdef USE_COMPUTED_GOTO_FOR_MATCH_OPCODE_LOOP
+#define EMIT_JUMP_TABLE_ENTRY(opcode) &&LABEL_OP_##opcode,
+    static void* opcodeJumpTable[256] = { FOR_EACH_OPCODE(EMIT_JUMP_TABLE_ENTRY) };
+#undef EMIT_JUMP_TABLE_ENTRY
+#endif
+    
+    /* One-time setup of the opcode jump table. */
+#ifdef USE_COMPUTED_GOTO_FOR_MATCH_OPCODE_LOOP
+    for (int i = 255; !opcodeJumpTable[i]; i--)
+        opcodeJumpTable[i] = &&CAPTURING_BRACKET;
+#endif
+    
+#ifdef USE_COMPUTED_GOTO_FOR_MATCH_RECURSION
+    // Shark shows this as a hot line
+    // Using a static const here makes this line disappear, but makes later access hotter (not sure why)
+    stack.currentFrame->returnLocation = &&RETURN;
+#else
+    stack.currentFrame->returnLocation = 0;
+#endif
+    stack.currentFrame->args.subjectPtr = subjectPtr;
+    stack.currentFrame->args.instructionPtr = instructionPtr;
+    stack.currentFrame->args.offsetTop = offsetTop;
+    stack.currentFrame->args.bracketChain = 0;
+    startNewGroup(stack.currentFrame);
+    
+    /* This is where control jumps back to to effect "recursion" */
+    
+RECURSE:
+    if (++matchCount > matchLimit)
+        return matchError(JSRegExpErrorHitLimit, stack);
+
+    /* Now start processing the operations. */
+    
+#ifndef USE_COMPUTED_GOTO_FOR_MATCH_OPCODE_LOOP
+    while (true)
+#endif
+    {
+        
+#ifdef USE_COMPUTED_GOTO_FOR_MATCH_OPCODE_LOOP
+#define BEGIN_OPCODE(opcode) LABEL_OP_##opcode
+#define NEXT_OPCODE goto *opcodeJumpTable[*stack.currentFrame->args.instructionPtr]
+#else
+#define BEGIN_OPCODE(opcode) case OP_##opcode
+#define NEXT_OPCODE continue
+#endif
+        
+#ifdef USE_COMPUTED_GOTO_FOR_MATCH_OPCODE_LOOP
+        NEXT_OPCODE;
+#else
+        switch (*stack.currentFrame->args.instructionPtr)
+#endif
+        {
+            /* Non-capturing bracket: optimized */
+                
+            BEGIN_OPCODE(BRA):
+            NON_CAPTURING_BRACKET:
+                DPRINTF(("start bracket 0\n"));
+                do {
+                    RECURSIVE_MATCH_STARTNG_NEW_GROUP(2, stack.currentFrame->args.instructionPtr + 1 + LINK_SIZE, stack.currentFrame->args.bracketChain);
+                    if (isMatch)
+                        RRETURN;
+                    stack.currentFrame->args.instructionPtr += getLinkValue(stack.currentFrame->args.instructionPtr + 1);
+                } while (*stack.currentFrame->args.instructionPtr == OP_ALT);
+                DPRINTF(("bracket 0 failed\n"));
+                RRETURN;
+                
+            /* Skip over large extraction number data if encountered. */
+                
+            BEGIN_OPCODE(BRANUMBER):
+                stack.currentFrame->args.instructionPtr += 3;
+                NEXT_OPCODE;
+                
+            /* End of the pattern. */
+                
+            BEGIN_OPCODE(END):
+                md.endMatchPtr = stack.currentFrame->args.subjectPtr;          /* Record where we ended */
+                md.endOffsetTop = stack.currentFrame->args.offsetTop;   /* and how many extracts were taken */
+                isMatch = true;
+                RRETURN;
+                
+            /* Assertion brackets. Check the alternative branches in turn - the
+             matching won't pass the KET for an assertion. If any one branch matches,
+             the assertion is true. Lookbehind assertions have an OP_REVERSE item at the
+             start of each branch to move the current point backwards, so the code at
+             this level is identical to the lookahead case. */
+                
+            BEGIN_OPCODE(ASSERT):
+                do {
+                    RECURSIVE_MATCH_STARTNG_NEW_GROUP(6, stack.currentFrame->args.instructionPtr + 1 + LINK_SIZE, NULL);
+                    if (isMatch)
+                        break;
+                    stack.currentFrame->args.instructionPtr += getLinkValue(stack.currentFrame->args.instructionPtr + 1);
+                } while (*stack.currentFrame->args.instructionPtr == OP_ALT);
+                if (*stack.currentFrame->args.instructionPtr == OP_KET)
+                    RRETURN_NO_MATCH;
+                
+                /* Continue from after the assertion, updating the offsets high water
+                 mark, since extracts may have been taken during the assertion. */
+                
+                advanceToEndOfBracket(stack.currentFrame->args.instructionPtr);
+                stack.currentFrame->args.instructionPtr += 1 + LINK_SIZE;
+                stack.currentFrame->args.offsetTop = md.endOffsetTop;
+                NEXT_OPCODE;
+                
+            /* Negative assertion: all branches must fail to match */
+                
+            BEGIN_OPCODE(ASSERT_NOT):
+                do {
+                    RECURSIVE_MATCH_STARTNG_NEW_GROUP(7, stack.currentFrame->args.instructionPtr + 1 + LINK_SIZE, NULL);
+                    if (isMatch)
+                        RRETURN_NO_MATCH;
+                    stack.currentFrame->args.instructionPtr += getLinkValue(stack.currentFrame->args.instructionPtr + 1);
+                } while (*stack.currentFrame->args.instructionPtr == OP_ALT);
+                
+                stack.currentFrame->args.instructionPtr += 1 + LINK_SIZE;
+                NEXT_OPCODE;
+                
+            /* An alternation is the end of a branch; scan along to find the end of the
+             bracketed group and go to there. */
+                
+            BEGIN_OPCODE(ALT):
+                advanceToEndOfBracket(stack.currentFrame->args.instructionPtr);
+                NEXT_OPCODE;
+                
+            /* BRAZERO and BRAMINZERO occur just before a bracket group, indicating
+             that it may occur zero times. It may repeat infinitely, or not at all -
+             i.e. it could be ()* or ()? in the pattern. Brackets with fixed upper
+             repeat limits are compiled as a number of copies, with the optional ones
+             preceded by BRAZERO or BRAMINZERO. */
+                
+            BEGIN_OPCODE(BRAZERO): {
+                stack.currentFrame->locals.startOfRepeatingBracket = stack.currentFrame->args.instructionPtr + 1;
+                RECURSIVE_MATCH_STARTNG_NEW_GROUP(14, stack.currentFrame->locals.startOfRepeatingBracket, stack.currentFrame->args.bracketChain);
+                if (isMatch)
+                    RRETURN;
+                advanceToEndOfBracket(stack.currentFrame->locals.startOfRepeatingBracket);
+                stack.currentFrame->args.instructionPtr = stack.currentFrame->locals.startOfRepeatingBracket + 1 + LINK_SIZE;
+                NEXT_OPCODE;
+            }
+                
+            BEGIN_OPCODE(BRAMINZERO): {
+                stack.currentFrame->locals.startOfRepeatingBracket = stack.currentFrame->args.instructionPtr + 1;
+                advanceToEndOfBracket(stack.currentFrame->locals.startOfRepeatingBracket);
+                RECURSIVE_MATCH_STARTNG_NEW_GROUP(15, stack.currentFrame->locals.startOfRepeatingBracket + 1 + LINK_SIZE, stack.currentFrame->args.bracketChain);
+                if (isMatch)
+                    RRETURN;
+                stack.currentFrame->args.instructionPtr++;
+                NEXT_OPCODE;
+            }
+                
+            /* End of a group, repeated or non-repeating. If we are at the end of
+             an assertion "group", stop matching and return 1, but record the
+             current high water mark for use by positive assertions. Do this also
+             for the "once" (not-backup up) groups. */
+                
+            BEGIN_OPCODE(KET):
+            BEGIN_OPCODE(KETRMIN):
+            BEGIN_OPCODE(KETRMAX):
+                stack.currentFrame->locals.instructionPtrAtStartOfOnce = stack.currentFrame->args.instructionPtr - getLinkValue(stack.currentFrame->args.instructionPtr + 1);
+                stack.currentFrame->locals.subjectPtrAtStartOfInstruction = stack.currentFrame->args.bracketChain->bracketStart;
+
+                /* Back up the stack of bracket start pointers. */
+
+                stack.currentFrame->args.bracketChain = stack.currentFrame->args.bracketChain->previousBracket;
+
+                if (*stack.currentFrame->locals.instructionPtrAtStartOfOnce == OP_ASSERT || *stack.currentFrame->locals.instructionPtrAtStartOfOnce == OP_ASSERT_NOT) {
+                    md.endOffsetTop = stack.currentFrame->args.offsetTop;
+                    isMatch = true;
+                    RRETURN;
+                }
+                
+                /* In all other cases except a conditional group we have to check the
+                 group number back at the start and if necessary complete handling an
+                 extraction by setting the offsets and bumping the high water mark. */
+                
+                stack.currentFrame->locals.number = *stack.currentFrame->locals.instructionPtrAtStartOfOnce - OP_BRA;
+                
+                /* For extended extraction brackets (large number), we have to fish out
+                 the number from a dummy opcode at the start. */
+                
+                if (stack.currentFrame->locals.number > EXTRACT_BASIC_MAX)
+                    stack.currentFrame->locals.number = get2ByteValue(stack.currentFrame->locals.instructionPtrAtStartOfOnce + 2 + LINK_SIZE);
+                stack.currentFrame->locals.offset = stack.currentFrame->locals.number << 1;
+                
+#ifdef DEBUG
+                printf("end bracket %d", stack.currentFrame->locals.number);
+                printf("\n");
+#endif
+                
+                /* Test for a numbered group. This includes groups called as a result
+                 of recursion. Note that whole-pattern recursion is coded as a recurse
+                 into group 0, so it won't be picked up here. Instead, we catch it when
+                 the OP_END is reached. */
+                
+                if (stack.currentFrame->locals.number > 0) {
+                    if (stack.currentFrame->locals.offset >= md.offsetMax)
+                        md.offsetOverflow = true;
+                    else {
+                        md.offsetVector[stack.currentFrame->locals.offset] =
+                        md.offsetVector[md.offsetEnd - stack.currentFrame->locals.number];
+                        md.offsetVector[stack.currentFrame->locals.offset+1] = stack.currentFrame->args.subjectPtr - md.startSubject;
+                        if (stack.currentFrame->args.offsetTop <= stack.currentFrame->locals.offset)
+                            stack.currentFrame->args.offsetTop = stack.currentFrame->locals.offset + 2;
+                    }
+                }
+                
+                /* For a non-repeating ket, just continue at this level. This also
+                 happens for a repeating ket if no characters were matched in the group.
+                 This is the forcible breaking of infinite loops as implemented in Perl
+                 5.005. If there is an options reset, it will get obeyed in the normal
+                 course of events. */
+                
+                if (*stack.currentFrame->args.instructionPtr == OP_KET || stack.currentFrame->args.subjectPtr == stack.currentFrame->locals.subjectPtrAtStartOfInstruction) {
+                    stack.currentFrame->args.instructionPtr += 1 + LINK_SIZE;
+                    NEXT_OPCODE;
+                }
+                
+                /* The repeating kets try the rest of the pattern or restart from the
+                 preceding bracket, in the appropriate order. */
+                
+                if (*stack.currentFrame->args.instructionPtr == OP_KETRMIN) {
+                    RECURSIVE_MATCH(16, stack.currentFrame->args.instructionPtr + 1 + LINK_SIZE, stack.currentFrame->args.bracketChain);
+                    if (isMatch)
+                        RRETURN;
+                    RECURSIVE_MATCH_STARTNG_NEW_GROUP(17, stack.currentFrame->locals.instructionPtrAtStartOfOnce, stack.currentFrame->args.bracketChain);
+                    if (isMatch)
+                        RRETURN;
+                } else { /* OP_KETRMAX */
+                    RECURSIVE_MATCH_STARTNG_NEW_GROUP(18, stack.currentFrame->locals.instructionPtrAtStartOfOnce, stack.currentFrame->args.bracketChain);
+                    if (isMatch)
+                        RRETURN;
+                    RECURSIVE_MATCH(19, stack.currentFrame->args.instructionPtr + 1 + LINK_SIZE, stack.currentFrame->args.bracketChain);
+                    if (isMatch)
+                        RRETURN;
+                }
+                RRETURN;
+                
+            /* Start of subject. */
+
+            BEGIN_OPCODE(CIRC):
+                if (stack.currentFrame->args.subjectPtr != md.startSubject)
+                    RRETURN_NO_MATCH;
+                stack.currentFrame->args.instructionPtr++;
+                NEXT_OPCODE;
+
+            /* After internal newline if multiline. */
+
+            BEGIN_OPCODE(BOL):
+                if (stack.currentFrame->args.subjectPtr != md.startSubject && !isNewline(stack.currentFrame->args.subjectPtr[-1]))
+                    RRETURN_NO_MATCH;
+                stack.currentFrame->args.instructionPtr++;
+                NEXT_OPCODE;
+
+            /* End of subject. */
+
+            BEGIN_OPCODE(DOLL):
+                if (stack.currentFrame->args.subjectPtr < md.endSubject)
+                    RRETURN_NO_MATCH;
+                stack.currentFrame->args.instructionPtr++;
+                NEXT_OPCODE;
+
+            /* Before internal newline if multiline. */
+
+            BEGIN_OPCODE(EOL):
+                if (stack.currentFrame->args.subjectPtr < md.endSubject && !isNewline(*stack.currentFrame->args.subjectPtr))
+                    RRETURN_NO_MATCH;
+                stack.currentFrame->args.instructionPtr++;
+                NEXT_OPCODE;
+                
+            /* Word boundary assertions */
+                
+            BEGIN_OPCODE(NOT_WORD_BOUNDARY):
+            BEGIN_OPCODE(WORD_BOUNDARY): {
+                bool currentCharIsWordChar = false;
+                bool previousCharIsWordChar = false;
+                
+                if (stack.currentFrame->args.subjectPtr > md.startSubject)
+                    previousCharIsWordChar = isWordChar(stack.currentFrame->args.subjectPtr[-1]);
+                if (stack.currentFrame->args.subjectPtr < md.endSubject)
+                    currentCharIsWordChar = isWordChar(*stack.currentFrame->args.subjectPtr);
+                
+                /* Now see if the situation is what we want */
+                bool wordBoundaryDesired = (*stack.currentFrame->args.instructionPtr++ == OP_WORD_BOUNDARY);
+                if (wordBoundaryDesired ? currentCharIsWordChar == previousCharIsWordChar : currentCharIsWordChar != previousCharIsWordChar)
+                    RRETURN_NO_MATCH;
+                NEXT_OPCODE;
+            }
+                
+            /* Match a single character type; inline for speed */
+                
+            BEGIN_OPCODE(NOT_NEWLINE):
+                if (stack.currentFrame->args.subjectPtr >= md.endSubject)
+                    RRETURN_NO_MATCH;
+                if (isNewline(*stack.currentFrame->args.subjectPtr++))
+                    RRETURN_NO_MATCH;
+                stack.currentFrame->args.instructionPtr++;
+                NEXT_OPCODE;
+
+            BEGIN_OPCODE(NOT_DIGIT):
+                if (stack.currentFrame->args.subjectPtr >= md.endSubject)
+                    RRETURN_NO_MATCH;
+                if (isASCIIDigit(*stack.currentFrame->args.subjectPtr++))
+                    RRETURN_NO_MATCH;
+                stack.currentFrame->args.instructionPtr++;
+                NEXT_OPCODE;
+
+            BEGIN_OPCODE(DIGIT):
+                if (stack.currentFrame->args.subjectPtr >= md.endSubject)
+                    RRETURN_NO_MATCH;
+                if (!isASCIIDigit(*stack.currentFrame->args.subjectPtr++))
+                    RRETURN_NO_MATCH;
+                stack.currentFrame->args.instructionPtr++;
+                NEXT_OPCODE;
+
+            BEGIN_OPCODE(NOT_WHITESPACE):
+                if (stack.currentFrame->args.subjectPtr >= md.endSubject)
+                    RRETURN_NO_MATCH;
+                if (isSpaceChar(*stack.currentFrame->args.subjectPtr++))
+                    RRETURN_NO_MATCH;
+                stack.currentFrame->args.instructionPtr++;
+                NEXT_OPCODE;
+
+            BEGIN_OPCODE(WHITESPACE):
+                if (stack.currentFrame->args.subjectPtr >= md.endSubject)
+                    RRETURN_NO_MATCH;
+                if (!isSpaceChar(*stack.currentFrame->args.subjectPtr++))
+                    RRETURN_NO_MATCH;
+                stack.currentFrame->args.instructionPtr++;
+                NEXT_OPCODE;
+                
+            BEGIN_OPCODE(NOT_WORDCHAR):
+                if (stack.currentFrame->args.subjectPtr >= md.endSubject)
+                    RRETURN_NO_MATCH;
+                if (isWordChar(*stack.currentFrame->args.subjectPtr++))
+                    RRETURN_NO_MATCH;
+                stack.currentFrame->args.instructionPtr++;
+                NEXT_OPCODE;
+                
+            BEGIN_OPCODE(WORDCHAR):
+                if (stack.currentFrame->args.subjectPtr >= md.endSubject)
+                    RRETURN_NO_MATCH;
+                if (!isWordChar(*stack.currentFrame->args.subjectPtr++))
+                    RRETURN_NO_MATCH;
+                stack.currentFrame->args.instructionPtr++;
+                NEXT_OPCODE;
+                
+            /* Match a back reference, possibly repeatedly. Look past the end of the
+             item to see if there is repeat information following. The code is similar
+             to that for character classes, but repeated for efficiency. Then obey
+             similar code to character type repeats - written out again for speed.
+             However, if the referenced string is the empty string, always treat
+             it as matched, any number of times (otherwise there could be infinite
+             loops). */
+                
+            BEGIN_OPCODE(REF):
+                stack.currentFrame->locals.offset = get2ByteValue(stack.currentFrame->args.instructionPtr + 1) << 1;               /* Doubled ref number */
+                stack.currentFrame->args.instructionPtr += 3;                                 /* Advance past item */
+                
+                /* If the reference is unset, set the length to be longer than the amount
+                 of subject left; this ensures that every attempt at a match fails. We
+                 can't just fail here, because of the possibility of quantifiers with zero
+                 minima. */
+                
+                if (stack.currentFrame->locals.offset >= stack.currentFrame->args.offsetTop || md.offsetVector[stack.currentFrame->locals.offset] < 0)
+                    stack.currentFrame->locals.length = 0;
+                else
+                    stack.currentFrame->locals.length = md.offsetVector[stack.currentFrame->locals.offset+1] - md.offsetVector[stack.currentFrame->locals.offset];
+                
+                /* Set up for repetition, or handle the non-repeated case */
+                
+                switch (*stack.currentFrame->args.instructionPtr) {
+                    case OP_CRSTAR:
+                    case OP_CRMINSTAR:
+                    case OP_CRPLUS:
+                    case OP_CRMINPLUS:
+                    case OP_CRQUERY:
+                    case OP_CRMINQUERY:
+                        repeatInformationFromInstructionOffset(*stack.currentFrame->args.instructionPtr++ - OP_CRSTAR, minimize, min, stack.currentFrame->locals.max);
+                        break;
+                        
+                    case OP_CRRANGE:
+                    case OP_CRMINRANGE:
+                        minimize = (*stack.currentFrame->args.instructionPtr == OP_CRMINRANGE);
+                        min = get2ByteValue(stack.currentFrame->args.instructionPtr + 1);
+                        stack.currentFrame->locals.max = get2ByteValue(stack.currentFrame->args.instructionPtr + 3);
+                        if (stack.currentFrame->locals.max == 0)
+                            stack.currentFrame->locals.max = INT_MAX;
+                        stack.currentFrame->args.instructionPtr += 5;
+                        break;
+                    
+                    default:               /* No repeat follows */
+                        if (!matchRef(stack.currentFrame->locals.offset, stack.currentFrame->args.subjectPtr, stack.currentFrame->locals.length, md))
+                            RRETURN_NO_MATCH;
+                        stack.currentFrame->args.subjectPtr += stack.currentFrame->locals.length;
+                        NEXT_OPCODE;
+                }
+                
+                /* If the length of the reference is zero, just continue with the
+                 main loop. */
+                
+                if (stack.currentFrame->locals.length == 0)
+                    NEXT_OPCODE;
+                
+                /* First, ensure the minimum number of matches are present. */
+                
+                for (int i = 1; i <= min; i++) {
+                    if (!matchRef(stack.currentFrame->locals.offset, stack.currentFrame->args.subjectPtr, stack.currentFrame->locals.length, md))
+                        RRETURN_NO_MATCH;
+                    stack.currentFrame->args.subjectPtr += stack.currentFrame->locals.length;
+                }
+                
+                /* If min = max, continue at the same level without recursion.
+                 They are not both allowed to be zero. */
+                
+                if (min == stack.currentFrame->locals.max)
+                    NEXT_OPCODE;
+                
+                /* If minimizing, keep trying and advancing the pointer */
+                
+                if (minimize) {
+                    for (stack.currentFrame->locals.fi = min;; stack.currentFrame->locals.fi++) {
+                        RECURSIVE_MATCH(20, stack.currentFrame->args.instructionPtr, stack.currentFrame->args.bracketChain);
+                        if (isMatch)
+                            RRETURN;
+                        if (stack.currentFrame->locals.fi >= stack.currentFrame->locals.max || !matchRef(stack.currentFrame->locals.offset, stack.currentFrame->args.subjectPtr, stack.currentFrame->locals.length, md))
+                            RRETURN;
+                        stack.currentFrame->args.subjectPtr += stack.currentFrame->locals.length;
+                    }
+                    /* Control never reaches here */
+                }
+                
+                /* If maximizing, find the longest string and work backwards */
+                
+                else {
+                    stack.currentFrame->locals.subjectPtrAtStartOfInstruction = stack.currentFrame->args.subjectPtr;
+                    for (int i = min; i < stack.currentFrame->locals.max; i++) {
+                        if (!matchRef(stack.currentFrame->locals.offset, stack.currentFrame->args.subjectPtr, stack.currentFrame->locals.length, md))
+                            break;
+                        stack.currentFrame->args.subjectPtr += stack.currentFrame->locals.length;
+                    }
+                    while (stack.currentFrame->args.subjectPtr >= stack.currentFrame->locals.subjectPtrAtStartOfInstruction) {
+                        RECURSIVE_MATCH(21, stack.currentFrame->args.instructionPtr, stack.currentFrame->args.bracketChain);
+                        if (isMatch)
+                            RRETURN;
+                        stack.currentFrame->args.subjectPtr -= stack.currentFrame->locals.length;
+                    }
+                    RRETURN_NO_MATCH;
+                }
+                /* Control never reaches here */
+                
+            /* Match a bit-mapped character class, possibly repeatedly. This op code is
+             used when all the characters in the class have values in the range 0-255,
+             and either the matching is caseful, or the characters are in the range
+             0-127 when UTF-8 processing is enabled. The only difference between
+             OP_CLASS and OP_NCLASS occurs when a data character outside the range is
+             encountered.
+             
+             First, look past the end of the item to see if there is repeat information
+             following. Then obey similar code to character type repeats - written out
+             again for speed. */
+                
+            BEGIN_OPCODE(NCLASS):
+            BEGIN_OPCODE(CLASS):
+                stack.currentFrame->locals.data = stack.currentFrame->args.instructionPtr + 1;                /* Save for matching */
+                stack.currentFrame->args.instructionPtr += 33;                     /* Advance past the item */
+                
+                switch (*stack.currentFrame->args.instructionPtr) {
+                    case OP_CRSTAR:
+                    case OP_CRMINSTAR:
+                    case OP_CRPLUS:
+                    case OP_CRMINPLUS:
+                    case OP_CRQUERY:
+                    case OP_CRMINQUERY:
+                        repeatInformationFromInstructionOffset(*stack.currentFrame->args.instructionPtr++ - OP_CRSTAR, minimize, min, stack.currentFrame->locals.max);
+                        break;
+                        
+                    case OP_CRRANGE:
+                    case OP_CRMINRANGE:
+                        minimize = (*stack.currentFrame->args.instructionPtr == OP_CRMINRANGE);
+                        min = get2ByteValue(stack.currentFrame->args.instructionPtr + 1);
+                        stack.currentFrame->locals.max = get2ByteValue(stack.currentFrame->args.instructionPtr + 3);
+                        if (stack.currentFrame->locals.max == 0)
+                            stack.currentFrame->locals.max = INT_MAX;
+                        stack.currentFrame->args.instructionPtr += 5;
+                        break;
+                        
+                    default:               /* No repeat follows */
+                        min = stack.currentFrame->locals.max = 1;
+                        break;
+                }
+                
+                /* First, ensure the minimum number of matches are present. */
+                
+                for (int i = 1; i <= min; i++) {
+                    if (stack.currentFrame->args.subjectPtr >= md.endSubject)
+                        RRETURN_NO_MATCH;
+                    int c = *stack.currentFrame->args.subjectPtr++;
+                    if (c > 255) {
+                        if (stack.currentFrame->locals.data[-1] == OP_CLASS)
+                            RRETURN_NO_MATCH;
+                    } else {
+                        if (!(stack.currentFrame->locals.data[c / 8] & (1 << (c & 7))))
+                            RRETURN_NO_MATCH;
+                    }
+                }
+                
+                /* If max == min we can continue with the main loop without the
+                 need to recurse. */
+                
+                if (min == stack.currentFrame->locals.max)
+                    NEXT_OPCODE;      
+                
+                /* If minimizing, keep testing the rest of the expression and advancing
+                 the pointer while it matches the class. */
+                if (minimize) {
+                    for (stack.currentFrame->locals.fi = min;; stack.currentFrame->locals.fi++) {
+                        RECURSIVE_MATCH(22, stack.currentFrame->args.instructionPtr, stack.currentFrame->args.bracketChain);
+                        if (isMatch)
+                            RRETURN;
+                        if (stack.currentFrame->locals.fi >= stack.currentFrame->locals.max || stack.currentFrame->args.subjectPtr >= md.endSubject)
+                            RRETURN;
+                        int c = *stack.currentFrame->args.subjectPtr++;
+                        if (c > 255) {
+                            if (stack.currentFrame->locals.data[-1] == OP_CLASS)
+                                RRETURN;
+                        } else {
+                            if ((stack.currentFrame->locals.data[c/8] & (1 << (c&7))) == 0)
+                                RRETURN;
+                        }
+                    }
+                    /* Control never reaches here */
+                }
+                /* If maximizing, find the longest possible run, then work backwards. */
+                else {
+                    stack.currentFrame->locals.subjectPtrAtStartOfInstruction = stack.currentFrame->args.subjectPtr;
+                    
+                    for (int i = min; i < stack.currentFrame->locals.max; i++) {
+                        if (stack.currentFrame->args.subjectPtr >= md.endSubject)
+                            break;
+                        int c = *stack.currentFrame->args.subjectPtr;
+                        if (c > 255) {
+                            if (stack.currentFrame->locals.data[-1] == OP_CLASS)
+                                break;
+                        } else {
+                            if (!(stack.currentFrame->locals.data[c / 8] & (1 << (c & 7))))
+                                break;
+                        }
+                        ++stack.currentFrame->args.subjectPtr;
+                    }
+                    for (;;) {
+                        RECURSIVE_MATCH(24, stack.currentFrame->args.instructionPtr, stack.currentFrame->args.bracketChain);
+                        if (isMatch)
+                            RRETURN;
+                        if (stack.currentFrame->args.subjectPtr-- == stack.currentFrame->locals.subjectPtrAtStartOfInstruction)
+                            break;        /* Stop if tried at original pos */
+                    }
+                    
+                    RRETURN;
+                }
+                /* Control never reaches here */
+                
+            /* Match an extended character class. */
+                
+            BEGIN_OPCODE(XCLASS):
+                stack.currentFrame->locals.data = stack.currentFrame->args.instructionPtr + 1 + LINK_SIZE;                /* Save for matching */
+                stack.currentFrame->args.instructionPtr += getLinkValue(stack.currentFrame->args.instructionPtr + 1);                      /* Advance past the item */
+                
+                switch (*stack.currentFrame->args.instructionPtr) {
+                    case OP_CRSTAR:
+                    case OP_CRMINSTAR:
+                    case OP_CRPLUS:
+                    case OP_CRMINPLUS:
+                    case OP_CRQUERY:
+                    case OP_CRMINQUERY:
+                        repeatInformationFromInstructionOffset(*stack.currentFrame->args.instructionPtr++ - OP_CRSTAR, minimize, min, stack.currentFrame->locals.max);
+                        break;
+                        
+                    case OP_CRRANGE:
+                    case OP_CRMINRANGE:
+                        minimize = (*stack.currentFrame->args.instructionPtr == OP_CRMINRANGE);
+                        min = get2ByteValue(stack.currentFrame->args.instructionPtr + 1);
+                        stack.currentFrame->locals.max = get2ByteValue(stack.currentFrame->args.instructionPtr + 3);
+                        if (stack.currentFrame->locals.max == 0)
+                            stack.currentFrame->locals.max = INT_MAX;
+                        stack.currentFrame->args.instructionPtr += 5;
+                        break;
+                        
+                    default:               /* No repeat follows */
+                        min = stack.currentFrame->locals.max = 1;
+                }
+                
+                /* First, ensure the minimum number of matches are present. */
+                
+                for (int i = 1; i <= min; i++) {
+                    if (stack.currentFrame->args.subjectPtr >= md.endSubject)
+                        RRETURN_NO_MATCH;
+                    int c = *stack.currentFrame->args.subjectPtr++;
+                    if (!kjs_pcre_xclass(c, stack.currentFrame->locals.data))
+                        RRETURN_NO_MATCH;
+                }
+                
+                /* If max == min we can continue with the main loop without the
+                 need to recurse. */
+                
+                if (min == stack.currentFrame->locals.max)
+                    NEXT_OPCODE;
+                
+                /* If minimizing, keep testing the rest of the expression and advancing
+                 the pointer while it matches the class. */
+                
+                if (minimize) {
+                    for (stack.currentFrame->locals.fi = min;; stack.currentFrame->locals.fi++) {
+                        RECURSIVE_MATCH(26, stack.currentFrame->args.instructionPtr, stack.currentFrame->args.bracketChain);
+                        if (isMatch)
+                            RRETURN;
+                        if (stack.currentFrame->locals.fi >= stack.currentFrame->locals.max || stack.currentFrame->args.subjectPtr >= md.endSubject)
+                            RRETURN;
+                        int c = *stack.currentFrame->args.subjectPtr++;
+                        if (!kjs_pcre_xclass(c, stack.currentFrame->locals.data))
+                            RRETURN;
+                    }
+                    /* Control never reaches here */
+                }
+                
+                /* If maximizing, find the longest possible run, then work backwards. */
+                
+                else {
+                    stack.currentFrame->locals.subjectPtrAtStartOfInstruction = stack.currentFrame->args.subjectPtr;
+                    for (int i = min; i < stack.currentFrame->locals.max; i++) {
+                        if (stack.currentFrame->args.subjectPtr >= md.endSubject)
+                            break;
+                        int c = *stack.currentFrame->args.subjectPtr;
+                        if (!kjs_pcre_xclass(c, stack.currentFrame->locals.data))
+                            break;
+                        ++stack.currentFrame->args.subjectPtr;
+                    }
+                    for(;;) {
+                        RECURSIVE_MATCH(27, stack.currentFrame->args.instructionPtr, stack.currentFrame->args.bracketChain);
+                        if (isMatch)
+                            RRETURN;
+                        if (stack.currentFrame->args.subjectPtr-- == stack.currentFrame->locals.subjectPtrAtStartOfInstruction)
+                            break;        /* Stop if tried at original pos */
+                    }
+                    RRETURN;
+                }
+                
+                /* Control never reaches here */
+                
+            /* Match a single character, casefully */
+                
+            BEGIN_OPCODE(CHAR):
+                stack.currentFrame->locals.length = 1;
+                stack.currentFrame->args.instructionPtr++;
+                getUTF8CharAndIncrementLength(stack.currentFrame->locals.fc, stack.currentFrame->args.instructionPtr, stack.currentFrame->locals.length);
+                stack.currentFrame->args.instructionPtr += stack.currentFrame->locals.length;
+                if (stack.currentFrame->args.subjectPtr >= md.endSubject)
+                    RRETURN_NO_MATCH;
+                if (stack.currentFrame->locals.fc != *stack.currentFrame->args.subjectPtr++)
+                    RRETURN_NO_MATCH;
+                NEXT_OPCODE;
+                
+            /* Match a single character, caselessly */
+                
+            BEGIN_OPCODE(CHAR_IGNORING_CASE): {
+                stack.currentFrame->locals.length = 1;
+                stack.currentFrame->args.instructionPtr++;
+                getUTF8CharAndIncrementLength(stack.currentFrame->locals.fc, stack.currentFrame->args.instructionPtr, stack.currentFrame->locals.length);
+                stack.currentFrame->args.instructionPtr += stack.currentFrame->locals.length;
+                if (stack.currentFrame->args.subjectPtr >= md.endSubject)
+                    RRETURN_NO_MATCH;
+                int dc = *stack.currentFrame->args.subjectPtr++;
+                if (stack.currentFrame->locals.fc != dc && kjs_pcre_ucp_othercase(stack.currentFrame->locals.fc) != dc)
+                    RRETURN_NO_MATCH;
+                NEXT_OPCODE;
+            }
+                
+            /* Match a single ASCII character. */
+                
+            BEGIN_OPCODE(ASCII_CHAR):
+                if (md.endSubject == stack.currentFrame->args.subjectPtr)
+                    RRETURN_NO_MATCH;
+                if (*stack.currentFrame->args.subjectPtr != stack.currentFrame->args.instructionPtr[1])
+                    RRETURN_NO_MATCH;
+                ++stack.currentFrame->args.subjectPtr;
+                stack.currentFrame->args.instructionPtr += 2;
+                NEXT_OPCODE;
+                
+            /* Match one of two cases of an ASCII letter. */
+                
+            BEGIN_OPCODE(ASCII_LETTER_IGNORING_CASE):
+                if (md.endSubject == stack.currentFrame->args.subjectPtr)
+                    RRETURN_NO_MATCH;
+                if ((*stack.currentFrame->args.subjectPtr | 0x20) != stack.currentFrame->args.instructionPtr[1])
+                    RRETURN_NO_MATCH;
+                ++stack.currentFrame->args.subjectPtr;
+                stack.currentFrame->args.instructionPtr += 2;
+                NEXT_OPCODE;
+                
+            /* Match a single character repeatedly; different opcodes share code. */
+                
+            BEGIN_OPCODE(EXACT):
+                min = stack.currentFrame->locals.max = get2ByteValue(stack.currentFrame->args.instructionPtr + 1);
+                minimize = false;
+                stack.currentFrame->args.instructionPtr += 3;
+                goto REPEATCHAR;
+                
+            BEGIN_OPCODE(UPTO):
+            BEGIN_OPCODE(MINUPTO):
+                min = 0;
+                stack.currentFrame->locals.max = get2ByteValue(stack.currentFrame->args.instructionPtr + 1);
+                minimize = *stack.currentFrame->args.instructionPtr == OP_MINUPTO;
+                stack.currentFrame->args.instructionPtr += 3;
+                goto REPEATCHAR;
+                
+            BEGIN_OPCODE(STAR):
+            BEGIN_OPCODE(MINSTAR):
+            BEGIN_OPCODE(PLUS):
+            BEGIN_OPCODE(MINPLUS):
+            BEGIN_OPCODE(QUERY):
+            BEGIN_OPCODE(MINQUERY):
+                repeatInformationFromInstructionOffset(*stack.currentFrame->args.instructionPtr++ - OP_STAR, minimize, min, stack.currentFrame->locals.max);
+                
+                /* Common code for all repeated single-character matches. We can give
+                 up quickly if there are fewer than the minimum number of characters left in
+                 the subject. */
+                
+            REPEATCHAR:
+                
+                stack.currentFrame->locals.length = 1;
+                getUTF8CharAndIncrementLength(stack.currentFrame->locals.fc, stack.currentFrame->args.instructionPtr, stack.currentFrame->locals.length);
+                if (min * (stack.currentFrame->locals.fc > 0xFFFF ? 2 : 1) > md.endSubject - stack.currentFrame->args.subjectPtr)
+                    RRETURN_NO_MATCH;
+                stack.currentFrame->args.instructionPtr += stack.currentFrame->locals.length;
+                
+                if (stack.currentFrame->locals.fc <= 0xFFFF) {
+                    int othercase = md.ignoreCase ? kjs_pcre_ucp_othercase(stack.currentFrame->locals.fc) : -1;
+                    
+                    for (int i = 1; i <= min; i++) {
+                        if (*stack.currentFrame->args.subjectPtr != stack.currentFrame->locals.fc && *stack.currentFrame->args.subjectPtr != othercase)
+                            RRETURN_NO_MATCH;
+                        ++stack.currentFrame->args.subjectPtr;
+                    }
+                    
+                    if (min == stack.currentFrame->locals.max)
+                        NEXT_OPCODE;
+                    
+                    if (minimize) {
+                        stack.currentFrame->locals.repeatOthercase = othercase;
+                        for (stack.currentFrame->locals.fi = min;; stack.currentFrame->locals.fi++) {
+                            RECURSIVE_MATCH(28, stack.currentFrame->args.instructionPtr, stack.currentFrame->args.bracketChain);
+                            if (isMatch)
+                                RRETURN;
+                            if (stack.currentFrame->locals.fi >= stack.currentFrame->locals.max || stack.currentFrame->args.subjectPtr >= md.endSubject)
+                                RRETURN;
+                            if (*stack.currentFrame->args.subjectPtr != stack.currentFrame->locals.fc && *stack.currentFrame->args.subjectPtr != stack.currentFrame->locals.repeatOthercase)
+                                RRETURN;
+                            ++stack.currentFrame->args.subjectPtr;
+                        }
+                        /* Control never reaches here */
+                    } else {
+                        stack.currentFrame->locals.subjectPtrAtStartOfInstruction = stack.currentFrame->args.subjectPtr;
+                        for (int i = min; i < stack.currentFrame->locals.max; i++) {
+                            if (stack.currentFrame->args.subjectPtr >= md.endSubject)
+                                break;
+                            if (*stack.currentFrame->args.subjectPtr != stack.currentFrame->locals.fc && *stack.currentFrame->args.subjectPtr != othercase)
+                                break;
+                            ++stack.currentFrame->args.subjectPtr;
+                        }
+                        while (stack.currentFrame->args.subjectPtr >= stack.currentFrame->locals.subjectPtrAtStartOfInstruction) {
+                            RECURSIVE_MATCH(29, stack.currentFrame->args.instructionPtr, stack.currentFrame->args.bracketChain);
+                            if (isMatch)
+                                RRETURN;
+                            --stack.currentFrame->args.subjectPtr;
+                        }
+                        RRETURN_NO_MATCH;
+                    }
+                    /* Control never reaches here */
+                } else {
+                    /* No case on surrogate pairs, so no need to bother with "othercase". */
+                    
+                    for (int i = 1; i <= min; i++) {
+                        if (*stack.currentFrame->args.subjectPtr != stack.currentFrame->locals.fc)
+                            RRETURN_NO_MATCH;
+                        stack.currentFrame->args.subjectPtr += 2;
+                    }
+                    
+                    if (min == stack.currentFrame->locals.max)
+                        NEXT_OPCODE;
+                    
+                    if (minimize) {
+                        for (stack.currentFrame->locals.fi = min;; stack.currentFrame->locals.fi++) {
+                            RECURSIVE_MATCH(30, stack.currentFrame->args.instructionPtr, stack.currentFrame->args.bracketChain);
+                            if (isMatch)
+                                RRETURN;
+                            if (stack.currentFrame->locals.fi >= stack.currentFrame->locals.max || stack.currentFrame->args.subjectPtr >= md.endSubject)
+                                RRETURN;
+                            if (*stack.currentFrame->args.subjectPtr != stack.currentFrame->locals.fc)
+                                RRETURN;
+                            stack.currentFrame->args.subjectPtr += 2;
+                        }
+                        /* Control never reaches here */
+                    } else {
+                        stack.currentFrame->locals.subjectPtrAtStartOfInstruction = stack.currentFrame->args.subjectPtr;
+                        for (int i = min; i < stack.currentFrame->locals.max; i++) {
+                            if (stack.currentFrame->args.subjectPtr > md.endSubject - 2)
+                                break;
+                            if (*stack.currentFrame->args.subjectPtr != stack.currentFrame->locals.fc)
+                                break;
+                            stack.currentFrame->args.subjectPtr += 2;
+                        }
+                        while (stack.currentFrame->args.subjectPtr >= stack.currentFrame->locals.subjectPtrAtStartOfInstruction) {
+                            RECURSIVE_MATCH(31, stack.currentFrame->args.instructionPtr, stack.currentFrame->args.bracketChain);
+                            if (isMatch)
+                                RRETURN;
+                            stack.currentFrame->args.subjectPtr -= 2;
+                        }
+                        RRETURN_NO_MATCH;
+                    }
+                    /* Control never reaches here */
+                }
+                /* Control never reaches here */
+                
+            /* Match a negated single one-byte character. */
+                
+            BEGIN_OPCODE(NOT): {
+                if (stack.currentFrame->args.subjectPtr >= md.endSubject)
+                    RRETURN_NO_MATCH;
+                stack.currentFrame->args.instructionPtr++;
+                int c = *stack.currentFrame->args.subjectPtr++;
+                if (md.ignoreCase) {
+                    if (c < 128)
+                        c = toLowerCase(c);
+                    if (toLowerCase(*stack.currentFrame->args.instructionPtr++) == c)
+                        RRETURN_NO_MATCH;
+                } else {
+                    if (*stack.currentFrame->args.instructionPtr++ == c)
+                        RRETURN_NO_MATCH;
+                }
+                NEXT_OPCODE;
+            }
+                
+            /* Match a negated single one-byte character repeatedly. This is almost a
+             repeat of the code for a repeated single character, but I haven't found a
+             nice way of commoning these up that doesn't require a test of the
+             positive/negative option for each character match. Maybe that wouldn't add
+             very much to the time taken, but character matching *is* what this is all
+             about... */
+                
+            BEGIN_OPCODE(NOTEXACT):
+                min = stack.currentFrame->locals.max = get2ByteValue(stack.currentFrame->args.instructionPtr + 1);
+                minimize = false;
+                stack.currentFrame->args.instructionPtr += 3;
+                goto REPEATNOTCHAR;
+                
+            BEGIN_OPCODE(NOTUPTO):
+            BEGIN_OPCODE(NOTMINUPTO):
+                min = 0;
+                stack.currentFrame->locals.max = get2ByteValue(stack.currentFrame->args.instructionPtr + 1);
+                minimize = *stack.currentFrame->args.instructionPtr == OP_NOTMINUPTO;
+                stack.currentFrame->args.instructionPtr += 3;
+                goto REPEATNOTCHAR;
+                
+            BEGIN_OPCODE(NOTSTAR):
+            BEGIN_OPCODE(NOTMINSTAR):
+            BEGIN_OPCODE(NOTPLUS):
+            BEGIN_OPCODE(NOTMINPLUS):
+            BEGIN_OPCODE(NOTQUERY):
+            BEGIN_OPCODE(NOTMINQUERY):
+                repeatInformationFromInstructionOffset(*stack.currentFrame->args.instructionPtr++ - OP_NOTSTAR, minimize, min, stack.currentFrame->locals.max);
+                
+            /* Common code for all repeated single-byte matches. We can give up quickly
+             if there are fewer than the minimum number of bytes left in the
+             subject. */
+                
+            REPEATNOTCHAR:
+                if (min > md.endSubject - stack.currentFrame->args.subjectPtr)
+                    RRETURN_NO_MATCH;
+                stack.currentFrame->locals.fc = *stack.currentFrame->args.instructionPtr++;
+                
+                /* The code is duplicated for the caseless and caseful cases, for speed,
+                 since matching characters is likely to be quite common. First, ensure the
+                 minimum number of matches are present. If min = max, continue at the same
+                 level without recursing. Otherwise, if minimizing, keep trying the rest of
+                 the expression and advancing one matching character if failing, up to the
+                 maximum. Alternatively, if maximizing, find the maximum number of
+                 characters and work backwards. */
+                
+                DPRINTF(("negative matching %c{%d,%d}\n", stack.currentFrame->locals.fc, min, stack.currentFrame->locals.max));
+                
+                if (md.ignoreCase) {
+                    if (stack.currentFrame->locals.fc < 128)
+                        stack.currentFrame->locals.fc = toLowerCase(stack.currentFrame->locals.fc);
+                    
+                    for (int i = 1; i <= min; i++) {
+                        int d = *stack.currentFrame->args.subjectPtr++;
+                        if (d < 128)
+                            d = toLowerCase(d);
+                        if (stack.currentFrame->locals.fc == d)
+                            RRETURN_NO_MATCH;
+                    }
+                    
+                    if (min == stack.currentFrame->locals.max)
+                        NEXT_OPCODE;      
+                    
+                    if (minimize) {
+                        for (stack.currentFrame->locals.fi = min;; stack.currentFrame->locals.fi++) {
+                            RECURSIVE_MATCH(38, stack.currentFrame->args.instructionPtr, stack.currentFrame->args.bracketChain);
+                            if (isMatch)
+                                RRETURN;
+                            int d = *stack.currentFrame->args.subjectPtr++;
+                            if (d < 128)
+                                d = toLowerCase(d);
+                            if (stack.currentFrame->locals.fi >= stack.currentFrame->locals.max || stack.currentFrame->args.subjectPtr >= md.endSubject || stack.currentFrame->locals.fc == d)
+                                RRETURN;
+                        }
+                        /* Control never reaches here */
+                    }
+                    
+                    /* Maximize case */
+                    
+                    else {
+                        stack.currentFrame->locals.subjectPtrAtStartOfInstruction = stack.currentFrame->args.subjectPtr;
+                        
+                        for (int i = min; i < stack.currentFrame->locals.max; i++) {
+                            if (stack.currentFrame->args.subjectPtr >= md.endSubject)
+                                break;
+                            int d = *stack.currentFrame->args.subjectPtr;
+                            if (d < 128)
+                                d = toLowerCase(d);
+                            if (stack.currentFrame->locals.fc == d)
+                                break;
+                            ++stack.currentFrame->args.subjectPtr;
+                        }
+                        for (;;) {
+                            RECURSIVE_MATCH(40, stack.currentFrame->args.instructionPtr, stack.currentFrame->args.bracketChain);
+                            if (isMatch)
+                                RRETURN;
+                            if (stack.currentFrame->args.subjectPtr-- == stack.currentFrame->locals.subjectPtrAtStartOfInstruction)
+                                break;        /* Stop if tried at original pos */
+                        }
+                        
+                        RRETURN;
+                    }
+                    /* Control never reaches here */
+                }
+                
+                /* Caseful comparisons */
+                
+                else {
+                    for (int i = 1; i <= min; i++) {
+                        int d = *stack.currentFrame->args.subjectPtr++;
+                        if (stack.currentFrame->locals.fc == d)
+                            RRETURN_NO_MATCH;
+                    }
+
+                    if (min == stack.currentFrame->locals.max)
+                        NEXT_OPCODE;
+                    
+                    if (minimize) {
+                        for (stack.currentFrame->locals.fi = min;; stack.currentFrame->locals.fi++) {
+                            RECURSIVE_MATCH(42, stack.currentFrame->args.instructionPtr, stack.currentFrame->args.bracketChain);
+                            if (isMatch)
+                                RRETURN;
+                            int d = *stack.currentFrame->args.subjectPtr++;
+                            if (stack.currentFrame->locals.fi >= stack.currentFrame->locals.max || stack.currentFrame->args.subjectPtr >= md.endSubject || stack.currentFrame->locals.fc == d)
+                                RRETURN;
+                        }
+                        /* Control never reaches here */
+                    }
+                    
+                    /* Maximize case */
+                    
+                    else {
+                        stack.currentFrame->locals.subjectPtrAtStartOfInstruction = stack.currentFrame->args.subjectPtr;
+                        
+                        for (int i = min; i < stack.currentFrame->locals.max; i++) {
+                            if (stack.currentFrame->args.subjectPtr >= md.endSubject)
+                                break;
+                            int d = *stack.currentFrame->args.subjectPtr;
+                            if (stack.currentFrame->locals.fc == d)
+                                break;
+                            ++stack.currentFrame->args.subjectPtr;
+                        }
+                        for (;;) {
+                            RECURSIVE_MATCH(44, stack.currentFrame->args.instructionPtr, stack.currentFrame->args.bracketChain);
+                            if (isMatch)
+                                RRETURN;
+                            if (stack.currentFrame->args.subjectPtr-- == stack.currentFrame->locals.subjectPtrAtStartOfInstruction)
+                                break;        /* Stop if tried at original pos */
+                        }
+
+                        RRETURN;
+                    }
+                }
+                /* Control never reaches here */
+                
+            /* Match a single character type repeatedly; several different opcodes
+             share code. This is very similar to the code for single characters, but we
+             repeat it in the interests of efficiency. */
+                
+            BEGIN_OPCODE(TYPEEXACT):
+                min = stack.currentFrame->locals.max = get2ByteValue(stack.currentFrame->args.instructionPtr + 1);
+                minimize = true;
+                stack.currentFrame->args.instructionPtr += 3;
+                goto REPEATTYPE;
+                
+            BEGIN_OPCODE(TYPEUPTO):
+            BEGIN_OPCODE(TYPEMINUPTO):
+                min = 0;
+                stack.currentFrame->locals.max = get2ByteValue(stack.currentFrame->args.instructionPtr + 1);
+                minimize = *stack.currentFrame->args.instructionPtr == OP_TYPEMINUPTO;
+                stack.currentFrame->args.instructionPtr += 3;
+                goto REPEATTYPE;
+                
+            BEGIN_OPCODE(TYPESTAR):
+            BEGIN_OPCODE(TYPEMINSTAR):
+            BEGIN_OPCODE(TYPEPLUS):
+            BEGIN_OPCODE(TYPEMINPLUS):
+            BEGIN_OPCODE(TYPEQUERY):
+            BEGIN_OPCODE(TYPEMINQUERY):
+                repeatInformationFromInstructionOffset(*stack.currentFrame->args.instructionPtr++ - OP_TYPESTAR, minimize, min, stack.currentFrame->locals.max);
+                
+                /* Common code for all repeated single character type matches. Note that
+                 in UTF-8 mode, '.' matches a character of any length, but for the other
+                 character types, the valid characters are all one-byte long. */
+                
+            REPEATTYPE:
+                stack.currentFrame->locals.ctype = *stack.currentFrame->args.instructionPtr++;      /* Code for the character type */
+                
+                /* First, ensure the minimum number of matches are present. Use inline
+                 code for maximizing the speed, and do the type test once at the start
+                 (i.e. keep it out of the loop). Also we can test that there are at least
+                 the minimum number of characters before we start. */
+                
+                if (min > md.endSubject - stack.currentFrame->args.subjectPtr)
+                    RRETURN_NO_MATCH;
+                if (min > 0) {
+                    switch (stack.currentFrame->locals.ctype) {
+                        case OP_NOT_NEWLINE:
+                            for (int i = 1; i <= min; i++) {
+                                if (isNewline(*stack.currentFrame->args.subjectPtr))
+                                    RRETURN_NO_MATCH;
+                                ++stack.currentFrame->args.subjectPtr;
+                            }
+                            break;
+                            
+                        case OP_NOT_DIGIT:
+                            for (int i = 1; i <= min; i++) {
+                                if (isASCIIDigit(*stack.currentFrame->args.subjectPtr))
+                                    RRETURN_NO_MATCH;
+                                ++stack.currentFrame->args.subjectPtr;
+                            }
+                            break;
+                            
+                        case OP_DIGIT:
+                            for (int i = 1; i <= min; i++) {
+                                if (!isASCIIDigit(*stack.currentFrame->args.subjectPtr))
+                                    RRETURN_NO_MATCH;
+                                ++stack.currentFrame->args.subjectPtr;
+                            }
+                            break;
+                            
+                        case OP_NOT_WHITESPACE:
+                            for (int i = 1; i <= min; i++) {
+                                if (isSpaceChar(*stack.currentFrame->args.subjectPtr))
+                                    RRETURN_NO_MATCH;
+                                ++stack.currentFrame->args.subjectPtr;
+                            }
+                            break;
+                            
+                        case OP_WHITESPACE:
+                            for (int i = 1; i <= min; i++) {
+                                if (!isSpaceChar(*stack.currentFrame->args.subjectPtr))
+                                    RRETURN_NO_MATCH;
+                                ++stack.currentFrame->args.subjectPtr;
+                            }
+                            break;
+                            
+                        case OP_NOT_WORDCHAR:
+                            for (int i = 1; i <= min; i++) {
+                                if (isWordChar(*stack.currentFrame->args.subjectPtr))
+                                    RRETURN_NO_MATCH;
+                                ++stack.currentFrame->args.subjectPtr;
+                            }
+                            break;
+                            
+                        case OP_WORDCHAR:
+                            for (int i = 1; i <= min; i++) {
+                                if (!isWordChar(*stack.currentFrame->args.subjectPtr))
+                                    RRETURN_NO_MATCH;
+                                ++stack.currentFrame->args.subjectPtr;
+                            }
+                            break;
+                            
+                        default:
+                            ASSERT_NOT_REACHED();
+                            return matchError(JSRegExpErrorInternal, stack);
+                    }  /* End switch(stack.currentFrame->locals.ctype) */
+                }
+                
+                /* If min = max, continue at the same level without recursing */
+                
+                if (min == stack.currentFrame->locals.max)
+                    NEXT_OPCODE;    
+                
+                /* If minimizing, we have to test the rest of the pattern before each
+                 subsequent match. */
+                
+                if (minimize) {
+                    for (stack.currentFrame->locals.fi = min;; stack.currentFrame->locals.fi++) {
+                        RECURSIVE_MATCH(48, stack.currentFrame->args.instructionPtr, stack.currentFrame->args.bracketChain);
+                        if (isMatch)
+                            RRETURN;
+                        if (stack.currentFrame->locals.fi >= stack.currentFrame->locals.max || stack.currentFrame->args.subjectPtr >= md.endSubject)
+                            RRETURN;
+                        
+                        int c = *stack.currentFrame->args.subjectPtr++;
+                        switch (stack.currentFrame->locals.ctype) {
+                            case OP_NOT_NEWLINE:
+                                if (isNewline(c))
+                                    RRETURN;
+                                break;
+                                
+                            case OP_NOT_DIGIT:
+                                if (isASCIIDigit(c))
+                                    RRETURN;
+                                break;
+                                
+                            case OP_DIGIT:
+                                if (!isASCIIDigit(c))
+                                    RRETURN;
+                                break;
+                                
+                            case OP_NOT_WHITESPACE:
+                                if (isSpaceChar(c))
+                                    RRETURN;
+                                break;
+                                
+                            case OP_WHITESPACE:
+                                if (!isSpaceChar(c))
+                                    RRETURN;
+                                break;
+                                
+                            case OP_NOT_WORDCHAR:
+                                if (isWordChar(c))
+                                    RRETURN;
+                                break;
+                                
+                            case OP_WORDCHAR:
+                                if (!isWordChar(c))
+                                    RRETURN;
+                                break;
+                                
+                            default:
+                                ASSERT_NOT_REACHED();
+                                return matchError(JSRegExpErrorInternal, stack);
+                        }
+                    }
+                    /* Control never reaches here */
+                }
+                
+                /* If maximizing it is worth using inline code for speed, doing the type
+                 test once at the start (i.e. keep it out of the loop). */
+                
+                else {
+                    stack.currentFrame->locals.subjectPtrAtStartOfInstruction = stack.currentFrame->args.subjectPtr;  /* Remember where we started */
+                    
+                    switch (stack.currentFrame->locals.ctype) {
+                        case OP_NOT_NEWLINE:
+                            for (int i = min; i < stack.currentFrame->locals.max; i++) {
+                                if (stack.currentFrame->args.subjectPtr >= md.endSubject || isNewline(*stack.currentFrame->args.subjectPtr))
+                                    break;
+                                stack.currentFrame->args.subjectPtr++;
+                            }
+                            break;
+                            
+                        case OP_NOT_DIGIT:
+                            for (int i = min; i < stack.currentFrame->locals.max; i++) {
+                                if (stack.currentFrame->args.subjectPtr >= md.endSubject)
+                                    break;
+                                int c = *stack.currentFrame->args.subjectPtr;
+                                if (isASCIIDigit(c))
+                                    break;
+                                ++stack.currentFrame->args.subjectPtr;
+                            }
+                            break;
+                            
+                        case OP_DIGIT:
+                            for (int i = min; i < stack.currentFrame->locals.max; i++) {
+                                if (stack.currentFrame->args.subjectPtr >= md.endSubject)
+                                    break;
+                                int c = *stack.currentFrame->args.subjectPtr;
+                                if (!isASCIIDigit(c))
+                                    break;
+                                ++stack.currentFrame->args.subjectPtr;
+                            }
+                            break;
+                            
+                        case OP_NOT_WHITESPACE:
+                            for (int i = min; i < stack.currentFrame->locals.max; i++) {
+                                if (stack.currentFrame->args.subjectPtr >= md.endSubject)
+                                    break;
+                                int c = *stack.currentFrame->args.subjectPtr;
+                                if (isSpaceChar(c))
+                                    break;
+                                ++stack.currentFrame->args.subjectPtr;
+                            }
+                            break;
+                            
+                        case OP_WHITESPACE:
+                            for (int i = min; i < stack.currentFrame->locals.max; i++) {
+                                if (stack.currentFrame->args.subjectPtr >= md.endSubject)
+                                    break;
+                                int c = *stack.currentFrame->args.subjectPtr;
+                                if (!isSpaceChar(c))
+                                    break;
+                                ++stack.currentFrame->args.subjectPtr;
+                            }
+                            break;
+                            
+                        case OP_NOT_WORDCHAR:
+                            for (int i = min; i < stack.currentFrame->locals.max; i++) {
+                                if (stack.currentFrame->args.subjectPtr >= md.endSubject)
+                                    break;
+                                int c = *stack.currentFrame->args.subjectPtr;
+                                if (isWordChar(c))
+                                    break;
+                                ++stack.currentFrame->args.subjectPtr;
+                            }
+                            break;
+                            
+                        case OP_WORDCHAR:
+                            for (int i = min; i < stack.currentFrame->locals.max; i++) {
+                                if (stack.currentFrame->args.subjectPtr >= md.endSubject)
+                                    break;
+                                int c = *stack.currentFrame->args.subjectPtr;
+                                if (!isWordChar(c))
+                                    break;
+                                ++stack.currentFrame->args.subjectPtr;
+                            }
+                            break;
+                            
+                        default:
+                            ASSERT_NOT_REACHED();
+                            return matchError(JSRegExpErrorInternal, stack);
+                    }
+                    
+                    /* stack.currentFrame->args.subjectPtr is now past the end of the maximum run */
+                    
+                    for (;;) {
+                        RECURSIVE_MATCH(52, stack.currentFrame->args.instructionPtr, stack.currentFrame->args.bracketChain);
+                        if (isMatch)
+                            RRETURN;
+                        if (stack.currentFrame->args.subjectPtr-- == stack.currentFrame->locals.subjectPtrAtStartOfInstruction)
+                            break;        /* Stop if tried at original pos */
+                    }
+                    
+                    /* Get here if we can't make it match with any permitted repetitions */
+                    
+                    RRETURN;
+                }
+                /* Control never reaches here */
+                
+            BEGIN_OPCODE(CRMINPLUS):
+            BEGIN_OPCODE(CRMINQUERY):
+            BEGIN_OPCODE(CRMINRANGE):
+            BEGIN_OPCODE(CRMINSTAR):
+            BEGIN_OPCODE(CRPLUS):
+            BEGIN_OPCODE(CRQUERY):
+            BEGIN_OPCODE(CRRANGE):
+            BEGIN_OPCODE(CRSTAR):
+                ASSERT_NOT_REACHED();
+                return matchError(JSRegExpErrorInternal, stack);
+                
+#ifdef USE_COMPUTED_GOTO_FOR_MATCH_OPCODE_LOOP
+            CAPTURING_BRACKET:
+#else
+            default:
+#endif
+                /* Opening capturing bracket. If there is space in the offset vector, save
+                 the current subject position in the working slot at the top of the vector. We
+                 mustn't change the current values of the data slot, because they may be set
+                 from a previous iteration of this group, and be referred to by a reference
+                 inside the group.
+                 
+                 If the bracket fails to match, we need to restore this value and also the
+                 values of the final offsets, in case they were set by a previous iteration of
+                 the same bracket.
+                 
+                 If there isn't enough space in the offset vector, treat this as if it were a
+                 non-capturing bracket. Don't worry about setting the flag for the error case
+                 here; that is handled in the code for KET. */
+                
+                ASSERT(*stack.currentFrame->args.instructionPtr > OP_BRA);
+                
+                stack.currentFrame->locals.number = *stack.currentFrame->args.instructionPtr - OP_BRA;
+                
+                /* For extended extraction brackets (large number), we have to fish out the
+                 number from a dummy opcode at the start. */
+                
+                if (stack.currentFrame->locals.number > EXTRACT_BASIC_MAX)
+                    stack.currentFrame->locals.number = get2ByteValue(stack.currentFrame->args.instructionPtr + 2 + LINK_SIZE);
+                stack.currentFrame->locals.offset = stack.currentFrame->locals.number << 1;
+                
+#ifdef DEBUG
+                printf("start bracket %d subject=", stack.currentFrame->locals.number);
+                pchars(stack.currentFrame->args.subjectPtr, 16, true, md);
+                printf("\n");
+#endif
+                
+                if (stack.currentFrame->locals.offset < md.offsetMax) {
+                    stack.currentFrame->locals.saveOffset1 = md.offsetVector[stack.currentFrame->locals.offset];
+                    stack.currentFrame->locals.saveOffset2 = md.offsetVector[stack.currentFrame->locals.offset + 1];
+                    stack.currentFrame->locals.saveOffset3 = md.offsetVector[md.offsetEnd - stack.currentFrame->locals.number];
+                    
+                    DPRINTF(("saving %d %d %d\n", stack.currentFrame->locals.saveOffset1, stack.currentFrame->locals.saveOffset2, stack.currentFrame->locals.saveOffset3));
+                    md.offsetVector[md.offsetEnd - stack.currentFrame->locals.number] = stack.currentFrame->args.subjectPtr - md.startSubject;
+                    
+                    do {
+                        RECURSIVE_MATCH_STARTNG_NEW_GROUP(1, stack.currentFrame->args.instructionPtr + 1 + LINK_SIZE, stack.currentFrame->args.bracketChain);
+                        if (isMatch)
+                            RRETURN;
+                        stack.currentFrame->args.instructionPtr += getLinkValue(stack.currentFrame->args.instructionPtr + 1);
+                    } while (*stack.currentFrame->args.instructionPtr == OP_ALT);
+                    
+                    DPRINTF(("bracket %d failed\n", stack.currentFrame->locals.number));
+                    
+                    md.offsetVector[stack.currentFrame->locals.offset] = stack.currentFrame->locals.saveOffset1;
+                    md.offsetVector[stack.currentFrame->locals.offset + 1] = stack.currentFrame->locals.saveOffset2;
+                    md.offsetVector[md.offsetEnd - stack.currentFrame->locals.number] = stack.currentFrame->locals.saveOffset3;
+                    
+                    RRETURN;
+                }
+                
+                /* Insufficient room for saving captured contents */
+                
+                goto NON_CAPTURING_BRACKET;
+        }
+        
+        /* Do not stick any code in here without much thought; it is assumed
+         that "continue" in the code above comes out to here to repeat the main
+         loop. */
+        
+    } /* End of main loop */
+    
+    ASSERT_NOT_REACHED();
+    
+#ifndef USE_COMPUTED_GOTO_FOR_MATCH_RECURSION
+    
+RRETURN_SWITCH:
+    switch (stack.currentFrame->returnLocation) {
+        case 0: goto RETURN;
+        case 1: goto RRETURN_1;
+        case 2: goto RRETURN_2;
+        case 6: goto RRETURN_6;
+        case 7: goto RRETURN_7;
+        case 14: goto RRETURN_14;
+        case 15: goto RRETURN_15;
+        case 16: goto RRETURN_16;
+        case 17: goto RRETURN_17;
+        case 18: goto RRETURN_18;
+        case 19: goto RRETURN_19;
+        case 20: goto RRETURN_20;
+        case 21: goto RRETURN_21;
+        case 22: goto RRETURN_22;
+        case 24: goto RRETURN_24;
+        case 26: goto RRETURN_26;
+        case 27: goto RRETURN_27;
+        case 28: goto RRETURN_28;
+        case 29: goto RRETURN_29;
+        case 30: goto RRETURN_30;
+        case 31: goto RRETURN_31;
+        case 38: goto RRETURN_38;
+        case 40: goto RRETURN_40;
+        case 42: goto RRETURN_42;
+        case 44: goto RRETURN_44;
+        case 48: goto RRETURN_48;
+        case 52: goto RRETURN_52;
+    }
+    
+    ASSERT_NOT_REACHED();
+    return matchError(JSRegExpErrorInternal, stack);
+    
+#endif
+    
+RETURN:
+    return isMatch;
+}
+
+
+/*************************************************
+*         Execute a Regular Expression           *
+*************************************************/
+
+/* This function applies a compiled re to a subject string and picks out
+portions of the string if it matches. Two elements in the vector are set for
+each substring: the offsets to the start and end of the substring.
+
+Arguments:
+  re              points to the compiled expression
+  extra_data      points to extra data or is NULL
+  subject         points to the subject string
+  length          length of subject string (may contain binary zeros)
+  start_offset    where to start in the subject string
+  options         option bits
+  offsets         points to a vector of ints to be filled in with offsets
+  offsetcount     the number of elements in the vector
+
+Returns:          > 0 => success; value is the number of elements filled in
+                  = 0 => success, but offsets is not big enough
+                   -1 => failed to match
+                 < -1 => some kind of unexpected problem
+*/
+
+static void tryFirstByteOptimization(const UChar*& subjectPtr, const UChar* endSubject, int first_byte, bool first_byte_caseless, bool useMultiLineFirstCharOptimization, const UChar* originalSubjectStart)
+{
+    // If first_byte is set, try scanning to the first instance of that byte
+    // no need to try and match against any earlier part of the subject string.
+    if (first_byte >= 0) {
+        UChar first_char = first_byte;
+        if (first_byte_caseless)
+            while (subjectPtr < endSubject) {
+                int c = *subjectPtr;
+                if (c > 127)
+                    break;
+                if (toLowerCase(c) == first_char)
+                    break;
+                subjectPtr++;
+            }
+        else {
+            while (subjectPtr < endSubject && *subjectPtr != first_char)
+                subjectPtr++;
+        }
+    } else if (useMultiLineFirstCharOptimization) {
+        /* Or to just after \n for a multiline match if possible */
+        // I'm not sure why this != originalSubjectStart check is necessary -- ecs 11/18/07
+        if (subjectPtr > originalSubjectStart) {
+            while (subjectPtr < endSubject && !isNewline(subjectPtr[-1]))
+                subjectPtr++;
+        }
+    }
+}
+
+static bool tryRequiredByteOptimization(const UChar*& subjectPtr, const UChar* endSubject, int req_byte, int req_byte2, bool req_byte_caseless, bool hasFirstByte, const UChar*& reqBytePtr)
+{
+    /* If req_byte is set, we know that that character must appear in the subject
+     for the match to succeed. If the first character is set, req_byte must be
+     later in the subject; otherwise the test starts at the match point. This
+     optimization can save a huge amount of backtracking in patterns with nested
+     unlimited repeats that aren't going to match. Writing separate code for
+     cased/caseless versions makes it go faster, as does using an autoincrement
+     and backing off on a match.
+     
+     HOWEVER: when the subject string is very, very long, searching to its end can
+     take a long time, and give bad performance on quite ordinary patterns. This
+     showed up when somebody was matching /^C/ on a 32-megabyte string... so we
+     don't do this when the string is sufficiently long.
+    */
+
+    if (req_byte >= 0 && endSubject - subjectPtr < REQ_BYTE_MAX) {
+        const UChar* p = subjectPtr + (hasFirstByte ? 1 : 0);
+
+        /* We don't need to repeat the search if we haven't yet reached the
+         place we found it at last time. */
+
+        if (p > reqBytePtr) {
+            if (req_byte_caseless) {
+                while (p < endSubject) {
+                    int pp = *p++;
+                    if (pp == req_byte || pp == req_byte2) {
+                        p--;
+                        break;
+                    }
+                }
+            } else {
+                while (p < endSubject) {
+                    if (*p++ == req_byte) {
+                        p--;
+                        break;
+                    }
+                }
+            }
+
+            /* If we can't find the required character, break the matching loop */
+
+            if (p >= endSubject)
+                return true;
+
+            /* If we have found the required character, save the point where we
+             found it, so that we don't search again next time round the loop if
+             the start hasn't passed this character yet. */
+
+            reqBytePtr = p;
+        }
+    }
+    return false;
+}
+
+int jsRegExpExecute(const JSRegExp* re,
+                    const UChar* subject, int length, int start_offset, int* offsets,
+                    int offsetcount)
+{
+    ASSERT(re);
+    ASSERT(subject);
+    ASSERT(offsetcount >= 0);
+    ASSERT(offsets || offsetcount == 0);
+    
+    MatchData matchBlock;
+    matchBlock.startSubject = subject;
+    matchBlock.endSubject = matchBlock.startSubject + length;
+    const UChar* endSubject = matchBlock.endSubject;
+    
+    matchBlock.multiline = 0 != (re->options & MatchAcrossMultipleLinesOption);
+    matchBlock.ignoreCase = 0 != (re->options & IgnoreCaseOption);
+    
+    /* If the expression has got more back references than the offsets supplied can
+     hold, we get a temporary chunk of working store to use during the matching.
+     Otherwise, we can use the vector supplied, rounding down its size to a multiple
+     of 3. */
+    
+    int ocount = offsetcount - (offsetcount % 3);
+    
+    // FIXME: This is lame that we have to second-guess our caller here.
+    // The API should change to either fail-hard when we don't have enough offset space
+    // or that we shouldn't ask our callers to pre-allocate in the first place.
+    bool using_temporary_offsets = false;
+    if (re->top_backref > 0 && re->top_backref >= ocount/3) {
+        ocount = re->top_backref * 3 + 3;
+        matchBlock.offsetVector = new int[ocount];
+        if (!matchBlock.offsetVector)
+            return JSRegExpErrorNoMemory;
+        using_temporary_offsets = true;
+    } else
+        matchBlock.offsetVector = offsets;
+    
+    matchBlock.offsetEnd = ocount;
+    matchBlock.offsetMax = (2*ocount)/3;
+    matchBlock.offsetOverflow = false;
+    
+    /* Compute the minimum number of offsets that we need to reset each time. Doing
+     this makes a huge difference to execution time when there aren't many brackets
+     in the pattern. */
+    
+    int resetcount = 2 + re->top_bracket * 2;
+    if (resetcount > offsetcount)
+        resetcount = ocount;
+    
+    /* Reset the working variable associated with each extraction. These should
+     never be used unless previously set, but they get saved and restored, and so we
+     initialize them to avoid reading uninitialized locations. */
+    
+    if (matchBlock.offsetVector) {
+        int* iptr = matchBlock.offsetVector + ocount;
+        int* iend = iptr - resetcount/2 + 1;
+        while (--iptr >= iend)
+            *iptr = -1;
+    }
+    
+    /* Set up the first character to match, if available. The first_byte value is
+     never set for an anchored regular expression, but the anchoring may be forced
+     at run time, so we have to test for anchoring. The first char may be unset for
+     an unanchored pattern, of course. If there's no first char and the pattern was
+     studied, there may be a bitmap of possible first characters. */
+    
+    bool first_byte_caseless = false;
+    int first_byte = -1;
+    if (re->options & UseFirstByteOptimizationOption) {
+        first_byte = re->first_byte & 255;
+        if ((first_byte_caseless = 0 != (re->first_byte & REQ_IGNORE_CASE)))
+            first_byte = toLowerCase(first_byte);
+    }
+    
+    /* For anchored or unanchored matches, there may be a "last known required
+     character" set. */
+    
+    bool req_byte_caseless = false;
+    int req_byte = -1;
+    int req_byte2 = -1;
+    if (re->options & UseRequiredByteOptimizationOption) {
+        req_byte = re->req_byte & 255; // FIXME: This optimization could be made to work for UTF16 chars as well...
+        req_byte_caseless = 0 != (re->req_byte & REQ_IGNORE_CASE);
+        req_byte2 = flipCase(req_byte);
+    }
+    
+    /* Loop for handling unanchored repeated matching attempts; for anchored regexs
+     the loop runs just once. */
+    
+    const UChar* startMatch = subject + start_offset;
+    const UChar* reqBytePtr = startMatch - 1;
+    bool useMultiLineFirstCharOptimization = 0 != (re->options & UseMultiLineFirstByteOptimizationOption);
+    
+    do {
+        /* Reset the maximum number of extractions we might see. */
+        if (matchBlock.offsetVector) {
+            int* iptr = matchBlock.offsetVector;
+            int* iend = iptr + resetcount;
+            while (iptr < iend)
+                *iptr++ = -1;
+        }
+        
+        tryFirstByteOptimization(startMatch, endSubject, first_byte, first_byte_caseless, useMultiLineFirstCharOptimization, matchBlock.startSubject + start_offset);
+        if (tryRequiredByteOptimization(startMatch, endSubject, req_byte, req_byte2, req_byte_caseless, first_byte >= 0, reqBytePtr))
+            break;
+                
+        /* When a match occurs, substrings will be set for all internal extractions;
+         we just need to set up the whole thing as substring 0 before returning. If
+         there were too many extractions, set the return code to zero. In the case
+         where we had to get some local store to hold offsets for backreferences, copy
+         those back references that we can. In this case there need not be overflow
+         if certain parts of the pattern were not used. */
+        
+        /* The code starts after the JSRegExp block and the capture name table. */
+        const unsigned char* start_code = (const unsigned char*)(re + 1);
+        
+        int returnCode = match(startMatch, start_code, 2, matchBlock);
+        
+        /* When the result is no match, advance the pointer to the next character
+         and continue. */
+        if (returnCode == 0) {
+            startMatch++;
+            continue;
+        }
+
+        if (returnCode != 1) {
+            ASSERT(returnCode == JSRegExpErrorHitLimit || returnCode == JSRegExpErrorNoMemory);
+            DPRINTF((">>>> error: returning %d\n", returnCode));
+            return returnCode;
+        }
+        
+        /* We have a match! Copy the offset information from temporary store if
+         necessary */
+        
+        if (using_temporary_offsets) {
+            if (offsetcount >= 4) {
+                memcpy(offsets + 2, matchBlock.offsetVector + 2, (offsetcount - 2) * sizeof(int));
+                DPRINTF(("Copied offsets from temporary memory\n"));
+            }
+            if (matchBlock.endOffsetTop > offsetcount)
+                matchBlock.offsetOverflow = true;
+            
+            DPRINTF(("Freeing temporary memory\n"));
+            delete [] matchBlock.offsetVector;
+        }
+        
+        returnCode = matchBlock.offsetOverflow ? 0 : matchBlock.endOffsetTop / 2;
+        
+        if (offsetcount < 2)
+            returnCode = 0;
+        else {
+            offsets[0] = startMatch - matchBlock.startSubject;
+            offsets[1] = matchBlock.endMatchPtr - matchBlock.startSubject;
+        }
+        
+        DPRINTF((">>>> returning %d\n", returnCode));
+        return returnCode;
+    } while (!(re->options & IsAnchoredOption) && startMatch <= endSubject);
+    
+    if (using_temporary_offsets) {
+        DPRINTF(("Freeing temporary memory\n"));
+        delete [] matchBlock.offsetVector;
+    }
+    
+    DPRINTF((">>>> returning PCRE_ERROR_NOMATCH\n"));
+    return JSRegExpErrorNoMatch;
+}
+
+} // namespace jscre
diff --git a/plugin/jscre/JSRegExp_internal.h b/plugin/jscre/JSRegExp_internal.h
new file mode 100644
index 0000000..8b0d0c3
--- /dev/null
+++ b/plugin/jscre/JSRegExp_internal.h
@@ -0,0 +1,423 @@
+/* This is JavaScriptCore's variant of the PCRE library. While this library
+started out as a copy of PCRE, many of the features of PCRE have been
+removed. This library now supports only the regular expression features
+required by the JavaScript language specification, and has only the functions
+needed by JavaScriptCore and the rest of WebKit.
+
+                 Originally written by Philip Hazel
+           Copyright (c) 1997-2006 University of Cambridge
+    Copyright (C) 2002, 2004, 2006, 2007 Apple Inc. All rights reserved.
+
+-----------------------------------------------------------------------------
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+    * Neither the name of the University of Cambridge nor the names of its
+      contributors may be used to endorse or promote products derived from
+      this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+-----------------------------------------------------------------------------
+*/
+
+#pragma once
+
+/* This header contains definitions that are shared between the different
+modules, but which are not relevant to the exported API. This includes some
+functions whose names all begin with "_pcre_". */
+
+/* Bit definitions for entries in the pcre_ctypes table. */
+
+#define ctype_space   0x01
+#define ctype_xdigit  0x08
+#define ctype_word    0x10   /* alphameric or '_' */
+
+/* Offsets for the bitmap tables in pcre_cbits. Each table contains a set
+of bits for a class map. Some classes are built by combining these tables. */
+
+#define cbit_space     0      /* \s */
+#define cbit_digit    32      /* \d */
+#define cbit_word     64      /* \w */
+#define cbit_length   96      /* Length of the cbits table */
+
+/* Offsets of the various tables from the base tables pointer, and
+total length. */
+
+#define lcc_offset      0
+#define fcc_offset    128
+#define cbits_offset  256
+#define ctypes_offset (cbits_offset + cbit_length)
+#define tables_length (ctypes_offset + 128)
+
+#ifndef DFTABLES
+
+// TODO: Hook this up to something that checks assertions.
+#define ASSERT(x) do { } while(0)
+#define ASSERT_NOT_REACHED() do {} while(0)
+
+#ifdef WIN32
+#pragma warning(disable: 4232)
+#pragma warning(disable: 4244)
+#endif
+
+#include "JSRegExp.h"
+
+/* The value of LINK_SIZE determines the number of bytes used to store links as
+offsets within the compiled regex. The default is 2, which allows for compiled
+patterns up to 64K long. */
+
+#define LINK_SIZE   2
+
+/* Define DEBUG to get debugging output on stdout. */
+
+#if 0
+#define DEBUG
+#endif
+
+/* Use a macro for debugging printing, 'cause that eliminates the use of #ifdef
+inline, and there are *still* stupid compilers about that don't like indented
+pre-processor statements, or at least there were when I first wrote this. After
+all, it had only been about 10 years then... */
+
+#ifdef DEBUG
+#define DPRINTF(p) printf p
+#else
+#define DPRINTF(p) /*nothing*/
+#endif
+
+namespace jscre {
+
+/* PCRE keeps offsets in its compiled code as 2-byte quantities (always stored
+in big-endian order) by default. These are used, for example, to link from the
+start of a subpattern to its alternatives and its end. The use of 2 bytes per
+offset limits the size of the compiled regex to around 64K, which is big enough
+for almost everybody. However, I received a request for an even bigger limit.
+For this reason, and also to make the code easier to maintain, the storing and
+loading of offsets from the byte string is now handled by the functions that are
+defined here. */
+
+/* PCRE uses some other 2-byte quantities that do not change when the size of
+offsets changes. There are used for repeat counts and for other things such as
+capturing parenthesis numbers in back references. */
+
+static inline void put2ByteValue(unsigned char* opcodePtr, int value)
+{
+    ASSERT(value >= 0 && value <= 0xFFFF);
+    opcodePtr[0] = value >> 8;
+    opcodePtr[1] = value;
+}
+
+static inline int get2ByteValue(const unsigned char* opcodePtr)
+{
+    return (opcodePtr[0] << 8) | opcodePtr[1];
+}
+
+static inline void put2ByteValueAndAdvance(unsigned char*& opcodePtr, int value)
+{
+    put2ByteValue(opcodePtr, value);
+    opcodePtr += 2;
+}
+
+static inline void putLinkValueAllowZero(unsigned char* opcodePtr, int value)
+{
+    put2ByteValue(opcodePtr, value);
+}
+
+static inline int getLinkValueAllowZero(const unsigned char* opcodePtr)
+{
+    return get2ByteValue(opcodePtr);
+}
+
+#define MAX_PATTERN_SIZE (1 << 16)
+
+static inline void putLinkValue(unsigned char* opcodePtr, int value)
+{
+    ASSERT(value);
+    putLinkValueAllowZero(opcodePtr, value);
+}
+
+static inline int getLinkValue(const unsigned char* opcodePtr)
+{
+    int value = getLinkValueAllowZero(opcodePtr);
+    ASSERT(value);
+    return value;
+}
+
+static inline void putLinkValueAndAdvance(unsigned char*& opcodePtr, int value)
+{
+    putLinkValue(opcodePtr, value);
+    opcodePtr += LINK_SIZE;
+}
+
+static inline void putLinkValueAllowZeroAndAdvance(unsigned char*& opcodePtr, int value)
+{
+    putLinkValueAllowZero(opcodePtr, value);
+    opcodePtr += LINK_SIZE;
+}
+
+// FIXME: These are really more of a "compiled regexp state" than "regexp options"
+enum RegExpOptions {
+    UseFirstByteOptimizationOption = 0x40000000,  /* first_byte is set */
+    UseRequiredByteOptimizationOption = 0x20000000,  /* req_byte is set */
+    UseMultiLineFirstByteOptimizationOption = 0x10000000,  /* start after \n for multiline */
+    IsAnchoredOption = 0x02000000,  /* can't use partial with this regex */
+    IgnoreCaseOption = 0x00000001,
+    MatchAcrossMultipleLinesOption = 0x00000002
+};
+
+/* Flags added to firstbyte or reqbyte; a "non-literal" item is either a
+variable-length repeat, or a anything other than literal characters. */
+
+#define REQ_IGNORE_CASE 0x0100    /* indicates should ignore case */
+#define REQ_VARY     0x0200    /* reqbyte followed non-literal item */
+
+/* Miscellaneous definitions */
+
+/* Flag bits and data types for the extended class (OP_XCLASS) for classes that
+contain UTF-8 characters with values greater than 255. */
+
+#define XCL_NOT    0x01    /* Flag: this is a negative class */
+#define XCL_MAP    0x02    /* Flag: a 32-byte map is present */
+
+#define XCL_END       0    /* Marks end of individual items */
+#define XCL_SINGLE    1    /* Single item (one multibyte char) follows */
+#define XCL_RANGE     2    /* A range (two multibyte chars) follows */
+
+/* These are escaped items that aren't just an encoding of a particular data
+value such as \n. They must have non-zero values, as check_escape() returns
+their negation. Also, they must appear in the same order as in the opcode
+definitions below, up to ESC_w. The final one must be
+ESC_REF as subsequent values are used for \1, \2, \3, etc. There is are two
+tests in the code for an escape > ESC_b and <= ESC_w to
+detect the types that may be repeated. These are the types that consume
+characters. If any new escapes are put in between that don't consume a
+character, that code will have to change. */
+
+enum { ESC_B = 1, ESC_b, ESC_D, ESC_d, ESC_S, ESC_s, ESC_W, ESC_w, ESC_REF };
+
+/* Opcode table: OP_BRA must be last, as all values >= it are used for brackets
+that extract substrings. Starting from 1 (i.e. after OP_END), the values up to
+OP_EOD must correspond in order to the list of escapes immediately above.
+Note that whenever this list is updated, the two macro definitions that follow
+must also be updated to match. */
+
+#define FOR_EACH_OPCODE(macro) \
+    macro(END) \
+    \
+    macro(NOT_WORD_BOUNDARY) \
+    macro(WORD_BOUNDARY) \
+    macro(NOT_DIGIT) \
+    macro(DIGIT) \
+    macro(NOT_WHITESPACE) \
+    macro(WHITESPACE) \
+    macro(NOT_WORDCHAR) \
+    macro(WORDCHAR) \
+    \
+    macro(NOT_NEWLINE) \
+    \
+    macro(CIRC) \
+    macro(DOLL) \
+    macro(BOL) \
+    macro(EOL) \
+    macro(CHAR) \
+    macro(CHAR_IGNORING_CASE) \
+    macro(ASCII_CHAR) \
+    macro(ASCII_LETTER_IGNORING_CASE) \
+    macro(NOT) \
+    \
+    macro(STAR) \
+    macro(MINSTAR) \
+    macro(PLUS) \
+    macro(MINPLUS) \
+    macro(QUERY) \
+    macro(MINQUERY) \
+    macro(UPTO) \
+    macro(MINUPTO) \
+    macro(EXACT) \
+    \
+    macro(NOTSTAR) \
+    macro(NOTMINSTAR) \
+    macro(NOTPLUS) \
+    macro(NOTMINPLUS) \
+    macro(NOTQUERY) \
+    macro(NOTMINQUERY) \
+    macro(NOTUPTO) \
+    macro(NOTMINUPTO) \
+    macro(NOTEXACT) \
+    \
+    macro(TYPESTAR) \
+    macro(TYPEMINSTAR) \
+    macro(TYPEPLUS) \
+    macro(TYPEMINPLUS) \
+    macro(TYPEQUERY) \
+    macro(TYPEMINQUERY) \
+    macro(TYPEUPTO) \
+    macro(TYPEMINUPTO) \
+    macro(TYPEEXACT) \
+    \
+    macro(CRSTAR) \
+    macro(CRMINSTAR) \
+    macro(CRPLUS) \
+    macro(CRMINPLUS) \
+    macro(CRQUERY) \
+    macro(CRMINQUERY) \
+    macro(CRRANGE) \
+    macro(CRMINRANGE) \
+    \
+    macro(CLASS) \
+    macro(NCLASS) \
+    macro(XCLASS) \
+    \
+    macro(REF) \
+    \
+    macro(ALT) \
+    macro(KET) \
+    macro(KETRMAX) \
+    macro(KETRMIN) \
+    \
+    macro(ASSERT) \
+    macro(ASSERT_NOT) \
+    \
+    macro(BRAZERO) \
+    macro(BRAMINZERO) \
+    macro(BRANUMBER) \
+    macro(BRA)
+
+#define OPCODE_ENUM_VALUE(opcode) OP_##opcode,
+enum { FOR_EACH_OPCODE(OPCODE_ENUM_VALUE) };
+
+/* WARNING WARNING WARNING: There is an implicit assumption in pcre.c and
+study.c that all opcodes are less than 128 in value. This makes handling UTF-8
+character sequences easier. */
+
+/* The highest extraction number before we have to start using additional
+bytes. (Originally PCRE didn't have support for extraction counts higher than
+this number.) The value is limited by the number of opcodes left after OP_BRA,
+i.e. 255 - OP_BRA. We actually set it a bit lower to leave room for additional
+opcodes. */
+
+/* FIXME: Note that OP_BRA + 100 is > 128, so the two comments above
+are in conflict! */
+
+#define EXTRACT_BASIC_MAX  100
+
+/* The index of names and the
+code vector run on as long as necessary after the end. We store an explicit
+offset to the name table so that if a regex is compiled on one host, saved, and
+then run on another where the size of pointers is different, all might still
+be well. For the case of compiled-on-4 and run-on-8, we include an extra
+pointer that is always NULL.
+*/
+
+struct JSRegExp {
+    unsigned options;
+
+    unsigned short top_bracket;
+    unsigned short top_backref;
+    
+    unsigned short first_byte;
+    unsigned short req_byte;
+};
+
+/* Internal shared data tables. These are tables that are used by more than one
+ of the exported public functions. They have to be "external" in the C sense,
+ but are not part of the PCRE public API. The data for these tables is in the
+ pcre_tables.c module. */
+
+#define kjs_pcre_utf8_table1_size 6
+
+extern const int    kjs_pcre_utf8_table1[6];
+extern const int    kjs_pcre_utf8_table2[6];
+extern const int    kjs_pcre_utf8_table3[6];
+extern const unsigned char kjs_pcre_utf8_table4[0x40];
+
+extern const unsigned char kjs_pcre_default_tables[tables_length];
+
+static inline unsigned char toLowerCase(unsigned char c)
+{
+    static const unsigned char* lowerCaseChars = kjs_pcre_default_tables + lcc_offset;
+    return lowerCaseChars[c];
+}
+
+static inline unsigned char flipCase(unsigned char c)
+{
+    static const unsigned char* flippedCaseChars = kjs_pcre_default_tables + fcc_offset;
+    return flippedCaseChars[c];
+}
+
+static inline unsigned char classBitmapForChar(unsigned char c)
+{
+    static const unsigned char* charClassBitmaps = kjs_pcre_default_tables + cbits_offset;
+    return charClassBitmaps[c];
+}
+
+static inline unsigned char charTypeForChar(unsigned char c)
+{
+    const unsigned char* charTypeMap = kjs_pcre_default_tables + ctypes_offset;
+    return charTypeMap[c];
+}
+
+static inline bool isWordChar(UChar c)
+{
+    return c < 128 && (charTypeForChar(c) & ctype_word);
+}
+
+static inline bool isSpaceChar(UChar c)
+{
+    return (c < 128 && (charTypeForChar(c) & ctype_space));
+}
+
+static inline bool isNewline(UChar nl)
+{
+    return (nl == 0xA || nl == 0xD || nl == 0x2028 || nl == 0x2029);
+}
+
+static inline bool isBracketStartOpcode(unsigned char opcode)
+{
+    if (opcode >= OP_BRA)
+        return true;
+    switch (opcode) {
+        case OP_ASSERT:
+        case OP_ASSERT_NOT:
+            return true;
+        default:
+            return false;
+    }
+}
+
+static inline void advanceToEndOfBracket(const unsigned char*& opcodePtr)
+{
+    ASSERT(isBracketStartOpcode(*opcodePtr) || *opcodePtr == OP_ALT);
+    do
+        opcodePtr += getLinkValue(opcodePtr + 1);
+    while (*opcodePtr == OP_ALT);
+}
+
+/* Internal shared functions. These are functions that are used in more
+that one of the source files. They have to have external linkage, but
+but are not part of the public API and so not exported from the library. */
+
+extern int kjs_pcre_ucp_othercase(unsigned);
+extern bool kjs_pcre_xclass(int, const unsigned char*);
+
+} // namespace jscre
+#endif
+
+/* End of jsregexp_internal.h */
diff --git a/plugin/jscre/JSRegExp_tables.cpp b/plugin/jscre/JSRegExp_tables.cpp
new file mode 100644
index 0000000..fa00dcf
--- /dev/null
+++ b/plugin/jscre/JSRegExp_tables.cpp
@@ -0,0 +1,75 @@
+/* This is JavaScriptCore's variant of the PCRE library. While this library
+started out as a copy of PCRE, many of the features of PCRE have been
+removed. This library now supports only the regular expression features
+required by the JavaScript language specification, and has only the functions
+needed by JavaScriptCore and the rest of WebKit.
+
+                 Originally written by Philip Hazel
+           Copyright (c) 1997-2006 University of Cambridge
+    Copyright (C) 2002, 2004, 2006, 2007 Apple Inc. All rights reserved.
+
+-----------------------------------------------------------------------------
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+    * Neither the name of the University of Cambridge nor the names of its
+      contributors may be used to endorse or promote products derived from
+      this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+-----------------------------------------------------------------------------
+*/
+
+/* This module contains some fixed tables that are used by more than one of the
+PCRE code modules. */
+
+#include "JSRegExp_internal.h"
+
+namespace jscre {
+
+/*************************************************
+*           Tables for UTF-8 support             *
+*************************************************/
+
+/* These are the breakpoints for different numbers of bytes in a UTF-8
+character. */
+
+const int kjs_pcre_utf8_table1[6] =
+  { 0x7f, 0x7ff, 0xffff, 0x1fffff, 0x3ffffff, 0x7fffffff};
+
+/* These are the indicator bits and the mask for the data bits to set in the
+first byte of a character, indexed by the number of additional bytes. */
+
+const int kjs_pcre_utf8_table2[6] = { 0,    0xc0, 0xe0, 0xf0, 0xf8, 0xfc};
+const int kjs_pcre_utf8_table3[6] = { 0xff, 0x1f, 0x0f, 0x07, 0x03, 0x01};
+
+/* Table of the number of extra characters, indexed by the first character
+masked with 0x3f. The highest number for a valid UTF-8 character is in fact
+0x3d. */
+
+const unsigned char kjs_pcre_utf8_table4[0x40] = {
+  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
+  3,3,3,3,3,3,3,3,4,4,4,4,5,5,5,5 };
+
+#include "JSRegExp_chartables.c"
+
+} // namespace jscre
diff --git a/plugin/jscre/JSRegExp_ucp_searchfuncs.cpp b/plugin/jscre/JSRegExp_ucp_searchfuncs.cpp
new file mode 100644
index 0000000..df304ac
--- /dev/null
+++ b/plugin/jscre/JSRegExp_ucp_searchfuncs.cpp
@@ -0,0 +1,102 @@
+/* This is JavaScriptCore's variant of the PCRE library. While this library
+started out as a copy of PCRE, many of the features of PCRE have been
+removed. This library now supports only the regular expression features
+required by the JavaScript language specification, and has only the functions
+needed by JavaScriptCore and the rest of WebKit.
+
+                 Originally written by Philip Hazel
+           Copyright (c) 1997-2006 University of Cambridge
+    Copyright (C) 2002, 2004, 2006, 2007 Apple Inc. All rights reserved.
+
+-----------------------------------------------------------------------------
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+    * Neither the name of the University of Cambridge nor the names of its
+      contributors may be used to endorse or promote products derived from
+      this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+-----------------------------------------------------------------------------
+*/
+
+
+/* This module contains code for searching the table of Unicode character
+properties. */
+
+#include "JSRegExp_internal.h"
+
+#include "ucpinternal.h"       /* Internal table details */
+#include "ucptable.cpp"        /* The table itself */
+
+namespace jscre {
+
+/*************************************************
+*       Search table and return other case       *
+*************************************************/
+
+/* If the given character is a letter, and there is another case for the
+letter, return the other case. Otherwise, return -1.
+
+Arguments:
+  c           the character value
+
+Returns:      the other case or -1 if none
+*/
+
+int kjs_pcre_ucp_othercase(unsigned c)
+{
+    int bot = 0;
+    int top = sizeof(ucp_table) / sizeof(cnode);
+    int mid;
+    
+    /* The table is searched using a binary chop. You might think that using
+     intermediate variables to hold some of the common expressions would speed
+     things up, but tests with gcc 3.4.4 on Linux showed that, on the contrary, it
+     makes things a lot slower. */
+    
+    for (;;) {
+        if (top <= bot)
+            return -1;
+        mid = (bot + top) >> 1;
+        if (c == (ucp_table[mid].f0 & f0_charmask))
+            break;
+        if (c < (ucp_table[mid].f0 & f0_charmask))
+            top = mid;
+        else {
+            if ((ucp_table[mid].f0 & f0_rangeflag) && (c <= (ucp_table[mid].f0 & f0_charmask) + (ucp_table[mid].f1 & f1_rangemask)))
+                break;
+            bot = mid + 1;
+        }
+    }
+    
+    /* Found an entry in the table. Return -1 for a range entry. Otherwise return
+     the other case if there is one, else -1. */
+    
+    if (ucp_table[mid].f0 & f0_rangeflag)
+        return -1;
+    
+    int offset = ucp_table[mid].f1 & f1_casemask;
+    if (offset & f1_caseneg)
+        offset |= f1_caseneg;
+    return !offset ? -1 : c + offset;
+}
+
+} // namespace jscre
diff --git a/plugin/jscre/JSRegExp_xclass.cpp b/plugin/jscre/JSRegExp_xclass.cpp
new file mode 100644
index 0000000..1054a37
--- /dev/null
+++ b/plugin/jscre/JSRegExp_xclass.cpp
@@ -0,0 +1,118 @@
+/* This is JavaScriptCore's variant of the PCRE library. While this library
+started out as a copy of PCRE, many of the features of PCRE have been
+removed. This library now supports only the regular expression features
+required by the JavaScript language specification, and has only the functions
+needed by JavaScriptCore and the rest of WebKit.
+
+                 Originally written by Philip Hazel
+           Copyright (c) 1997-2006 University of Cambridge
+    Copyright (C) 2002, 2004, 2006, 2007 Apple Inc. All rights reserved.
+
+-----------------------------------------------------------------------------
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+    * Neither the name of the University of Cambridge nor the names of its
+      contributors may be used to endorse or promote products derived from
+      this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+-----------------------------------------------------------------------------
+*/
+
+/* This module contains an internal function that is used to match an extended
+class (one that contains characters whose values are > 255). */
+
+#include "JSRegExp_internal.h"
+
+namespace jscre {
+
+/*************************************************
+*       Match character against an XCLASS        *
+*************************************************/
+
+/* This function is called to match a character against an extended class that
+might contain values > 255.
+
+Arguments:
+  c           the character
+  data        points to the flag byte of the XCLASS data
+
+Returns:      true if character matches, else false
+*/
+
+/* Get the next UTF-8 character, advancing the pointer. This is called when we
+ know we are in UTF-8 mode. */
+
+static inline void getUTF8CharAndAdvancePointer(int& c, const unsigned char*& subjectPtr)
+{
+    c = *subjectPtr++;
+    if ((c & 0xc0) == 0xc0) {
+        int gcaa = kjs_pcre_utf8_table4[c & 0x3f];  /* Number of additional bytes */
+        int gcss = 6 * gcaa;
+        c = (c & kjs_pcre_utf8_table3[gcaa]) << gcss;
+        while (gcaa-- > 0) {
+            gcss -= 6;
+            c |= (*subjectPtr++ & 0x3f) << gcss;
+        }
+    }
+}
+
+bool kjs_pcre_xclass(int c, const unsigned char* data)
+{
+    bool negated = (*data & XCL_NOT);
+    
+    /* Character values < 256 are matched against a bitmap, if one is present. If
+     not, we still carry on, because there may be ranges that start below 256 in the
+     additional data. */
+    
+    if (c < 256) {
+        if ((*data & XCL_MAP) != 0 && (data[1 + c/8] & (1 << (c&7))) != 0)
+            return !negated;   /* char found */
+    }
+    
+    /* First skip the bit map if present. Then match against the list of Unicode
+     properties or large chars or ranges that end with a large char. We won't ever
+     encounter XCL_PROP or XCL_NOTPROP when UCP support is not compiled. */
+    
+    if ((*data++ & XCL_MAP) != 0)
+        data += 32;
+    
+    int t;
+    while ((t = *data++) != XCL_END) {
+        if (t == XCL_SINGLE) {
+            int x;
+            getUTF8CharAndAdvancePointer(x, data);
+            if (c == x)
+                return !negated;
+        }
+        else if (t == XCL_RANGE) {
+            int x, y;
+            getUTF8CharAndAdvancePointer(x, data);
+            getUTF8CharAndAdvancePointer(y, data);
+            if (c >= x && c <= y)
+                return !negated;
+        }
+    }
+    
+    return negated;   /* char did not match */
+}
+
+} // namespace jscre
diff --git a/plugin/jscre/LICENSE b/plugin/jscre/LICENSE
new file mode 100644
index 0000000..020c45f
--- /dev/null
+++ b/plugin/jscre/LICENSE
@@ -0,0 +1,85 @@
+-----------------------------------------------------------------------------
+The following license text is extracted from the header of the file
+ASCIICType.h and applies only to that file.
+-----------------------------------------------------------------------------
+
+Copyright (C) 2007, 2008 Apple Inc. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+1.  Redistributions of source code must retain the above copyright
+    notice, this list of conditions and the following disclaimer. 
+2.  Redistributions in binary form must reproduce the above copyright
+    notice, this list of conditions and the following disclaimer in the
+    documentation and/or other materials provided with the distribution. 
+3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
+    its contributors may be used to endorse or promote products derived
+    from this software without specific prior written permission. 
+
+THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+-----------------------------------------------------------------------------
+The following license text is from the file COPYING and applies to the other
+source files in this directory.
+-----------------------------------------------------------------------------
+
+PCRE is a library of functions to support regular expressions whose syntax
+and semantics are as close as possible to those of the Perl 5 language.
+
+This is JavaScriptCore's variant of the PCRE library. While this library
+started out as a copy of PCRE, many of the features of PCRE have been
+removed.
+
+Copyright (c) 1997-2005 University of Cambridge. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+    * Neither the name of the University of Cambridge nor the name of Apple
+      Inc. nor the names of their contributors may be used to endorse or
+      promote products derived from this software without specific prior
+      written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+-----------------------------------------------------------------------------
+The following copyright lines are found in individual files other than
+ASCIICType.h
+-----------------------------------------------------------------------------
+
+
+Copyright (C) 2002, 2004, 2006, 2007 Apple Inc. All rights reserved.
+Copyright (C) 2002, 2004, 2006, 2007, 2008 Apple Inc.  All rights reserved.
+Copyright (C) 2007 Eric Seidel <eric@webkit.org>
+Copyright (c) 1997-2005 University of Cambridge
+Copyright (c) 1997-2005 University of Cambridge. All rights reserved.
+Copyright (c) 1997-2006 University of Cambridge
+Copyright (c) 2005, 2006, 2007 Apple Inc. All rights reserved.
diff --git a/plugin/jscre/config.h b/plugin/jscre/config.h
new file mode 100644
index 0000000..05914ad
--- /dev/null
+++ b/plugin/jscre/config.h
@@ -0,0 +1,143 @@
+
+/* On Unix-like systems config.in is converted by "configure" into config.h.
+Some other environments also support the use of "configure". PCRE is written in
+Standard C, but there are a few non-standard things it can cope with, allowing
+it to run on SunOS4 and other "close to standard" systems.
+
+On a non-Unix-like system you should just copy this file into config.h, and set
+up the macros the way you need them. You should normally change the definitions
+of HAVE_STRERROR and HAVE_MEMMOVE to 1. Unfortunately, because of the way
+autoconf works, these cannot be made the defaults. If your system has bcopy()
+and not memmove(), change the definition of HAVE_BCOPY instead of HAVE_MEMMOVE.
+If your system has neither bcopy() nor memmove(), leave them both as 0; an
+emulation function will be used. */
+
+/* If you are compiling for a system that uses EBCDIC instead of ASCII
+character codes, define this macro as 1. On systems that can use "configure",
+this can be done via --enable-ebcdic. */
+
+#ifndef EBCDIC
+#define EBCDIC 0
+#endif
+
+/* If you are compiling for a system other than a Unix-like system or Win32,
+and it needs some magic to be inserted before the definition of a function that
+is exported by the library, define this macro to contain the relevant magic. If
+you do not define this macro, it defaults to "extern" for a C compiler and
+"extern C" for a C++ compiler on non-Win32 systems. This macro apears at the
+start of every exported function that is part of the external API. It does not
+appear on functions that are "external" in the C sense, but which are internal
+to the library. */
+
+/* #define PCRE_DATA_SCOPE */
+
+/* Define the following macro to empty if the "const" keyword does not work. */
+
+#undef const
+
+/* Define the following macro to "unsigned" if <stddef.h> does not define
+size_t. */
+
+#undef size_t
+
+/* The following two definitions are mainly for the benefit of SunOS4, which
+does not have the strerror() or memmove() functions that should be present in
+all Standard C libraries. The macros HAVE_STRERROR and HAVE_MEMMOVE should
+normally be defined with the value 1 for other systems, but unfortunately we
+cannot make this the default because "configure" files generated by autoconf
+will only change 0 to 1; they won't change 1 to 0 if the functions are not
+found. */
+
+#define HAVE_STRERROR 1
+#define HAVE_MEMMOVE  1
+
+/* There are some non-Unix-like systems that don't even have bcopy(). If this
+macro is false, an emulation is used. If HAVE_MEMMOVE is set to 1, the value of
+HAVE_BCOPY is not relevant. */
+
+#define HAVE_BCOPY    0
+
+/* The value of NEWLINE determines the newline character. The default is to
+leave it up to the compiler, but some sites want to force a particular value.
+On Unix-like systems, "configure" can be used to override this default. */
+
+#ifndef NEWLINE
+#define NEWLINE '\n'
+#endif
+
+/* The value of LINK_SIZE determines the number of bytes used to store links as
+offsets within the compiled regex. The default is 2, which allows for compiled
+patterns up to 64K long. This covers the vast majority of cases. However, PCRE
+can also be compiled to use 3 or 4 bytes instead. This allows for longer
+patterns in extreme cases. On systems that support it, "configure" can be used
+to override this default. */
+
+#ifndef LINK_SIZE
+#define LINK_SIZE   2
+#endif
+
+/* When calling PCRE via the POSIX interface, additional working storage is
+required for holding the pointers to capturing substrings because PCRE requires
+three integers per substring, whereas the POSIX interface provides only two. If
+the number of expected substrings is small, the wrapper function uses space on
+the stack, because this is faster than using malloc() for each call. The
+threshold above which the stack is no longer used is defined by POSIX_MALLOC_
+THRESHOLD. On systems that support it, "configure" can be used to override this
+default. */
+
+#ifndef POSIX_MALLOC_THRESHOLD
+#define POSIX_MALLOC_THRESHOLD 10
+#endif
+
+/* PCRE uses recursive function calls to handle backtracking while matching.
+This can sometimes be a problem on systems that have stacks of limited size.
+Define NO_RECURSE to get a version that doesn't use recursion in the match()
+function; instead it creates its own stack by steam using pcre_recurse_malloc()
+to obtain memory from the heap. For more detail, see the comments and other
+stuff just above the match() function. On systems that support it, "configure"
+can be used to set this in the Makefile (use --disable-stack-for-recursion). */
+
+/* #define NO_RECURSE */
+
+/* The value of MATCH_LIMIT determines the default number of times the internal
+match() function can be called during a single execution of pcre_exec(). There
+is a runtime interface for setting a different limit. The limit exists in order
+to catch runaway regular expressions that take for ever to determine that they
+do not match. The default is set very large so that it does not accidentally
+catch legitimate cases. On systems that support it, "configure" can be used to
+override this default default. */
+
+#ifndef MATCH_LIMIT
+#define MATCH_LIMIT 10000000
+#endif
+
+/* The above limit applies to all calls of match(), whether or not they
+increase the recursion depth. In some environments it is desirable to limit the
+depth of recursive calls of match() more strictly, in order to restrict the
+maximum amount of stack (or heap, if NO_RECURSE is defined) that is used. The
+value of MATCH_LIMIT_RECURSION applies only to recursive calls of match(). To
+have any useful effect, it must be less than the value of MATCH_LIMIT. There is
+a runtime method for setting a different limit. On systems that support it,
+"configure" can be used to override this default default. */
+
+#ifndef MATCH_LIMIT_RECURSION
+#define MATCH_LIMIT_RECURSION MATCH_LIMIT
+#endif
+
+/* These three limits are parameterized just in case anybody ever wants to
+change them. Care must be taken if they are increased, because they guard
+against integer overflow caused by enormously large patterns. */
+
+#ifndef MAX_NAME_SIZE
+#define MAX_NAME_SIZE 32
+#endif
+
+#ifndef MAX_NAME_COUNT
+#define MAX_NAME_COUNT 10000
+#endif
+
+#ifndef MAX_DUPLENGTH
+#define MAX_DUPLENGTH 30000
+#endif
+
+/* End */
diff --git a/plugin/jscre/stdint.h b/plugin/jscre/stdint.h
new file mode 100644
index 0000000..d02608a
--- /dev/null
+++ b/plugin/jscre/stdint.h
@@ -0,0 +1,247 @@
+// ISO C9x  compliant stdint.h for Microsoft Visual Studio
+// Based on ISO/IEC 9899:TC2 Committee draft (May 6, 2005) WG14/N1124 
+// 
+//  Copyright (c) 2006-2008 Alexander Chemeris
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+// 
+//   1. Redistributions of source code must retain the above copyright notice,
+//      this list of conditions and the following disclaimer.
+// 
+//   2. Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+// 
+//   3. The name of the author may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
+// EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+// OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
+// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+// OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+// 
+///////////////////////////////////////////////////////////////////////////////
+
+#ifndef _MSC_VER // [
+#error "Use this header only with Microsoft Visual C++ compilers!"
+#endif // _MSC_VER ]
+
+#ifndef _MSC_STDINT_H_ // [
+#define _MSC_STDINT_H_
+
+#if _MSC_VER > 1000
+#pragma once
+#endif
+
+#include <limits.h>
+
+// For Visual Studio 6 in C++ mode and for many Visual Studio versions when
+// compiling for ARM we should wrap <wchar.h> include with 'extern "C++" {}'
+// or compiler give many errors like this:
+//   error C2733: second C linkage of overloaded function 'wmemchr' not allowed
+#ifdef __cplusplus
+extern "C" {
+#endif
+#  include <wchar.h>
+#ifdef __cplusplus
+}
+#endif
+
+// Define _W64 macros to mark types changing their size, like intptr_t.
+#ifndef _W64
+#  if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
+#     define _W64 __w64
+#  else
+#     define _W64
+#  endif
+#endif
+
+
+// 7.18.1 Integer types
+
+// 7.18.1.1 Exact-width integer types
+
+// Visual Studio 6 and Embedded Visual C++ 4 doesn't
+// realize that, e.g. char has the same size as __int8
+// so we give up on __intX for them.
+#if (_MSC_VER < 1300)
+   typedef signed char       int8_t;
+   typedef signed short      int16_t;
+   typedef signed int        int32_t;
+   typedef unsigned char     uint8_t;
+   typedef unsigned short    uint16_t;
+   typedef unsigned int      uint32_t;
+#else
+   typedef signed __int8     int8_t;
+   typedef signed __int16    int16_t;
+   typedef signed __int32    int32_t;
+   typedef unsigned __int8   uint8_t;
+   typedef unsigned __int16  uint16_t;
+   typedef unsigned __int32  uint32_t;
+#endif
+typedef signed __int64       int64_t;
+typedef unsigned __int64     uint64_t;
+
+
+// 7.18.1.2 Minimum-width integer types
+typedef int8_t    int_least8_t;
+typedef int16_t   int_least16_t;
+typedef int32_t   int_least32_t;
+typedef int64_t   int_least64_t;
+typedef uint8_t   uint_least8_t;
+typedef uint16_t  uint_least16_t;
+typedef uint32_t  uint_least32_t;
+typedef uint64_t  uint_least64_t;
+
+// 7.18.1.3 Fastest minimum-width integer types
+typedef int8_t    int_fast8_t;
+typedef int16_t   int_fast16_t;
+typedef int32_t   int_fast32_t;
+typedef int64_t   int_fast64_t;
+typedef uint8_t   uint_fast8_t;
+typedef uint16_t  uint_fast16_t;
+typedef uint32_t  uint_fast32_t;
+typedef uint64_t  uint_fast64_t;
+
+// 7.18.1.4 Integer types capable of holding object pointers
+#ifdef _WIN64 // [
+   typedef signed __int64    intptr_t;
+   typedef unsigned __int64  uintptr_t;
+#else // _WIN64 ][
+   typedef _W64 signed int   intptr_t;
+   typedef _W64 unsigned int uintptr_t;
+#endif // _WIN64 ]
+
+// 7.18.1.5 Greatest-width integer types
+typedef int64_t   intmax_t;
+typedef uint64_t  uintmax_t;
+
+
+// 7.18.2 Limits of specified-width integer types
+
+#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS) // [   See footnote 220 at page 257 and footnote 221 at page 259
+
+// 7.18.2.1 Limits of exact-width integer types
+#define INT8_MIN     ((int8_t)_I8_MIN)
+#define INT8_MAX     _I8_MAX
+#define INT16_MIN    ((int16_t)_I16_MIN)
+#define INT16_MAX    _I16_MAX
+#define INT32_MIN    ((int32_t)_I32_MIN)
+#define INT32_MAX    _I32_MAX
+#define INT64_MIN    ((int64_t)_I64_MIN)
+#define INT64_MAX    _I64_MAX
+#define UINT8_MAX    _UI8_MAX
+#define UINT16_MAX   _UI16_MAX
+#define UINT32_MAX   _UI32_MAX
+#define UINT64_MAX   _UI64_MAX
+
+// 7.18.2.2 Limits of minimum-width integer types
+#define INT_LEAST8_MIN    INT8_MIN
+#define INT_LEAST8_MAX    INT8_MAX
+#define INT_LEAST16_MIN   INT16_MIN
+#define INT_LEAST16_MAX   INT16_MAX
+#define INT_LEAST32_MIN   INT32_MIN
+#define INT_LEAST32_MAX   INT32_MAX
+#define INT_LEAST64_MIN   INT64_MIN
+#define INT_LEAST64_MAX   INT64_MAX
+#define UINT_LEAST8_MAX   UINT8_MAX
+#define UINT_LEAST16_MAX  UINT16_MAX
+#define UINT_LEAST32_MAX  UINT32_MAX
+#define UINT_LEAST64_MAX  UINT64_MAX
+
+// 7.18.2.3 Limits of fastest minimum-width integer types
+#define INT_FAST8_MIN    INT8_MIN
+#define INT_FAST8_MAX    INT8_MAX
+#define INT_FAST16_MIN   INT16_MIN
+#define INT_FAST16_MAX   INT16_MAX
+#define INT_FAST32_MIN   INT32_MIN
+#define INT_FAST32_MAX   INT32_MAX
+#define INT_FAST64_MIN   INT64_MIN
+#define INT_FAST64_MAX   INT64_MAX
+#define UINT_FAST8_MAX   UINT8_MAX
+#define UINT_FAST16_MAX  UINT16_MAX
+#define UINT_FAST32_MAX  UINT32_MAX
+#define UINT_FAST64_MAX  UINT64_MAX
+
+// 7.18.2.4 Limits of integer types capable of holding object pointers
+#ifdef _WIN64 // [
+#  define INTPTR_MIN   INT64_MIN
+#  define INTPTR_MAX   INT64_MAX
+#  define UINTPTR_MAX  UINT64_MAX
+#else // _WIN64 ][
+#  define INTPTR_MIN   INT32_MIN
+#  define INTPTR_MAX   INT32_MAX
+#  define UINTPTR_MAX  UINT32_MAX
+#endif // _WIN64 ]
+
+// 7.18.2.5 Limits of greatest-width integer types
+#define INTMAX_MIN   INT64_MIN
+#define INTMAX_MAX   INT64_MAX
+#define UINTMAX_MAX  UINT64_MAX
+
+// 7.18.3 Limits of other integer types
+
+#ifdef _WIN64 // [
+#  define PTRDIFF_MIN  _I64_MIN
+#  define PTRDIFF_MAX  _I64_MAX
+#else  // _WIN64 ][
+#  define PTRDIFF_MIN  _I32_MIN
+#  define PTRDIFF_MAX  _I32_MAX
+#endif  // _WIN64 ]
+
+#define SIG_ATOMIC_MIN  INT_MIN
+#define SIG_ATOMIC_MAX  INT_MAX
+
+#ifndef SIZE_MAX // [
+#  ifdef _WIN64 // [
+#     define SIZE_MAX  _UI64_MAX
+#  else // _WIN64 ][
+#     define SIZE_MAX  _UI32_MAX
+#  endif // _WIN64 ]
+#endif // SIZE_MAX ]
+
+// WCHAR_MIN and WCHAR_MAX are also defined in <wchar.h>
+#ifndef WCHAR_MIN // [
+#  define WCHAR_MIN  0
+#endif  // WCHAR_MIN ]
+#ifndef WCHAR_MAX // [
+#  define WCHAR_MAX  _UI16_MAX
+#endif  // WCHAR_MAX ]
+
+#define WINT_MIN  0
+#define WINT_MAX  _UI16_MAX
+
+#endif // __STDC_LIMIT_MACROS ]
+
+
+// 7.18.4 Limits of other integer types
+
+#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS) // [   See footnote 224 at page 260
+
+// 7.18.4.1 Macros for minimum-width integer constants
+
+#define INT8_C(val)  val##i8
+#define INT16_C(val) val##i16
+#define INT32_C(val) val##i32
+#define INT64_C(val) val##i64
+
+#define UINT8_C(val)  val##ui8
+#define UINT16_C(val) val##ui16
+#define UINT32_C(val) val##ui32
+#define UINT64_C(val) val##ui64
+
+// 7.18.4.2 Macros for greatest-width integer constants
+#define INTMAX_C   INT64_C
+#define UINTMAX_C  UINT64_C
+
+#endif // __STDC_CONSTANT_MACROS ]
+
+
+#endif // _MSC_STDINT_H_ ]
diff --git a/plugin/jscre/ucpinternal.h b/plugin/jscre/ucpinternal.h
new file mode 100644
index 0000000..c8bc4aa
--- /dev/null
+++ b/plugin/jscre/ucpinternal.h
@@ -0,0 +1,126 @@
+/* This is JavaScriptCore's variant of the PCRE library. While this library
+started out as a copy of PCRE, many of the features of PCRE have been
+removed. This library now supports only the regular expression features
+required by the JavaScript language specification, and has only the functions
+needed by JavaScriptCore and the rest of WebKit.
+
+                 Originally written by Philip Hazel
+           Copyright (c) 1997-2006 University of Cambridge
+    Copyright (C) 2002, 2004, 2006, 2007 Apple Inc. All rights reserved.
+
+-----------------------------------------------------------------------------
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+    * Neither the name of the University of Cambridge nor the names of its
+      contributors may be used to endorse or promote products derived from
+      this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+-----------------------------------------------------------------------------
+*/
+
+/*************************************************
+*           Unicode Property Table handler       *
+*************************************************/
+
+/* Internal header file defining the layout of the bits in each pair of 32-bit
+words that form a data item in the table. */
+
+typedef struct cnode {
+  unsigned f0;
+  unsigned f1;
+} cnode;
+
+/* Things for the f0 field */
+
+#define f0_scriptmask   0xff000000  /* Mask for script field */
+#define f0_scriptshift          24  /* Shift for script value */
+#define f0_rangeflag    0x00f00000  /* Flag for a range item */
+#define f0_charmask     0x001fffff  /* Mask for code point value */
+
+/* Things for the f1 field */
+
+#define f1_typemask     0xfc000000  /* Mask for char type field */
+#define f1_typeshift            26  /* Shift for the type field */
+#define f1_rangemask    0x0000ffff  /* Mask for a range offset */
+#define f1_casemask     0x0000ffff  /* Mask for a case offset */
+#define f1_caseneg      0xffff8000  /* Bits for negation */
+
+/* The data consists of a vector of structures of type cnode. The two unsigned
+32-bit integers are used as follows:
+
+(f0) (1) The most significant byte holds the script number. The numbers are
+         defined by the enum in ucp.h.
+
+     (2) The 0x00800000 bit is set if this entry defines a range of characters.
+         It is not set if this entry defines a single character
+
+     (3) The 0x00600000 bits are spare.
+
+     (4) The 0x001fffff bits contain the code point. No Unicode code point will
+         ever be greater than 0x0010ffff, so this should be OK for ever.
+
+(f1) (1) The 0xfc000000 bits contain the character type number. The numbers are
+         defined by an enum in ucp.h.
+
+     (2) The 0x03ff0000 bits are spare.
+
+     (3) The 0x0000ffff bits contain EITHER the unsigned offset to the top of
+         range if this entry defines a range, OR the *signed* offset to the
+         character's "other case" partner if this entry defines a single
+         character. There is no partner if the value is zero.
+
+-------------------------------------------------------------------------------
+| script (8) |.|.|.| codepoint (21) || type (6) |.|.| spare (8) | offset (16) |
+-------------------------------------------------------------------------------
+              | | |                              | |
+              | | |-> spare                      | |-> spare
+              | |                                |
+              | |-> spare                        |-> spare
+              |
+              |-> range flag
+
+The upper/lower casing information is set only for characters that come in
+pairs. The non-one-to-one mappings in the Unicode data are ignored.
+
+When searching the data, proceed as follows:
+
+(1) Set up for a binary chop search.
+
+(2) If the top is not greater than the bottom, the character is not in the
+    table. Its type must therefore be "Cn" ("Undefined").
+
+(3) Find the middle vector element.
+
+(4) Extract the code point and compare. If equal, we are done.
+
+(5) If the test character is smaller, set the top to the current point, and
+    goto (2).
+
+(6) If the current entry defines a range, compute the last character by adding
+    the offset, and see if the test character is within the range. If it is,
+    we are done.
+
+(7) Otherwise, set the bottom to one element past the current point and goto
+    (2).
+*/
+
+/* End of ucpinternal.h */
diff --git a/plugin/jscre/ucptable.cpp b/plugin/jscre/ucptable.cpp
new file mode 100644
index 0000000..011f7f5
--- /dev/null
+++ b/plugin/jscre/ucptable.cpp
@@ -0,0 +1,2968 @@
+/* This source module is automatically generated from the Unicode
+property table. See ucpinternal.h for a description of the layout. */
+
+static const cnode ucp_table[] = {
+  { 0x09800000, 0x0000001f },
+  { 0x09000020, 0x74000000 },
+  { 0x09800021, 0x54000002 },
+  { 0x09000024, 0x5c000000 },
+  { 0x09800025, 0x54000002 },
+  { 0x09000028, 0x58000000 },
+  { 0x09000029, 0x48000000 },
+  { 0x0900002a, 0x54000000 },
+  { 0x0900002b, 0x64000000 },
+  { 0x0900002c, 0x54000000 },
+  { 0x0900002d, 0x44000000 },
+  { 0x0980002e, 0x54000001 },
+  { 0x09800030, 0x34000009 },
+  { 0x0980003a, 0x54000001 },
+  { 0x0980003c, 0x64000002 },
+  { 0x0980003f, 0x54000001 },
+  { 0x21000041, 0x24000020 },
+  { 0x21000042, 0x24000020 },
+  { 0x21000043, 0x24000020 },
+  { 0x21000044, 0x24000020 },
+  { 0x21000045, 0x24000020 },
+  { 0x21000046, 0x24000020 },
+  { 0x21000047, 0x24000020 },
+  { 0x21000048, 0x24000020 },
+  { 0x21000049, 0x24000020 },
+  { 0x2100004a, 0x24000020 },
+  { 0x2100004b, 0x24000020 },
+  { 0x2100004c, 0x24000020 },
+  { 0x2100004d, 0x24000020 },
+  { 0x2100004e, 0x24000020 },
+  { 0x2100004f, 0x24000020 },
+  { 0x21000050, 0x24000020 },
+  { 0x21000051, 0x24000020 },
+  { 0x21000052, 0x24000020 },
+  { 0x21000053, 0x24000020 },
+  { 0x21000054, 0x24000020 },
+  { 0x21000055, 0x24000020 },
+  { 0x21000056, 0x24000020 },
+  { 0x21000057, 0x24000020 },
+  { 0x21000058, 0x24000020 },
+  { 0x21000059, 0x24000020 },
+  { 0x2100005a, 0x24000020 },
+  { 0x0900005b, 0x58000000 },
+  { 0x0900005c, 0x54000000 },
+  { 0x0900005d, 0x48000000 },
+  { 0x0900005e, 0x60000000 },
+  { 0x0900005f, 0x40000000 },
+  { 0x09000060, 0x60000000 },
+  { 0x21000061, 0x1400ffe0 },
+  { 0x21000062, 0x1400ffe0 },
+  { 0x21000063, 0x1400ffe0 },
+  { 0x21000064, 0x1400ffe0 },
+  { 0x21000065, 0x1400ffe0 },
+  { 0x21000066, 0x1400ffe0 },
+  { 0x21000067, 0x1400ffe0 },
+  { 0x21000068, 0x1400ffe0 },
+  { 0x21000069, 0x1400ffe0 },
+  { 0x2100006a, 0x1400ffe0 },
+  { 0x2100006b, 0x1400ffe0 },
+  { 0x2100006c, 0x1400ffe0 },
+  { 0x2100006d, 0x1400ffe0 },
+  { 0x2100006e, 0x1400ffe0 },
+  { 0x2100006f, 0x1400ffe0 },
+  { 0x21000070, 0x1400ffe0 },
+  { 0x21000071, 0x1400ffe0 },
+  { 0x21000072, 0x1400ffe0 },
+  { 0x21000073, 0x1400ffe0 },
+  { 0x21000074, 0x1400ffe0 },
+  { 0x21000075, 0x1400ffe0 },
+  { 0x21000076, 0x1400ffe0 },
+  { 0x21000077, 0x1400ffe0 },
+  { 0x21000078, 0x1400ffe0 },
+  { 0x21000079, 0x1400ffe0 },
+  { 0x2100007a, 0x1400ffe0 },
+  { 0x0900007b, 0x58000000 },
+  { 0x0900007c, 0x64000000 },
+  { 0x0900007d, 0x48000000 },
+  { 0x0900007e, 0x64000000 },
+  { 0x0980007f, 0x00000020 },
+  { 0x090000a0, 0x74000000 },
+  { 0x090000a1, 0x54000000 },
+  { 0x098000a2, 0x5c000003 },
+  { 0x098000a6, 0x68000001 },
+  { 0x090000a8, 0x60000000 },
+  { 0x090000a9, 0x68000000 },
+  { 0x210000aa, 0x14000000 },
+  { 0x090000ab, 0x50000000 },
+  { 0x090000ac, 0x64000000 },
+  { 0x090000ad, 0x04000000 },
+  { 0x090000ae, 0x68000000 },
+  { 0x090000af, 0x60000000 },
+  { 0x090000b0, 0x68000000 },
+  { 0x090000b1, 0x64000000 },
+  { 0x098000b2, 0x3c000001 },
+  { 0x090000b4, 0x60000000 },
+  { 0x090000b5, 0x140002e7 },
+  { 0x090000b6, 0x68000000 },
+  { 0x090000b7, 0x54000000 },
+  { 0x090000b8, 0x60000000 },
+  { 0x090000b9, 0x3c000000 },
+  { 0x210000ba, 0x14000000 },
+  { 0x090000bb, 0x4c000000 },
+  { 0x098000bc, 0x3c000002 },
+  { 0x090000bf, 0x54000000 },
+  { 0x210000c0, 0x24000020 },
+  { 0x210000c1, 0x24000020 },
+  { 0x210000c2, 0x24000020 },
+  { 0x210000c3, 0x24000020 },
+  { 0x210000c4, 0x24000020 },
+  { 0x210000c5, 0x24000020 },
+  { 0x210000c6, 0x24000020 },
+  { 0x210000c7, 0x24000020 },
+  { 0x210000c8, 0x24000020 },
+  { 0x210000c9, 0x24000020 },
+  { 0x210000ca, 0x24000020 },
+  { 0x210000cb, 0x24000020 },
+  { 0x210000cc, 0x24000020 },
+  { 0x210000cd, 0x24000020 },
+  { 0x210000ce, 0x24000020 },
+  { 0x210000cf, 0x24000020 },
+  { 0x210000d0, 0x24000020 },
+  { 0x210000d1, 0x24000020 },
+  { 0x210000d2, 0x24000020 },
+  { 0x210000d3, 0x24000020 },
+  { 0x210000d4, 0x24000020 },
+  { 0x210000d5, 0x24000020 },
+  { 0x210000d6, 0x24000020 },
+  { 0x090000d7, 0x64000000 },
+  { 0x210000d8, 0x24000020 },
+  { 0x210000d9, 0x24000020 },
+  { 0x210000da, 0x24000020 },
+  { 0x210000db, 0x24000020 },
+  { 0x210000dc, 0x24000020 },
+  { 0x210000dd, 0x24000020 },
+  { 0x210000de, 0x24000020 },
+  { 0x210000df, 0x14000000 },
+  { 0x210000e0, 0x1400ffe0 },
+  { 0x210000e1, 0x1400ffe0 },
+  { 0x210000e2, 0x1400ffe0 },
+  { 0x210000e3, 0x1400ffe0 },
+  { 0x210000e4, 0x1400ffe0 },
+  { 0x210000e5, 0x1400ffe0 },
+  { 0x210000e6, 0x1400ffe0 },
+  { 0x210000e7, 0x1400ffe0 },
+  { 0x210000e8, 0x1400ffe0 },
+  { 0x210000e9, 0x1400ffe0 },
+  { 0x210000ea, 0x1400ffe0 },
+  { 0x210000eb, 0x1400ffe0 },
+  { 0x210000ec, 0x1400ffe0 },
+  { 0x210000ed, 0x1400ffe0 },
+  { 0x210000ee, 0x1400ffe0 },
+  { 0x210000ef, 0x1400ffe0 },
+  { 0x210000f0, 0x1400ffe0 },
+  { 0x210000f1, 0x1400ffe0 },
+  { 0x210000f2, 0x1400ffe0 },
+  { 0x210000f3, 0x1400ffe0 },
+  { 0x210000f4, 0x1400ffe0 },
+  { 0x210000f5, 0x1400ffe0 },
+  { 0x210000f6, 0x1400ffe0 },
+  { 0x090000f7, 0x64000000 },
+  { 0x210000f8, 0x1400ffe0 },
+  { 0x210000f9, 0x1400ffe0 },
+  { 0x210000fa, 0x1400ffe0 },
+  { 0x210000fb, 0x1400ffe0 },
+  { 0x210000fc, 0x1400ffe0 },
+  { 0x210000fd, 0x1400ffe0 },
+  { 0x210000fe, 0x1400ffe0 },
+  { 0x210000ff, 0x14000079 },
+  { 0x21000100, 0x24000001 },
+  { 0x21000101, 0x1400ffff },
+  { 0x21000102, 0x24000001 },
+  { 0x21000103, 0x1400ffff },
+  { 0x21000104, 0x24000001 },
+  { 0x21000105, 0x1400ffff },
+  { 0x21000106, 0x24000001 },
+  { 0x21000107, 0x1400ffff },
+  { 0x21000108, 0x24000001 },
+  { 0x21000109, 0x1400ffff },
+  { 0x2100010a, 0x24000001 },
+  { 0x2100010b, 0x1400ffff },
+  { 0x2100010c, 0x24000001 },
+  { 0x2100010d, 0x1400ffff },
+  { 0x2100010e, 0x24000001 },
+  { 0x2100010f, 0x1400ffff },
+  { 0x21000110, 0x24000001 },
+  { 0x21000111, 0x1400ffff },
+  { 0x21000112, 0x24000001 },
+  { 0x21000113, 0x1400ffff },
+  { 0x21000114, 0x24000001 },
+  { 0x21000115, 0x1400ffff },
+  { 0x21000116, 0x24000001 },
+  { 0x21000117, 0x1400ffff },
+  { 0x21000118, 0x24000001 },
+  { 0x21000119, 0x1400ffff },
+  { 0x2100011a, 0x24000001 },
+  { 0x2100011b, 0x1400ffff },
+  { 0x2100011c, 0x24000001 },
+  { 0x2100011d, 0x1400ffff },
+  { 0x2100011e, 0x24000001 },
+  { 0x2100011f, 0x1400ffff },
+  { 0x21000120, 0x24000001 },
+  { 0x21000121, 0x1400ffff },
+  { 0x21000122, 0x24000001 },
+  { 0x21000123, 0x1400ffff },
+  { 0x21000124, 0x24000001 },
+  { 0x21000125, 0x1400ffff },
+  { 0x21000126, 0x24000001 },
+  { 0x21000127, 0x1400ffff },
+  { 0x21000128, 0x24000001 },
+  { 0x21000129, 0x1400ffff },
+  { 0x2100012a, 0x24000001 },
+  { 0x2100012b, 0x1400ffff },
+  { 0x2100012c, 0x24000001 },
+  { 0x2100012d, 0x1400ffff },
+  { 0x2100012e, 0x24000001 },
+  { 0x2100012f, 0x1400ffff },
+  { 0x21000130, 0x2400ff39 },
+  { 0x21000131, 0x1400ff18 },
+  { 0x21000132, 0x24000001 },
+  { 0x21000133, 0x1400ffff },
+  { 0x21000134, 0x24000001 },
+  { 0x21000135, 0x1400ffff },
+  { 0x21000136, 0x24000001 },
+  { 0x21000137, 0x1400ffff },
+  { 0x21000138, 0x14000000 },
+  { 0x21000139, 0x24000001 },
+  { 0x2100013a, 0x1400ffff },
+  { 0x2100013b, 0x24000001 },
+  { 0x2100013c, 0x1400ffff },
+  { 0x2100013d, 0x24000001 },
+  { 0x2100013e, 0x1400ffff },
+  { 0x2100013f, 0x24000001 },
+  { 0x21000140, 0x1400ffff },
+  { 0x21000141, 0x24000001 },
+  { 0x21000142, 0x1400ffff },
+  { 0x21000143, 0x24000001 },
+  { 0x21000144, 0x1400ffff },
+  { 0x21000145, 0x24000001 },
+  { 0x21000146, 0x1400ffff },
+  { 0x21000147, 0x24000001 },
+  { 0x21000148, 0x1400ffff },
+  { 0x21000149, 0x14000000 },
+  { 0x2100014a, 0x24000001 },
+  { 0x2100014b, 0x1400ffff },
+  { 0x2100014c, 0x24000001 },
+  { 0x2100014d, 0x1400ffff },
+  { 0x2100014e, 0x24000001 },
+  { 0x2100014f, 0x1400ffff },
+  { 0x21000150, 0x24000001 },
+  { 0x21000151, 0x1400ffff },
+  { 0x21000152, 0x24000001 },
+  { 0x21000153, 0x1400ffff },
+  { 0x21000154, 0x24000001 },
+  { 0x21000155, 0x1400ffff },
+  { 0x21000156, 0x24000001 },
+  { 0x21000157, 0x1400ffff },
+  { 0x21000158, 0x24000001 },
+  { 0x21000159, 0x1400ffff },
+  { 0x2100015a, 0x24000001 },
+  { 0x2100015b, 0x1400ffff },
+  { 0x2100015c, 0x24000001 },
+  { 0x2100015d, 0x1400ffff },
+  { 0x2100015e, 0x24000001 },
+  { 0x2100015f, 0x1400ffff },
+  { 0x21000160, 0x24000001 },
+  { 0x21000161, 0x1400ffff },
+  { 0x21000162, 0x24000001 },
+  { 0x21000163, 0x1400ffff },
+  { 0x21000164, 0x24000001 },
+  { 0x21000165, 0x1400ffff },
+  { 0x21000166, 0x24000001 },
+  { 0x21000167, 0x1400ffff },
+  { 0x21000168, 0x24000001 },
+  { 0x21000169, 0x1400ffff },
+  { 0x2100016a, 0x24000001 },
+  { 0x2100016b, 0x1400ffff },
+  { 0x2100016c, 0x24000001 },
+  { 0x2100016d, 0x1400ffff },
+  { 0x2100016e, 0x24000001 },
+  { 0x2100016f, 0x1400ffff },
+  { 0x21000170, 0x24000001 },
+  { 0x21000171, 0x1400ffff },
+  { 0x21000172, 0x24000001 },
+  { 0x21000173, 0x1400ffff },
+  { 0x21000174, 0x24000001 },
+  { 0x21000175, 0x1400ffff },
+  { 0x21000176, 0x24000001 },
+  { 0x21000177, 0x1400ffff },
+  { 0x21000178, 0x2400ff87 },
+  { 0x21000179, 0x24000001 },
+  { 0x2100017a, 0x1400ffff },
+  { 0x2100017b, 0x24000001 },
+  { 0x2100017c, 0x1400ffff },
+  { 0x2100017d, 0x24000001 },
+  { 0x2100017e, 0x1400ffff },
+  { 0x2100017f, 0x1400fed4 },
+  { 0x21000180, 0x14000000 },
+  { 0x21000181, 0x240000d2 },
+  { 0x21000182, 0x24000001 },
+  { 0x21000183, 0x1400ffff },
+  { 0x21000184, 0x24000001 },
+  { 0x21000185, 0x1400ffff },
+  { 0x21000186, 0x240000ce },
+  { 0x21000187, 0x24000001 },
+  { 0x21000188, 0x1400ffff },
+  { 0x21000189, 0x240000cd },
+  { 0x2100018a, 0x240000cd },
+  { 0x2100018b, 0x24000001 },
+  { 0x2100018c, 0x1400ffff },
+  { 0x2100018d, 0x14000000 },
+  { 0x2100018e, 0x2400004f },
+  { 0x2100018f, 0x240000ca },
+  { 0x21000190, 0x240000cb },
+  { 0x21000191, 0x24000001 },
+  { 0x21000192, 0x1400ffff },
+  { 0x21000193, 0x240000cd },
+  { 0x21000194, 0x240000cf },
+  { 0x21000195, 0x14000061 },
+  { 0x21000196, 0x240000d3 },
+  { 0x21000197, 0x240000d1 },
+  { 0x21000198, 0x24000001 },
+  { 0x21000199, 0x1400ffff },
+  { 0x2100019a, 0x140000a3 },
+  { 0x2100019b, 0x14000000 },
+  { 0x2100019c, 0x240000d3 },
+  { 0x2100019d, 0x240000d5 },
+  { 0x2100019e, 0x14000082 },
+  { 0x2100019f, 0x240000d6 },
+  { 0x210001a0, 0x24000001 },
+  { 0x210001a1, 0x1400ffff },
+  { 0x210001a2, 0x24000001 },
+  { 0x210001a3, 0x1400ffff },
+  { 0x210001a4, 0x24000001 },
+  { 0x210001a5, 0x1400ffff },
+  { 0x210001a6, 0x240000da },
+  { 0x210001a7, 0x24000001 },
+  { 0x210001a8, 0x1400ffff },
+  { 0x210001a9, 0x240000da },
+  { 0x218001aa, 0x14000001 },
+  { 0x210001ac, 0x24000001 },
+  { 0x210001ad, 0x1400ffff },
+  { 0x210001ae, 0x240000da },
+  { 0x210001af, 0x24000001 },
+  { 0x210001b0, 0x1400ffff },
+  { 0x210001b1, 0x240000d9 },
+  { 0x210001b2, 0x240000d9 },
+  { 0x210001b3, 0x24000001 },
+  { 0x210001b4, 0x1400ffff },
+  { 0x210001b5, 0x24000001 },
+  { 0x210001b6, 0x1400ffff },
+  { 0x210001b7, 0x240000db },
+  { 0x210001b8, 0x24000001 },
+  { 0x210001b9, 0x1400ffff },
+  { 0x210001ba, 0x14000000 },
+  { 0x210001bb, 0x1c000000 },
+  { 0x210001bc, 0x24000001 },
+  { 0x210001bd, 0x1400ffff },
+  { 0x210001be, 0x14000000 },
+  { 0x210001bf, 0x14000038 },
+  { 0x218001c0, 0x1c000003 },
+  { 0x210001c4, 0x24000002 },
+  { 0x210001c5, 0x2000ffff },
+  { 0x210001c6, 0x1400fffe },
+  { 0x210001c7, 0x24000002 },
+  { 0x210001c8, 0x2000ffff },
+  { 0x210001c9, 0x1400fffe },
+  { 0x210001ca, 0x24000002 },
+  { 0x210001cb, 0x2000ffff },
+  { 0x210001cc, 0x1400fffe },
+  { 0x210001cd, 0x24000001 },
+  { 0x210001ce, 0x1400ffff },
+  { 0x210001cf, 0x24000001 },
+  { 0x210001d0, 0x1400ffff },
+  { 0x210001d1, 0x24000001 },
+  { 0x210001d2, 0x1400ffff },
+  { 0x210001d3, 0x24000001 },
+  { 0x210001d4, 0x1400ffff },
+  { 0x210001d5, 0x24000001 },
+  { 0x210001d6, 0x1400ffff },
+  { 0x210001d7, 0x24000001 },
+  { 0x210001d8, 0x1400ffff },
+  { 0x210001d9, 0x24000001 },
+  { 0x210001da, 0x1400ffff },
+  { 0x210001db, 0x24000001 },
+  { 0x210001dc, 0x1400ffff },
+  { 0x210001dd, 0x1400ffb1 },
+  { 0x210001de, 0x24000001 },
+  { 0x210001df, 0x1400ffff },
+  { 0x210001e0, 0x24000001 },
+  { 0x210001e1, 0x1400ffff },
+  { 0x210001e2, 0x24000001 },
+  { 0x210001e3, 0x1400ffff },
+  { 0x210001e4, 0x24000001 },
+  { 0x210001e5, 0x1400ffff },
+  { 0x210001e6, 0x24000001 },
+  { 0x210001e7, 0x1400ffff },
+  { 0x210001e8, 0x24000001 },
+  { 0x210001e9, 0x1400ffff },
+  { 0x210001ea, 0x24000001 },
+  { 0x210001eb, 0x1400ffff },
+  { 0x210001ec, 0x24000001 },
+  { 0x210001ed, 0x1400ffff },
+  { 0x210001ee, 0x24000001 },
+  { 0x210001ef, 0x1400ffff },
+  { 0x210001f0, 0x14000000 },
+  { 0x210001f1, 0x24000002 },
+  { 0x210001f2, 0x2000ffff },
+  { 0x210001f3, 0x1400fffe },
+  { 0x210001f4, 0x24000001 },
+  { 0x210001f5, 0x1400ffff },
+  { 0x210001f6, 0x2400ff9f },
+  { 0x210001f7, 0x2400ffc8 },
+  { 0x210001f8, 0x24000001 },
+  { 0x210001f9, 0x1400ffff },
+  { 0x210001fa, 0x24000001 },
+  { 0x210001fb, 0x1400ffff },
+  { 0x210001fc, 0x24000001 },
+  { 0x210001fd, 0x1400ffff },
+  { 0x210001fe, 0x24000001 },
+  { 0x210001ff, 0x1400ffff },
+  { 0x21000200, 0x24000001 },
+  { 0x21000201, 0x1400ffff },
+  { 0x21000202, 0x24000001 },
+  { 0x21000203, 0x1400ffff },
+  { 0x21000204, 0x24000001 },
+  { 0x21000205, 0x1400ffff },
+  { 0x21000206, 0x24000001 },
+  { 0x21000207, 0x1400ffff },
+  { 0x21000208, 0x24000001 },
+  { 0x21000209, 0x1400ffff },
+  { 0x2100020a, 0x24000001 },
+  { 0x2100020b, 0x1400ffff },
+  { 0x2100020c, 0x24000001 },
+  { 0x2100020d, 0x1400ffff },
+  { 0x2100020e, 0x24000001 },
+  { 0x2100020f, 0x1400ffff },
+  { 0x21000210, 0x24000001 },
+  { 0x21000211, 0x1400ffff },
+  { 0x21000212, 0x24000001 },
+  { 0x21000213, 0x1400ffff },
+  { 0x21000214, 0x24000001 },
+  { 0x21000215, 0x1400ffff },
+  { 0x21000216, 0x24000001 },
+  { 0x21000217, 0x1400ffff },
+  { 0x21000218, 0x24000001 },
+  { 0x21000219, 0x1400ffff },
+  { 0x2100021a, 0x24000001 },
+  { 0x2100021b, 0x1400ffff },
+  { 0x2100021c, 0x24000001 },
+  { 0x2100021d, 0x1400ffff },
+  { 0x2100021e, 0x24000001 },
+  { 0x2100021f, 0x1400ffff },
+  { 0x21000220, 0x2400ff7e },
+  { 0x21000221, 0x14000000 },
+  { 0x21000222, 0x24000001 },
+  { 0x21000223, 0x1400ffff },
+  { 0x21000224, 0x24000001 },
+  { 0x21000225, 0x1400ffff },
+  { 0x21000226, 0x24000001 },
+  { 0x21000227, 0x1400ffff },
+  { 0x21000228, 0x24000001 },
+  { 0x21000229, 0x1400ffff },
+  { 0x2100022a, 0x24000001 },
+  { 0x2100022b, 0x1400ffff },
+  { 0x2100022c, 0x24000001 },
+  { 0x2100022d, 0x1400ffff },
+  { 0x2100022e, 0x24000001 },
+  { 0x2100022f, 0x1400ffff },
+  { 0x21000230, 0x24000001 },
+  { 0x21000231, 0x1400ffff },
+  { 0x21000232, 0x24000001 },
+  { 0x21000233, 0x1400ffff },
+  { 0x21800234, 0x14000005 },
+  { 0x2100023a, 0x24000000 },
+  { 0x2100023b, 0x24000001 },
+  { 0x2100023c, 0x1400ffff },
+  { 0x2100023d, 0x2400ff5d },
+  { 0x2100023e, 0x24000000 },
+  { 0x2180023f, 0x14000001 },
+  { 0x21000241, 0x24000053 },
+  { 0x21800250, 0x14000002 },
+  { 0x21000253, 0x1400ff2e },
+  { 0x21000254, 0x1400ff32 },
+  { 0x21000255, 0x14000000 },
+  { 0x21000256, 0x1400ff33 },
+  { 0x21000257, 0x1400ff33 },
+  { 0x21000258, 0x14000000 },
+  { 0x21000259, 0x1400ff36 },
+  { 0x2100025a, 0x14000000 },
+  { 0x2100025b, 0x1400ff35 },
+  { 0x2180025c, 0x14000003 },
+  { 0x21000260, 0x1400ff33 },
+  { 0x21800261, 0x14000001 },
+  { 0x21000263, 0x1400ff31 },
+  { 0x21800264, 0x14000003 },
+  { 0x21000268, 0x1400ff2f },
+  { 0x21000269, 0x1400ff2d },
+  { 0x2180026a, 0x14000004 },
+  { 0x2100026f, 0x1400ff2d },
+  { 0x21800270, 0x14000001 },
+  { 0x21000272, 0x1400ff2b },
+  { 0x21800273, 0x14000001 },
+  { 0x21000275, 0x1400ff2a },
+  { 0x21800276, 0x14000009 },
+  { 0x21000280, 0x1400ff26 },
+  { 0x21800281, 0x14000001 },
+  { 0x21000283, 0x1400ff26 },
+  { 0x21800284, 0x14000003 },
+  { 0x21000288, 0x1400ff26 },
+  { 0x21000289, 0x14000000 },
+  { 0x2100028a, 0x1400ff27 },
+  { 0x2100028b, 0x1400ff27 },
+  { 0x2180028c, 0x14000005 },
+  { 0x21000292, 0x1400ff25 },
+  { 0x21000293, 0x14000000 },
+  { 0x21000294, 0x1400ffad },
+  { 0x21800295, 0x1400001a },
+  { 0x218002b0, 0x18000011 },
+  { 0x098002c2, 0x60000003 },
+  { 0x098002c6, 0x1800000b },
+  { 0x098002d2, 0x6000000d },
+  { 0x218002e0, 0x18000004 },
+  { 0x098002e5, 0x60000008 },
+  { 0x090002ee, 0x18000000 },
+  { 0x098002ef, 0x60000010 },
+  { 0x1b800300, 0x30000044 },
+  { 0x1b000345, 0x30000054 },
+  { 0x1b800346, 0x30000029 },
+  { 0x13800374, 0x60000001 },
+  { 0x1300037a, 0x18000000 },
+  { 0x0900037e, 0x54000000 },
+  { 0x13800384, 0x60000001 },
+  { 0x13000386, 0x24000026 },
+  { 0x09000387, 0x54000000 },
+  { 0x13000388, 0x24000025 },
+  { 0x13000389, 0x24000025 },
+  { 0x1300038a, 0x24000025 },
+  { 0x1300038c, 0x24000040 },
+  { 0x1300038e, 0x2400003f },
+  { 0x1300038f, 0x2400003f },
+  { 0x13000390, 0x14000000 },
+  { 0x13000391, 0x24000020 },
+  { 0x13000392, 0x24000020 },
+  { 0x13000393, 0x24000020 },
+  { 0x13000394, 0x24000020 },
+  { 0x13000395, 0x24000020 },
+  { 0x13000396, 0x24000020 },
+  { 0x13000397, 0x24000020 },
+  { 0x13000398, 0x24000020 },
+  { 0x13000399, 0x24000020 },
+  { 0x1300039a, 0x24000020 },
+  { 0x1300039b, 0x24000020 },
+  { 0x1300039c, 0x24000020 },
+  { 0x1300039d, 0x24000020 },
+  { 0x1300039e, 0x24000020 },
+  { 0x1300039f, 0x24000020 },
+  { 0x130003a0, 0x24000020 },
+  { 0x130003a1, 0x24000020 },
+  { 0x130003a3, 0x24000020 },
+  { 0x130003a4, 0x24000020 },
+  { 0x130003a5, 0x24000020 },
+  { 0x130003a6, 0x24000020 },
+  { 0x130003a7, 0x24000020 },
+  { 0x130003a8, 0x24000020 },
+  { 0x130003a9, 0x24000020 },
+  { 0x130003aa, 0x24000020 },
+  { 0x130003ab, 0x24000020 },
+  { 0x130003ac, 0x1400ffda },
+  { 0x130003ad, 0x1400ffdb },
+  { 0x130003ae, 0x1400ffdb },
+  { 0x130003af, 0x1400ffdb },
+  { 0x130003b0, 0x14000000 },
+  { 0x130003b1, 0x1400ffe0 },
+  { 0x130003b2, 0x1400ffe0 },
+  { 0x130003b3, 0x1400ffe0 },
+  { 0x130003b4, 0x1400ffe0 },
+  { 0x130003b5, 0x1400ffe0 },
+  { 0x130003b6, 0x1400ffe0 },
+  { 0x130003b7, 0x1400ffe0 },
+  { 0x130003b8, 0x1400ffe0 },
+  { 0x130003b9, 0x1400ffe0 },
+  { 0x130003ba, 0x1400ffe0 },
+  { 0x130003bb, 0x1400ffe0 },
+  { 0x130003bc, 0x1400ffe0 },
+  { 0x130003bd, 0x1400ffe0 },
+  { 0x130003be, 0x1400ffe0 },
+  { 0x130003bf, 0x1400ffe0 },
+  { 0x130003c0, 0x1400ffe0 },
+  { 0x130003c1, 0x1400ffe0 },
+  { 0x130003c2, 0x1400ffe1 },
+  { 0x130003c3, 0x1400ffe0 },
+  { 0x130003c4, 0x1400ffe0 },
+  { 0x130003c5, 0x1400ffe0 },
+  { 0x130003c6, 0x1400ffe0 },
+  { 0x130003c7, 0x1400ffe0 },
+  { 0x130003c8, 0x1400ffe0 },
+  { 0x130003c9, 0x1400ffe0 },
+  { 0x130003ca, 0x1400ffe0 },
+  { 0x130003cb, 0x1400ffe0 },
+  { 0x130003cc, 0x1400ffc0 },
+  { 0x130003cd, 0x1400ffc1 },
+  { 0x130003ce, 0x1400ffc1 },
+  { 0x130003d0, 0x1400ffc2 },
+  { 0x130003d1, 0x1400ffc7 },
+  { 0x138003d2, 0x24000002 },
+  { 0x130003d5, 0x1400ffd1 },
+  { 0x130003d6, 0x1400ffca },
+  { 0x130003d7, 0x14000000 },
+  { 0x130003d8, 0x24000001 },
+  { 0x130003d9, 0x1400ffff },
+  { 0x130003da, 0x24000001 },
+  { 0x130003db, 0x1400ffff },
+  { 0x130003dc, 0x24000001 },
+  { 0x130003dd, 0x1400ffff },
+  { 0x130003de, 0x24000001 },
+  { 0x130003df, 0x1400ffff },
+  { 0x130003e0, 0x24000001 },
+  { 0x130003e1, 0x1400ffff },
+  { 0x0a0003e2, 0x24000001 },
+  { 0x0a0003e3, 0x1400ffff },
+  { 0x0a0003e4, 0x24000001 },
+  { 0x0a0003e5, 0x1400ffff },
+  { 0x0a0003e6, 0x24000001 },
+  { 0x0a0003e7, 0x1400ffff },
+  { 0x0a0003e8, 0x24000001 },
+  { 0x0a0003e9, 0x1400ffff },
+  { 0x0a0003ea, 0x24000001 },
+  { 0x0a0003eb, 0x1400ffff },
+  { 0x0a0003ec, 0x24000001 },
+  { 0x0a0003ed, 0x1400ffff },
+  { 0x0a0003ee, 0x24000001 },
+  { 0x0a0003ef, 0x1400ffff },
+  { 0x130003f0, 0x1400ffaa },
+  { 0x130003f1, 0x1400ffb0 },
+  { 0x130003f2, 0x14000007 },
+  { 0x130003f3, 0x14000000 },
+  { 0x130003f4, 0x2400ffc4 },
+  { 0x130003f5, 0x1400ffa0 },
+  { 0x130003f6, 0x64000000 },
+  { 0x130003f7, 0x24000001 },
+  { 0x130003f8, 0x1400ffff },
+  { 0x130003f9, 0x2400fff9 },
+  { 0x130003fa, 0x24000001 },
+  { 0x130003fb, 0x1400ffff },
+  { 0x130003fc, 0x14000000 },
+  { 0x138003fd, 0x24000002 },
+  { 0x0c000400, 0x24000050 },
+  { 0x0c000401, 0x24000050 },
+  { 0x0c000402, 0x24000050 },
+  { 0x0c000403, 0x24000050 },
+  { 0x0c000404, 0x24000050 },
+  { 0x0c000405, 0x24000050 },
+  { 0x0c000406, 0x24000050 },
+  { 0x0c000407, 0x24000050 },
+  { 0x0c000408, 0x24000050 },
+  { 0x0c000409, 0x24000050 },
+  { 0x0c00040a, 0x24000050 },
+  { 0x0c00040b, 0x24000050 },
+  { 0x0c00040c, 0x24000050 },
+  { 0x0c00040d, 0x24000050 },
+  { 0x0c00040e, 0x24000050 },
+  { 0x0c00040f, 0x24000050 },
+  { 0x0c000410, 0x24000020 },
+  { 0x0c000411, 0x24000020 },
+  { 0x0c000412, 0x24000020 },
+  { 0x0c000413, 0x24000020 },
+  { 0x0c000414, 0x24000020 },
+  { 0x0c000415, 0x24000020 },
+  { 0x0c000416, 0x24000020 },
+  { 0x0c000417, 0x24000020 },
+  { 0x0c000418, 0x24000020 },
+  { 0x0c000419, 0x24000020 },
+  { 0x0c00041a, 0x24000020 },
+  { 0x0c00041b, 0x24000020 },
+  { 0x0c00041c, 0x24000020 },
+  { 0x0c00041d, 0x24000020 },
+  { 0x0c00041e, 0x24000020 },
+  { 0x0c00041f, 0x24000020 },
+  { 0x0c000420, 0x24000020 },
+  { 0x0c000421, 0x24000020 },
+  { 0x0c000422, 0x24000020 },
+  { 0x0c000423, 0x24000020 },
+  { 0x0c000424, 0x24000020 },
+  { 0x0c000425, 0x24000020 },
+  { 0x0c000426, 0x24000020 },
+  { 0x0c000427, 0x24000020 },
+  { 0x0c000428, 0x24000020 },
+  { 0x0c000429, 0x24000020 },
+  { 0x0c00042a, 0x24000020 },
+  { 0x0c00042b, 0x24000020 },
+  { 0x0c00042c, 0x24000020 },
+  { 0x0c00042d, 0x24000020 },
+  { 0x0c00042e, 0x24000020 },
+  { 0x0c00042f, 0x24000020 },
+  { 0x0c000430, 0x1400ffe0 },
+  { 0x0c000431, 0x1400ffe0 },
+  { 0x0c000432, 0x1400ffe0 },
+  { 0x0c000433, 0x1400ffe0 },
+  { 0x0c000434, 0x1400ffe0 },
+  { 0x0c000435, 0x1400ffe0 },
+  { 0x0c000436, 0x1400ffe0 },
+  { 0x0c000437, 0x1400ffe0 },
+  { 0x0c000438, 0x1400ffe0 },
+  { 0x0c000439, 0x1400ffe0 },
+  { 0x0c00043a, 0x1400ffe0 },
+  { 0x0c00043b, 0x1400ffe0 },
+  { 0x0c00043c, 0x1400ffe0 },
+  { 0x0c00043d, 0x1400ffe0 },
+  { 0x0c00043e, 0x1400ffe0 },
+  { 0x0c00043f, 0x1400ffe0 },
+  { 0x0c000440, 0x1400ffe0 },
+  { 0x0c000441, 0x1400ffe0 },
+  { 0x0c000442, 0x1400ffe0 },
+  { 0x0c000443, 0x1400ffe0 },
+  { 0x0c000444, 0x1400ffe0 },
+  { 0x0c000445, 0x1400ffe0 },
+  { 0x0c000446, 0x1400ffe0 },
+  { 0x0c000447, 0x1400ffe0 },
+  { 0x0c000448, 0x1400ffe0 },
+  { 0x0c000449, 0x1400ffe0 },
+  { 0x0c00044a, 0x1400ffe0 },
+  { 0x0c00044b, 0x1400ffe0 },
+  { 0x0c00044c, 0x1400ffe0 },
+  { 0x0c00044d, 0x1400ffe0 },
+  { 0x0c00044e, 0x1400ffe0 },
+  { 0x0c00044f, 0x1400ffe0 },
+  { 0x0c000450, 0x1400ffb0 },
+  { 0x0c000451, 0x1400ffb0 },
+  { 0x0c000452, 0x1400ffb0 },
+  { 0x0c000453, 0x1400ffb0 },
+  { 0x0c000454, 0x1400ffb0 },
+  { 0x0c000455, 0x1400ffb0 },
+  { 0x0c000456, 0x1400ffb0 },
+  { 0x0c000457, 0x1400ffb0 },
+  { 0x0c000458, 0x1400ffb0 },
+  { 0x0c000459, 0x1400ffb0 },
+  { 0x0c00045a, 0x1400ffb0 },
+  { 0x0c00045b, 0x1400ffb0 },
+  { 0x0c00045c, 0x1400ffb0 },
+  { 0x0c00045d, 0x1400ffb0 },
+  { 0x0c00045e, 0x1400ffb0 },
+  { 0x0c00045f, 0x1400ffb0 },
+  { 0x0c000460, 0x24000001 },
+  { 0x0c000461, 0x1400ffff },
+  { 0x0c000462, 0x24000001 },
+  { 0x0c000463, 0x1400ffff },
+  { 0x0c000464, 0x24000001 },
+  { 0x0c000465, 0x1400ffff },
+  { 0x0c000466, 0x24000001 },
+  { 0x0c000467, 0x1400ffff },
+  { 0x0c000468, 0x24000001 },
+  { 0x0c000469, 0x1400ffff },
+  { 0x0c00046a, 0x24000001 },
+  { 0x0c00046b, 0x1400ffff },
+  { 0x0c00046c, 0x24000001 },
+  { 0x0c00046d, 0x1400ffff },
+  { 0x0c00046e, 0x24000001 },
+  { 0x0c00046f, 0x1400ffff },
+  { 0x0c000470, 0x24000001 },
+  { 0x0c000471, 0x1400ffff },
+  { 0x0c000472, 0x24000001 },
+  { 0x0c000473, 0x1400ffff },
+  { 0x0c000474, 0x24000001 },
+  { 0x0c000475, 0x1400ffff },
+  { 0x0c000476, 0x24000001 },
+  { 0x0c000477, 0x1400ffff },
+  { 0x0c000478, 0x24000001 },
+  { 0x0c000479, 0x1400ffff },
+  { 0x0c00047a, 0x24000001 },
+  { 0x0c00047b, 0x1400ffff },
+  { 0x0c00047c, 0x24000001 },
+  { 0x0c00047d, 0x1400ffff },
+  { 0x0c00047e, 0x24000001 },
+  { 0x0c00047f, 0x1400ffff },
+  { 0x0c000480, 0x24000001 },
+  { 0x0c000481, 0x1400ffff },
+  { 0x0c000482, 0x68000000 },
+  { 0x0c800483, 0x30000003 },
+  { 0x0c800488, 0x2c000001 },
+  { 0x0c00048a, 0x24000001 },
+  { 0x0c00048b, 0x1400ffff },
+  { 0x0c00048c, 0x24000001 },
+  { 0x0c00048d, 0x1400ffff },
+  { 0x0c00048e, 0x24000001 },
+  { 0x0c00048f, 0x1400ffff },
+  { 0x0c000490, 0x24000001 },
+  { 0x0c000491, 0x1400ffff },
+  { 0x0c000492, 0x24000001 },
+  { 0x0c000493, 0x1400ffff },
+  { 0x0c000494, 0x24000001 },
+  { 0x0c000495, 0x1400ffff },
+  { 0x0c000496, 0x24000001 },
+  { 0x0c000497, 0x1400ffff },
+  { 0x0c000498, 0x24000001 },
+  { 0x0c000499, 0x1400ffff },
+  { 0x0c00049a, 0x24000001 },
+  { 0x0c00049b, 0x1400ffff },
+  { 0x0c00049c, 0x24000001 },
+  { 0x0c00049d, 0x1400ffff },
+  { 0x0c00049e, 0x24000001 },
+  { 0x0c00049f, 0x1400ffff },
+  { 0x0c0004a0, 0x24000001 },
+  { 0x0c0004a1, 0x1400ffff },
+  { 0x0c0004a2, 0x24000001 },
+  { 0x0c0004a3, 0x1400ffff },
+  { 0x0c0004a4, 0x24000001 },
+  { 0x0c0004a5, 0x1400ffff },
+  { 0x0c0004a6, 0x24000001 },
+  { 0x0c0004a7, 0x1400ffff },
+  { 0x0c0004a8, 0x24000001 },
+  { 0x0c0004a9, 0x1400ffff },
+  { 0x0c0004aa, 0x24000001 },
+  { 0x0c0004ab, 0x1400ffff },
+  { 0x0c0004ac, 0x24000001 },
+  { 0x0c0004ad, 0x1400ffff },
+  { 0x0c0004ae, 0x24000001 },
+  { 0x0c0004af, 0x1400ffff },
+  { 0x0c0004b0, 0x24000001 },
+  { 0x0c0004b1, 0x1400ffff },
+  { 0x0c0004b2, 0x24000001 },
+  { 0x0c0004b3, 0x1400ffff },
+  { 0x0c0004b4, 0x24000001 },
+  { 0x0c0004b5, 0x1400ffff },
+  { 0x0c0004b6, 0x24000001 },
+  { 0x0c0004b7, 0x1400ffff },
+  { 0x0c0004b8, 0x24000001 },
+  { 0x0c0004b9, 0x1400ffff },
+  { 0x0c0004ba, 0x24000001 },
+  { 0x0c0004bb, 0x1400ffff },
+  { 0x0c0004bc, 0x24000001 },
+  { 0x0c0004bd, 0x1400ffff },
+  { 0x0c0004be, 0x24000001 },
+  { 0x0c0004bf, 0x1400ffff },
+  { 0x0c0004c0, 0x24000000 },
+  { 0x0c0004c1, 0x24000001 },
+  { 0x0c0004c2, 0x1400ffff },
+  { 0x0c0004c3, 0x24000001 },
+  { 0x0c0004c4, 0x1400ffff },
+  { 0x0c0004c5, 0x24000001 },
+  { 0x0c0004c6, 0x1400ffff },
+  { 0x0c0004c7, 0x24000001 },
+  { 0x0c0004c8, 0x1400ffff },
+  { 0x0c0004c9, 0x24000001 },
+  { 0x0c0004ca, 0x1400ffff },
+  { 0x0c0004cb, 0x24000001 },
+  { 0x0c0004cc, 0x1400ffff },
+  { 0x0c0004cd, 0x24000001 },
+  { 0x0c0004ce, 0x1400ffff },
+  { 0x0c0004d0, 0x24000001 },
+  { 0x0c0004d1, 0x1400ffff },
+  { 0x0c0004d2, 0x24000001 },
+  { 0x0c0004d3, 0x1400ffff },
+  { 0x0c0004d4, 0x24000001 },
+  { 0x0c0004d5, 0x1400ffff },
+  { 0x0c0004d6, 0x24000001 },
+  { 0x0c0004d7, 0x1400ffff },
+  { 0x0c0004d8, 0x24000001 },
+  { 0x0c0004d9, 0x1400ffff },
+  { 0x0c0004da, 0x24000001 },
+  { 0x0c0004db, 0x1400ffff },
+  { 0x0c0004dc, 0x24000001 },
+  { 0x0c0004dd, 0x1400ffff },
+  { 0x0c0004de, 0x24000001 },
+  { 0x0c0004df, 0x1400ffff },
+  { 0x0c0004e0, 0x24000001 },
+  { 0x0c0004e1, 0x1400ffff },
+  { 0x0c0004e2, 0x24000001 },
+  { 0x0c0004e3, 0x1400ffff },
+  { 0x0c0004e4, 0x24000001 },
+  { 0x0c0004e5, 0x1400ffff },
+  { 0x0c0004e6, 0x24000001 },
+  { 0x0c0004e7, 0x1400ffff },
+  { 0x0c0004e8, 0x24000001 },
+  { 0x0c0004e9, 0x1400ffff },
+  { 0x0c0004ea, 0x24000001 },
+  { 0x0c0004eb, 0x1400ffff },
+  { 0x0c0004ec, 0x24000001 },
+  { 0x0c0004ed, 0x1400ffff },
+  { 0x0c0004ee, 0x24000001 },
+  { 0x0c0004ef, 0x1400ffff },
+  { 0x0c0004f0, 0x24000001 },
+  { 0x0c0004f1, 0x1400ffff },
+  { 0x0c0004f2, 0x24000001 },
+  { 0x0c0004f3, 0x1400ffff },
+  { 0x0c0004f4, 0x24000001 },
+  { 0x0c0004f5, 0x1400ffff },
+  { 0x0c0004f6, 0x24000001 },
+  { 0x0c0004f7, 0x1400ffff },
+  { 0x0c0004f8, 0x24000001 },
+  { 0x0c0004f9, 0x1400ffff },
+  { 0x0c000500, 0x24000001 },
+  { 0x0c000501, 0x1400ffff },
+  { 0x0c000502, 0x24000001 },
+  { 0x0c000503, 0x1400ffff },
+  { 0x0c000504, 0x24000001 },
+  { 0x0c000505, 0x1400ffff },
+  { 0x0c000506, 0x24000001 },
+  { 0x0c000507, 0x1400ffff },
+  { 0x0c000508, 0x24000001 },
+  { 0x0c000509, 0x1400ffff },
+  { 0x0c00050a, 0x24000001 },
+  { 0x0c00050b, 0x1400ffff },
+  { 0x0c00050c, 0x24000001 },
+  { 0x0c00050d, 0x1400ffff },
+  { 0x0c00050e, 0x24000001 },
+  { 0x0c00050f, 0x1400ffff },
+  { 0x01000531, 0x24000030 },
+  { 0x01000532, 0x24000030 },
+  { 0x01000533, 0x24000030 },
+  { 0x01000534, 0x24000030 },
+  { 0x01000535, 0x24000030 },
+  { 0x01000536, 0x24000030 },
+  { 0x01000537, 0x24000030 },
+  { 0x01000538, 0x24000030 },
+  { 0x01000539, 0x24000030 },
+  { 0x0100053a, 0x24000030 },
+  { 0x0100053b, 0x24000030 },
+  { 0x0100053c, 0x24000030 },
+  { 0x0100053d, 0x24000030 },
+  { 0x0100053e, 0x24000030 },
+  { 0x0100053f, 0x24000030 },
+  { 0x01000540, 0x24000030 },
+  { 0x01000541, 0x24000030 },
+  { 0x01000542, 0x24000030 },
+  { 0x01000543, 0x24000030 },
+  { 0x01000544, 0x24000030 },
+  { 0x01000545, 0x24000030 },
+  { 0x01000546, 0x24000030 },
+  { 0x01000547, 0x24000030 },
+  { 0x01000548, 0x24000030 },
+  { 0x01000549, 0x24000030 },
+  { 0x0100054a, 0x24000030 },
+  { 0x0100054b, 0x24000030 },
+  { 0x0100054c, 0x24000030 },
+  { 0x0100054d, 0x24000030 },
+  { 0x0100054e, 0x24000030 },
+  { 0x0100054f, 0x24000030 },
+  { 0x01000550, 0x24000030 },
+  { 0x01000551, 0x24000030 },
+  { 0x01000552, 0x24000030 },
+  { 0x01000553, 0x24000030 },
+  { 0x01000554, 0x24000030 },
+  { 0x01000555, 0x24000030 },
+  { 0x01000556, 0x24000030 },
+  { 0x01000559, 0x18000000 },
+  { 0x0180055a, 0x54000005 },
+  { 0x01000561, 0x1400ffd0 },
+  { 0x01000562, 0x1400ffd0 },
+  { 0x01000563, 0x1400ffd0 },
+  { 0x01000564, 0x1400ffd0 },
+  { 0x01000565, 0x1400ffd0 },
+  { 0x01000566, 0x1400ffd0 },
+  { 0x01000567, 0x1400ffd0 },
+  { 0x01000568, 0x1400ffd0 },
+  { 0x01000569, 0x1400ffd0 },
+  { 0x0100056a, 0x1400ffd0 },
+  { 0x0100056b, 0x1400ffd0 },
+  { 0x0100056c, 0x1400ffd0 },
+  { 0x0100056d, 0x1400ffd0 },
+  { 0x0100056e, 0x1400ffd0 },
+  { 0x0100056f, 0x1400ffd0 },
+  { 0x01000570, 0x1400ffd0 },
+  { 0x01000571, 0x1400ffd0 },
+  { 0x01000572, 0x1400ffd0 },
+  { 0x01000573, 0x1400ffd0 },
+  { 0x01000574, 0x1400ffd0 },
+  { 0x01000575, 0x1400ffd0 },
+  { 0x01000576, 0x1400ffd0 },
+  { 0x01000577, 0x1400ffd0 },
+  { 0x01000578, 0x1400ffd0 },
+  { 0x01000579, 0x1400ffd0 },
+  { 0x0100057a, 0x1400ffd0 },
+  { 0x0100057b, 0x1400ffd0 },
+  { 0x0100057c, 0x1400ffd0 },
+  { 0x0100057d, 0x1400ffd0 },
+  { 0x0100057e, 0x1400ffd0 },
+  { 0x0100057f, 0x1400ffd0 },
+  { 0x01000580, 0x1400ffd0 },
+  { 0x01000581, 0x1400ffd0 },
+  { 0x01000582, 0x1400ffd0 },
+  { 0x01000583, 0x1400ffd0 },
+  { 0x01000584, 0x1400ffd0 },
+  { 0x01000585, 0x1400ffd0 },
+  { 0x01000586, 0x1400ffd0 },
+  { 0x01000587, 0x14000000 },
+  { 0x09000589, 0x54000000 },
+  { 0x0100058a, 0x44000000 },
+  { 0x19800591, 0x30000028 },
+  { 0x198005bb, 0x30000002 },
+  { 0x190005be, 0x54000000 },
+  { 0x190005bf, 0x30000000 },
+  { 0x190005c0, 0x54000000 },
+  { 0x198005c1, 0x30000001 },
+  { 0x190005c3, 0x54000000 },
+  { 0x198005c4, 0x30000001 },
+  { 0x190005c6, 0x54000000 },
+  { 0x190005c7, 0x30000000 },
+  { 0x198005d0, 0x1c00001a },
+  { 0x198005f0, 0x1c000002 },
+  { 0x198005f3, 0x54000001 },
+  { 0x09800600, 0x04000003 },
+  { 0x0000060b, 0x5c000000 },
+  { 0x0980060c, 0x54000001 },
+  { 0x0080060e, 0x68000001 },
+  { 0x00800610, 0x30000005 },
+  { 0x0900061b, 0x54000000 },
+  { 0x0080061e, 0x54000001 },
+  { 0x00800621, 0x1c000019 },
+  { 0x09000640, 0x18000000 },
+  { 0x00800641, 0x1c000009 },
+  { 0x1b80064b, 0x30000013 },
+  { 0x09800660, 0x34000009 },
+  { 0x0080066a, 0x54000003 },
+  { 0x0080066e, 0x1c000001 },
+  { 0x1b000670, 0x30000000 },
+  { 0x00800671, 0x1c000062 },
+  { 0x000006d4, 0x54000000 },
+  { 0x000006d5, 0x1c000000 },
+  { 0x008006d6, 0x30000006 },
+  { 0x090006dd, 0x04000000 },
+  { 0x000006de, 0x2c000000 },
+  { 0x008006df, 0x30000005 },
+  { 0x008006e5, 0x18000001 },
+  { 0x008006e7, 0x30000001 },
+  { 0x000006e9, 0x68000000 },
+  { 0x008006ea, 0x30000003 },
+  { 0x008006ee, 0x1c000001 },
+  { 0x008006f0, 0x34000009 },
+  { 0x008006fa, 0x1c000002 },
+  { 0x008006fd, 0x68000001 },
+  { 0x000006ff, 0x1c000000 },
+  { 0x31800700, 0x5400000d },
+  { 0x3100070f, 0x04000000 },
+  { 0x31000710, 0x1c000000 },
+  { 0x31000711, 0x30000000 },
+  { 0x31800712, 0x1c00001d },
+  { 0x31800730, 0x3000001a },
+  { 0x3180074d, 0x1c000020 },
+  { 0x37800780, 0x1c000025 },
+  { 0x378007a6, 0x3000000a },
+  { 0x370007b1, 0x1c000000 },
+  { 0x0e800901, 0x30000001 },
+  { 0x0e000903, 0x28000000 },
+  { 0x0e800904, 0x1c000035 },
+  { 0x0e00093c, 0x30000000 },
+  { 0x0e00093d, 0x1c000000 },
+  { 0x0e80093e, 0x28000002 },
+  { 0x0e800941, 0x30000007 },
+  { 0x0e800949, 0x28000003 },
+  { 0x0e00094d, 0x30000000 },
+  { 0x0e000950, 0x1c000000 },
+  { 0x0e800951, 0x30000003 },
+  { 0x0e800958, 0x1c000009 },
+  { 0x0e800962, 0x30000001 },
+  { 0x09800964, 0x54000001 },
+  { 0x0e800966, 0x34000009 },
+  { 0x09000970, 0x54000000 },
+  { 0x0e00097d, 0x1c000000 },
+  { 0x02000981, 0x30000000 },
+  { 0x02800982, 0x28000001 },
+  { 0x02800985, 0x1c000007 },
+  { 0x0280098f, 0x1c000001 },
+  { 0x02800993, 0x1c000015 },
+  { 0x028009aa, 0x1c000006 },
+  { 0x020009b2, 0x1c000000 },
+  { 0x028009b6, 0x1c000003 },
+  { 0x020009bc, 0x30000000 },
+  { 0x020009bd, 0x1c000000 },
+  { 0x028009be, 0x28000002 },
+  { 0x028009c1, 0x30000003 },
+  { 0x028009c7, 0x28000001 },
+  { 0x028009cb, 0x28000001 },
+  { 0x020009cd, 0x30000000 },
+  { 0x020009ce, 0x1c000000 },
+  { 0x020009d7, 0x28000000 },
+  { 0x028009dc, 0x1c000001 },
+  { 0x028009df, 0x1c000002 },
+  { 0x028009e2, 0x30000001 },
+  { 0x028009e6, 0x34000009 },
+  { 0x028009f0, 0x1c000001 },
+  { 0x028009f2, 0x5c000001 },
+  { 0x028009f4, 0x3c000005 },
+  { 0x020009fa, 0x68000000 },
+  { 0x15800a01, 0x30000001 },
+  { 0x15000a03, 0x28000000 },
+  { 0x15800a05, 0x1c000005 },
+  { 0x15800a0f, 0x1c000001 },
+  { 0x15800a13, 0x1c000015 },
+  { 0x15800a2a, 0x1c000006 },
+  { 0x15800a32, 0x1c000001 },
+  { 0x15800a35, 0x1c000001 },
+  { 0x15800a38, 0x1c000001 },
+  { 0x15000a3c, 0x30000000 },
+  { 0x15800a3e, 0x28000002 },
+  { 0x15800a41, 0x30000001 },
+  { 0x15800a47, 0x30000001 },
+  { 0x15800a4b, 0x30000002 },
+  { 0x15800a59, 0x1c000003 },
+  { 0x15000a5e, 0x1c000000 },
+  { 0x15800a66, 0x34000009 },
+  { 0x15800a70, 0x30000001 },
+  { 0x15800a72, 0x1c000002 },
+  { 0x14800a81, 0x30000001 },
+  { 0x14000a83, 0x28000000 },
+  { 0x14800a85, 0x1c000008 },
+  { 0x14800a8f, 0x1c000002 },
+  { 0x14800a93, 0x1c000015 },
+  { 0x14800aaa, 0x1c000006 },
+  { 0x14800ab2, 0x1c000001 },
+  { 0x14800ab5, 0x1c000004 },
+  { 0x14000abc, 0x30000000 },
+  { 0x14000abd, 0x1c000000 },
+  { 0x14800abe, 0x28000002 },
+  { 0x14800ac1, 0x30000004 },
+  { 0x14800ac7, 0x30000001 },
+  { 0x14000ac9, 0x28000000 },
+  { 0x14800acb, 0x28000001 },
+  { 0x14000acd, 0x30000000 },
+  { 0x14000ad0, 0x1c000000 },
+  { 0x14800ae0, 0x1c000001 },
+  { 0x14800ae2, 0x30000001 },
+  { 0x14800ae6, 0x34000009 },
+  { 0x14000af1, 0x5c000000 },
+  { 0x2b000b01, 0x30000000 },
+  { 0x2b800b02, 0x28000001 },
+  { 0x2b800b05, 0x1c000007 },
+  { 0x2b800b0f, 0x1c000001 },
+  { 0x2b800b13, 0x1c000015 },
+  { 0x2b800b2a, 0x1c000006 },
+  { 0x2b800b32, 0x1c000001 },
+  { 0x2b800b35, 0x1c000004 },
+  { 0x2b000b3c, 0x30000000 },
+  { 0x2b000b3d, 0x1c000000 },
+  { 0x2b000b3e, 0x28000000 },
+  { 0x2b000b3f, 0x30000000 },
+  { 0x2b000b40, 0x28000000 },
+  { 0x2b800b41, 0x30000002 },
+  { 0x2b800b47, 0x28000001 },
+  { 0x2b800b4b, 0x28000001 },
+  { 0x2b000b4d, 0x30000000 },
+  { 0x2b000b56, 0x30000000 },
+  { 0x2b000b57, 0x28000000 },
+  { 0x2b800b5c, 0x1c000001 },
+  { 0x2b800b5f, 0x1c000002 },
+  { 0x2b800b66, 0x34000009 },
+  { 0x2b000b70, 0x68000000 },
+  { 0x2b000b71, 0x1c000000 },
+  { 0x35000b82, 0x30000000 },
+  { 0x35000b83, 0x1c000000 },
+  { 0x35800b85, 0x1c000005 },
+  { 0x35800b8e, 0x1c000002 },
+  { 0x35800b92, 0x1c000003 },
+  { 0x35800b99, 0x1c000001 },
+  { 0x35000b9c, 0x1c000000 },
+  { 0x35800b9e, 0x1c000001 },
+  { 0x35800ba3, 0x1c000001 },
+  { 0x35800ba8, 0x1c000002 },
+  { 0x35800bae, 0x1c00000b },
+  { 0x35800bbe, 0x28000001 },
+  { 0x35000bc0, 0x30000000 },
+  { 0x35800bc1, 0x28000001 },
+  { 0x35800bc6, 0x28000002 },
+  { 0x35800bca, 0x28000002 },
+  { 0x35000bcd, 0x30000000 },
+  { 0x35000bd7, 0x28000000 },
+  { 0x35800be6, 0x34000009 },
+  { 0x35800bf0, 0x3c000002 },
+  { 0x35800bf3, 0x68000005 },
+  { 0x35000bf9, 0x5c000000 },
+  { 0x35000bfa, 0x68000000 },
+  { 0x36800c01, 0x28000002 },
+  { 0x36800c05, 0x1c000007 },
+  { 0x36800c0e, 0x1c000002 },
+  { 0x36800c12, 0x1c000016 },
+  { 0x36800c2a, 0x1c000009 },
+  { 0x36800c35, 0x1c000004 },
+  { 0x36800c3e, 0x30000002 },
+  { 0x36800c41, 0x28000003 },
+  { 0x36800c46, 0x30000002 },
+  { 0x36800c4a, 0x30000003 },
+  { 0x36800c55, 0x30000001 },
+  { 0x36800c60, 0x1c000001 },
+  { 0x36800c66, 0x34000009 },
+  { 0x1c800c82, 0x28000001 },
+  { 0x1c800c85, 0x1c000007 },
+  { 0x1c800c8e, 0x1c000002 },
+  { 0x1c800c92, 0x1c000016 },
+  { 0x1c800caa, 0x1c000009 },
+  { 0x1c800cb5, 0x1c000004 },
+  { 0x1c000cbc, 0x30000000 },
+  { 0x1c000cbd, 0x1c000000 },
+  { 0x1c000cbe, 0x28000000 },
+  { 0x1c000cbf, 0x30000000 },
+  { 0x1c800cc0, 0x28000004 },
+  { 0x1c000cc6, 0x30000000 },
+  { 0x1c800cc7, 0x28000001 },
+  { 0x1c800cca, 0x28000001 },
+  { 0x1c800ccc, 0x30000001 },
+  { 0x1c800cd5, 0x28000001 },
+  { 0x1c000cde, 0x1c000000 },
+  { 0x1c800ce0, 0x1c000001 },
+  { 0x1c800ce6, 0x34000009 },
+  { 0x24800d02, 0x28000001 },
+  { 0x24800d05, 0x1c000007 },
+  { 0x24800d0e, 0x1c000002 },
+  { 0x24800d12, 0x1c000016 },
+  { 0x24800d2a, 0x1c00000f },
+  { 0x24800d3e, 0x28000002 },
+  { 0x24800d41, 0x30000002 },
+  { 0x24800d46, 0x28000002 },
+  { 0x24800d4a, 0x28000002 },
+  { 0x24000d4d, 0x30000000 },
+  { 0x24000d57, 0x28000000 },
+  { 0x24800d60, 0x1c000001 },
+  { 0x24800d66, 0x34000009 },
+  { 0x2f800d82, 0x28000001 },
+  { 0x2f800d85, 0x1c000011 },
+  { 0x2f800d9a, 0x1c000017 },
+  { 0x2f800db3, 0x1c000008 },
+  { 0x2f000dbd, 0x1c000000 },
+  { 0x2f800dc0, 0x1c000006 },
+  { 0x2f000dca, 0x30000000 },
+  { 0x2f800dcf, 0x28000002 },
+  { 0x2f800dd2, 0x30000002 },
+  { 0x2f000dd6, 0x30000000 },
+  { 0x2f800dd8, 0x28000007 },
+  { 0x2f800df2, 0x28000001 },
+  { 0x2f000df4, 0x54000000 },
+  { 0x38800e01, 0x1c00002f },
+  { 0x38000e31, 0x30000000 },
+  { 0x38800e32, 0x1c000001 },
+  { 0x38800e34, 0x30000006 },
+  { 0x09000e3f, 0x5c000000 },
+  { 0x38800e40, 0x1c000005 },
+  { 0x38000e46, 0x18000000 },
+  { 0x38800e47, 0x30000007 },
+  { 0x38000e4f, 0x54000000 },
+  { 0x38800e50, 0x34000009 },
+  { 0x38800e5a, 0x54000001 },
+  { 0x20800e81, 0x1c000001 },
+  { 0x20000e84, 0x1c000000 },
+  { 0x20800e87, 0x1c000001 },
+  { 0x20000e8a, 0x1c000000 },
+  { 0x20000e8d, 0x1c000000 },
+  { 0x20800e94, 0x1c000003 },
+  { 0x20800e99, 0x1c000006 },
+  { 0x20800ea1, 0x1c000002 },
+  { 0x20000ea5, 0x1c000000 },
+  { 0x20000ea7, 0x1c000000 },
+  { 0x20800eaa, 0x1c000001 },
+  { 0x20800ead, 0x1c000003 },
+  { 0x20000eb1, 0x30000000 },
+  { 0x20800eb2, 0x1c000001 },
+  { 0x20800eb4, 0x30000005 },
+  { 0x20800ebb, 0x30000001 },
+  { 0x20000ebd, 0x1c000000 },
+  { 0x20800ec0, 0x1c000004 },
+  { 0x20000ec6, 0x18000000 },
+  { 0x20800ec8, 0x30000005 },
+  { 0x20800ed0, 0x34000009 },
+  { 0x20800edc, 0x1c000001 },
+  { 0x39000f00, 0x1c000000 },
+  { 0x39800f01, 0x68000002 },
+  { 0x39800f04, 0x5400000e },
+  { 0x39800f13, 0x68000004 },
+  { 0x39800f18, 0x30000001 },
+  { 0x39800f1a, 0x68000005 },
+  { 0x39800f20, 0x34000009 },
+  { 0x39800f2a, 0x3c000009 },
+  { 0x39000f34, 0x68000000 },
+  { 0x39000f35, 0x30000000 },
+  { 0x39000f36, 0x68000000 },
+  { 0x39000f37, 0x30000000 },
+  { 0x39000f38, 0x68000000 },
+  { 0x39000f39, 0x30000000 },
+  { 0x39000f3a, 0x58000000 },
+  { 0x39000f3b, 0x48000000 },
+  { 0x39000f3c, 0x58000000 },
+  { 0x39000f3d, 0x48000000 },
+  { 0x39800f3e, 0x28000001 },
+  { 0x39800f40, 0x1c000007 },
+  { 0x39800f49, 0x1c000021 },
+  { 0x39800f71, 0x3000000d },
+  { 0x39000f7f, 0x28000000 },
+  { 0x39800f80, 0x30000004 },
+  { 0x39000f85, 0x54000000 },
+  { 0x39800f86, 0x30000001 },
+  { 0x39800f88, 0x1c000003 },
+  { 0x39800f90, 0x30000007 },
+  { 0x39800f99, 0x30000023 },
+  { 0x39800fbe, 0x68000007 },
+  { 0x39000fc6, 0x30000000 },
+  { 0x39800fc7, 0x68000005 },
+  { 0x39000fcf, 0x68000000 },
+  { 0x39800fd0, 0x54000001 },
+  { 0x26801000, 0x1c000021 },
+  { 0x26801023, 0x1c000004 },
+  { 0x26801029, 0x1c000001 },
+  { 0x2600102c, 0x28000000 },
+  { 0x2680102d, 0x30000003 },
+  { 0x26001031, 0x28000000 },
+  { 0x26001032, 0x30000000 },
+  { 0x26801036, 0x30000001 },
+  { 0x26001038, 0x28000000 },
+  { 0x26001039, 0x30000000 },
+  { 0x26801040, 0x34000009 },
+  { 0x2680104a, 0x54000005 },
+  { 0x26801050, 0x1c000005 },
+  { 0x26801056, 0x28000001 },
+  { 0x26801058, 0x30000001 },
+  { 0x100010a0, 0x24001c60 },
+  { 0x100010a1, 0x24001c60 },
+  { 0x100010a2, 0x24001c60 },
+  { 0x100010a3, 0x24001c60 },
+  { 0x100010a4, 0x24001c60 },
+  { 0x100010a5, 0x24001c60 },
+  { 0x100010a6, 0x24001c60 },
+  { 0x100010a7, 0x24001c60 },
+  { 0x100010a8, 0x24001c60 },
+  { 0x100010a9, 0x24001c60 },
+  { 0x100010aa, 0x24001c60 },
+  { 0x100010ab, 0x24001c60 },
+  { 0x100010ac, 0x24001c60 },
+  { 0x100010ad, 0x24001c60 },
+  { 0x100010ae, 0x24001c60 },
+  { 0x100010af, 0x24001c60 },
+  { 0x100010b0, 0x24001c60 },
+  { 0x100010b1, 0x24001c60 },
+  { 0x100010b2, 0x24001c60 },
+  { 0x100010b3, 0x24001c60 },
+  { 0x100010b4, 0x24001c60 },
+  { 0x100010b5, 0x24001c60 },
+  { 0x100010b6, 0x24001c60 },
+  { 0x100010b7, 0x24001c60 },
+  { 0x100010b8, 0x24001c60 },
+  { 0x100010b9, 0x24001c60 },
+  { 0x100010ba, 0x24001c60 },
+  { 0x100010bb, 0x24001c60 },
+  { 0x100010bc, 0x24001c60 },
+  { 0x100010bd, 0x24001c60 },
+  { 0x100010be, 0x24001c60 },
+  { 0x100010bf, 0x24001c60 },
+  { 0x100010c0, 0x24001c60 },
+  { 0x100010c1, 0x24001c60 },
+  { 0x100010c2, 0x24001c60 },
+  { 0x100010c3, 0x24001c60 },
+  { 0x100010c4, 0x24001c60 },
+  { 0x100010c5, 0x24001c60 },
+  { 0x108010d0, 0x1c00002a },
+  { 0x090010fb, 0x54000000 },
+  { 0x100010fc, 0x18000000 },
+  { 0x17801100, 0x1c000059 },
+  { 0x1780115f, 0x1c000043 },
+  { 0x178011a8, 0x1c000051 },
+  { 0x0f801200, 0x1c000048 },
+  { 0x0f80124a, 0x1c000003 },
+  { 0x0f801250, 0x1c000006 },
+  { 0x0f001258, 0x1c000000 },
+  { 0x0f80125a, 0x1c000003 },
+  { 0x0f801260, 0x1c000028 },
+  { 0x0f80128a, 0x1c000003 },
+  { 0x0f801290, 0x1c000020 },
+  { 0x0f8012b2, 0x1c000003 },
+  { 0x0f8012b8, 0x1c000006 },
+  { 0x0f0012c0, 0x1c000000 },
+  { 0x0f8012c2, 0x1c000003 },
+  { 0x0f8012c8, 0x1c00000e },
+  { 0x0f8012d8, 0x1c000038 },
+  { 0x0f801312, 0x1c000003 },
+  { 0x0f801318, 0x1c000042 },
+  { 0x0f00135f, 0x30000000 },
+  { 0x0f001360, 0x68000000 },
+  { 0x0f801361, 0x54000007 },
+  { 0x0f801369, 0x3c000013 },
+  { 0x0f801380, 0x1c00000f },
+  { 0x0f801390, 0x68000009 },
+  { 0x088013a0, 0x1c000054 },
+  { 0x07801401, 0x1c00026b },
+  { 0x0780166d, 0x54000001 },
+  { 0x0780166f, 0x1c000007 },
+  { 0x28001680, 0x74000000 },
+  { 0x28801681, 0x1c000019 },
+  { 0x2800169b, 0x58000000 },
+  { 0x2800169c, 0x48000000 },
+  { 0x2d8016a0, 0x1c00004a },
+  { 0x098016eb, 0x54000002 },
+  { 0x2d8016ee, 0x38000002 },
+  { 0x32801700, 0x1c00000c },
+  { 0x3280170e, 0x1c000003 },
+  { 0x32801712, 0x30000002 },
+  { 0x18801720, 0x1c000011 },
+  { 0x18801732, 0x30000002 },
+  { 0x09801735, 0x54000001 },
+  { 0x06801740, 0x1c000011 },
+  { 0x06801752, 0x30000001 },
+  { 0x33801760, 0x1c00000c },
+  { 0x3380176e, 0x1c000002 },
+  { 0x33801772, 0x30000001 },
+  { 0x1f801780, 0x1c000033 },
+  { 0x1f8017b4, 0x04000001 },
+  { 0x1f0017b6, 0x28000000 },
+  { 0x1f8017b7, 0x30000006 },
+  { 0x1f8017be, 0x28000007 },
+  { 0x1f0017c6, 0x30000000 },
+  { 0x1f8017c7, 0x28000001 },
+  { 0x1f8017c9, 0x3000000a },
+  { 0x1f8017d4, 0x54000002 },
+  { 0x1f0017d7, 0x18000000 },
+  { 0x1f8017d8, 0x54000002 },
+  { 0x1f0017db, 0x5c000000 },
+  { 0x1f0017dc, 0x1c000000 },
+  { 0x1f0017dd, 0x30000000 },
+  { 0x1f8017e0, 0x34000009 },
+  { 0x1f8017f0, 0x3c000009 },
+  { 0x25801800, 0x54000005 },
+  { 0x25001806, 0x44000000 },
+  { 0x25801807, 0x54000003 },
+  { 0x2580180b, 0x30000002 },
+  { 0x2500180e, 0x74000000 },
+  { 0x25801810, 0x34000009 },
+  { 0x25801820, 0x1c000022 },
+  { 0x25001843, 0x18000000 },
+  { 0x25801844, 0x1c000033 },
+  { 0x25801880, 0x1c000028 },
+  { 0x250018a9, 0x30000000 },
+  { 0x22801900, 0x1c00001c },
+  { 0x22801920, 0x30000002 },
+  { 0x22801923, 0x28000003 },
+  { 0x22801927, 0x30000001 },
+  { 0x22801929, 0x28000002 },
+  { 0x22801930, 0x28000001 },
+  { 0x22001932, 0x30000000 },
+  { 0x22801933, 0x28000005 },
+  { 0x22801939, 0x30000002 },
+  { 0x22001940, 0x68000000 },
+  { 0x22801944, 0x54000001 },
+  { 0x22801946, 0x34000009 },
+  { 0x34801950, 0x1c00001d },
+  { 0x34801970, 0x1c000004 },
+  { 0x27801980, 0x1c000029 },
+  { 0x278019b0, 0x28000010 },
+  { 0x278019c1, 0x1c000006 },
+  { 0x278019c8, 0x28000001 },
+  { 0x278019d0, 0x34000009 },
+  { 0x278019de, 0x54000001 },
+  { 0x1f8019e0, 0x6800001f },
+  { 0x05801a00, 0x1c000016 },
+  { 0x05801a17, 0x30000001 },
+  { 0x05801a19, 0x28000002 },
+  { 0x05801a1e, 0x54000001 },
+  { 0x21801d00, 0x1400002b },
+  { 0x21801d2c, 0x18000035 },
+  { 0x21801d62, 0x14000015 },
+  { 0x0c001d78, 0x18000000 },
+  { 0x21801d79, 0x14000021 },
+  { 0x21801d9b, 0x18000024 },
+  { 0x1b801dc0, 0x30000003 },
+  { 0x21001e00, 0x24000001 },
+  { 0x21001e01, 0x1400ffff },
+  { 0x21001e02, 0x24000001 },
+  { 0x21001e03, 0x1400ffff },
+  { 0x21001e04, 0x24000001 },
+  { 0x21001e05, 0x1400ffff },
+  { 0x21001e06, 0x24000001 },
+  { 0x21001e07, 0x1400ffff },
+  { 0x21001e08, 0x24000001 },
+  { 0x21001e09, 0x1400ffff },
+  { 0x21001e0a, 0x24000001 },
+  { 0x21001e0b, 0x1400ffff },
+  { 0x21001e0c, 0x24000001 },
+  { 0x21001e0d, 0x1400ffff },
+  { 0x21001e0e, 0x24000001 },
+  { 0x21001e0f, 0x1400ffff },
+  { 0x21001e10, 0x24000001 },
+  { 0x21001e11, 0x1400ffff },
+  { 0x21001e12, 0x24000001 },
+  { 0x21001e13, 0x1400ffff },
+  { 0x21001e14, 0x24000001 },
+  { 0x21001e15, 0x1400ffff },
+  { 0x21001e16, 0x24000001 },
+  { 0x21001e17, 0x1400ffff },
+  { 0x21001e18, 0x24000001 },
+  { 0x21001e19, 0x1400ffff },
+  { 0x21001e1a, 0x24000001 },
+  { 0x21001e1b, 0x1400ffff },
+  { 0x21001e1c, 0x24000001 },
+  { 0x21001e1d, 0x1400ffff },
+  { 0x21001e1e, 0x24000001 },
+  { 0x21001e1f, 0x1400ffff },
+  { 0x21001e20, 0x24000001 },
+  { 0x21001e21, 0x1400ffff },
+  { 0x21001e22, 0x24000001 },
+  { 0x21001e23, 0x1400ffff },
+  { 0x21001e24, 0x24000001 },
+  { 0x21001e25, 0x1400ffff },
+  { 0x21001e26, 0x24000001 },
+  { 0x21001e27, 0x1400ffff },
+  { 0x21001e28, 0x24000001 },
+  { 0x21001e29, 0x1400ffff },
+  { 0x21001e2a, 0x24000001 },
+  { 0x21001e2b, 0x1400ffff },
+  { 0x21001e2c, 0x24000001 },
+  { 0x21001e2d, 0x1400ffff },
+  { 0x21001e2e, 0x24000001 },
+  { 0x21001e2f, 0x1400ffff },
+  { 0x21001e30, 0x24000001 },
+  { 0x21001e31, 0x1400ffff },
+  { 0x21001e32, 0x24000001 },
+  { 0x21001e33, 0x1400ffff },
+  { 0x21001e34, 0x24000001 },
+  { 0x21001e35, 0x1400ffff },
+  { 0x21001e36, 0x24000001 },
+  { 0x21001e37, 0x1400ffff },
+  { 0x21001e38, 0x24000001 },
+  { 0x21001e39, 0x1400ffff },
+  { 0x21001e3a, 0x24000001 },
+  { 0x21001e3b, 0x1400ffff },
+  { 0x21001e3c, 0x24000001 },
+  { 0x21001e3d, 0x1400ffff },
+  { 0x21001e3e, 0x24000001 },
+  { 0x21001e3f, 0x1400ffff },
+  { 0x21001e40, 0x24000001 },
+  { 0x21001e41, 0x1400ffff },
+  { 0x21001e42, 0x24000001 },
+  { 0x21001e43, 0x1400ffff },
+  { 0x21001e44, 0x24000001 },
+  { 0x21001e45, 0x1400ffff },
+  { 0x21001e46, 0x24000001 },
+  { 0x21001e47, 0x1400ffff },
+  { 0x21001e48, 0x24000001 },
+  { 0x21001e49, 0x1400ffff },
+  { 0x21001e4a, 0x24000001 },
+  { 0x21001e4b, 0x1400ffff },
+  { 0x21001e4c, 0x24000001 },
+  { 0x21001e4d, 0x1400ffff },
+  { 0x21001e4e, 0x24000001 },
+  { 0x21001e4f, 0x1400ffff },
+  { 0x21001e50, 0x24000001 },
+  { 0x21001e51, 0x1400ffff },
+  { 0x21001e52, 0x24000001 },
+  { 0x21001e53, 0x1400ffff },
+  { 0x21001e54, 0x24000001 },
+  { 0x21001e55, 0x1400ffff },
+  { 0x21001e56, 0x24000001 },
+  { 0x21001e57, 0x1400ffff },
+  { 0x21001e58, 0x24000001 },
+  { 0x21001e59, 0x1400ffff },
+  { 0x21001e5a, 0x24000001 },
+  { 0x21001e5b, 0x1400ffff },
+  { 0x21001e5c, 0x24000001 },
+  { 0x21001e5d, 0x1400ffff },
+  { 0x21001e5e, 0x24000001 },
+  { 0x21001e5f, 0x1400ffff },
+  { 0x21001e60, 0x24000001 },
+  { 0x21001e61, 0x1400ffff },
+  { 0x21001e62, 0x24000001 },
+  { 0x21001e63, 0x1400ffff },
+  { 0x21001e64, 0x24000001 },
+  { 0x21001e65, 0x1400ffff },
+  { 0x21001e66, 0x24000001 },
+  { 0x21001e67, 0x1400ffff },
+  { 0x21001e68, 0x24000001 },
+  { 0x21001e69, 0x1400ffff },
+  { 0x21001e6a, 0x24000001 },
+  { 0x21001e6b, 0x1400ffff },
+  { 0x21001e6c, 0x24000001 },
+  { 0x21001e6d, 0x1400ffff },
+  { 0x21001e6e, 0x24000001 },
+  { 0x21001e6f, 0x1400ffff },
+  { 0x21001e70, 0x24000001 },
+  { 0x21001e71, 0x1400ffff },
+  { 0x21001e72, 0x24000001 },
+  { 0x21001e73, 0x1400ffff },
+  { 0x21001e74, 0x24000001 },
+  { 0x21001e75, 0x1400ffff },
+  { 0x21001e76, 0x24000001 },
+  { 0x21001e77, 0x1400ffff },
+  { 0x21001e78, 0x24000001 },
+  { 0x21001e79, 0x1400ffff },
+  { 0x21001e7a, 0x24000001 },
+  { 0x21001e7b, 0x1400ffff },
+  { 0x21001e7c, 0x24000001 },
+  { 0x21001e7d, 0x1400ffff },
+  { 0x21001e7e, 0x24000001 },
+  { 0x21001e7f, 0x1400ffff },
+  { 0x21001e80, 0x24000001 },
+  { 0x21001e81, 0x1400ffff },
+  { 0x21001e82, 0x24000001 },
+  { 0x21001e83, 0x1400ffff },
+  { 0x21001e84, 0x24000001 },
+  { 0x21001e85, 0x1400ffff },
+  { 0x21001e86, 0x24000001 },
+  { 0x21001e87, 0x1400ffff },
+  { 0x21001e88, 0x24000001 },
+  { 0x21001e89, 0x1400ffff },
+  { 0x21001e8a, 0x24000001 },
+  { 0x21001e8b, 0x1400ffff },
+  { 0x21001e8c, 0x24000001 },
+  { 0x21001e8d, 0x1400ffff },
+  { 0x21001e8e, 0x24000001 },
+  { 0x21001e8f, 0x1400ffff },
+  { 0x21001e90, 0x24000001 },
+  { 0x21001e91, 0x1400ffff },
+  { 0x21001e92, 0x24000001 },
+  { 0x21001e93, 0x1400ffff },
+  { 0x21001e94, 0x24000001 },
+  { 0x21001e95, 0x1400ffff },
+  { 0x21801e96, 0x14000004 },
+  { 0x21001e9b, 0x1400ffc5 },
+  { 0x21001ea0, 0x24000001 },
+  { 0x21001ea1, 0x1400ffff },
+  { 0x21001ea2, 0x24000001 },
+  { 0x21001ea3, 0x1400ffff },
+  { 0x21001ea4, 0x24000001 },
+  { 0x21001ea5, 0x1400ffff },
+  { 0x21001ea6, 0x24000001 },
+  { 0x21001ea7, 0x1400ffff },
+  { 0x21001ea8, 0x24000001 },
+  { 0x21001ea9, 0x1400ffff },
+  { 0x21001eaa, 0x24000001 },
+  { 0x21001eab, 0x1400ffff },
+  { 0x21001eac, 0x24000001 },
+  { 0x21001ead, 0x1400ffff },
+  { 0x21001eae, 0x24000001 },
+  { 0x21001eaf, 0x1400ffff },
+  { 0x21001eb0, 0x24000001 },
+  { 0x21001eb1, 0x1400ffff },
+  { 0x21001eb2, 0x24000001 },
+  { 0x21001eb3, 0x1400ffff },
+  { 0x21001eb4, 0x24000001 },
+  { 0x21001eb5, 0x1400ffff },
+  { 0x21001eb6, 0x24000001 },
+  { 0x21001eb7, 0x1400ffff },
+  { 0x21001eb8, 0x24000001 },
+  { 0x21001eb9, 0x1400ffff },
+  { 0x21001eba, 0x24000001 },
+  { 0x21001ebb, 0x1400ffff },
+  { 0x21001ebc, 0x24000001 },
+  { 0x21001ebd, 0x1400ffff },
+  { 0x21001ebe, 0x24000001 },
+  { 0x21001ebf, 0x1400ffff },
+  { 0x21001ec0, 0x24000001 },
+  { 0x21001ec1, 0x1400ffff },
+  { 0x21001ec2, 0x24000001 },
+  { 0x21001ec3, 0x1400ffff },
+  { 0x21001ec4, 0x24000001 },
+  { 0x21001ec5, 0x1400ffff },
+  { 0x21001ec6, 0x24000001 },
+  { 0x21001ec7, 0x1400ffff },
+  { 0x21001ec8, 0x24000001 },
+  { 0x21001ec9, 0x1400ffff },
+  { 0x21001eca, 0x24000001 },
+  { 0x21001ecb, 0x1400ffff },
+  { 0x21001ecc, 0x24000001 },
+  { 0x21001ecd, 0x1400ffff },
+  { 0x21001ece, 0x24000001 },
+  { 0x21001ecf, 0x1400ffff },
+  { 0x21001ed0, 0x24000001 },
+  { 0x21001ed1, 0x1400ffff },
+  { 0x21001ed2, 0x24000001 },
+  { 0x21001ed3, 0x1400ffff },
+  { 0x21001ed4, 0x24000001 },
+  { 0x21001ed5, 0x1400ffff },
+  { 0x21001ed6, 0x24000001 },
+  { 0x21001ed7, 0x1400ffff },
+  { 0x21001ed8, 0x24000001 },
+  { 0x21001ed9, 0x1400ffff },
+  { 0x21001eda, 0x24000001 },
+  { 0x21001edb, 0x1400ffff },
+  { 0x21001edc, 0x24000001 },
+  { 0x21001edd, 0x1400ffff },
+  { 0x21001ede, 0x24000001 },
+  { 0x21001edf, 0x1400ffff },
+  { 0x21001ee0, 0x24000001 },
+  { 0x21001ee1, 0x1400ffff },
+  { 0x21001ee2, 0x24000001 },
+  { 0x21001ee3, 0x1400ffff },
+  { 0x21001ee4, 0x24000001 },
+  { 0x21001ee5, 0x1400ffff },
+  { 0x21001ee6, 0x24000001 },
+  { 0x21001ee7, 0x1400ffff },
+  { 0x21001ee8, 0x24000001 },
+  { 0x21001ee9, 0x1400ffff },
+  { 0x21001eea, 0x24000001 },
+  { 0x21001eeb, 0x1400ffff },
+  { 0x21001eec, 0x24000001 },
+  { 0x21001eed, 0x1400ffff },
+  { 0x21001eee, 0x24000001 },
+  { 0x21001eef, 0x1400ffff },
+  { 0x21001ef0, 0x24000001 },
+  { 0x21001ef1, 0x1400ffff },
+  { 0x21001ef2, 0x24000001 },
+  { 0x21001ef3, 0x1400ffff },
+  { 0x21001ef4, 0x24000001 },
+  { 0x21001ef5, 0x1400ffff },
+  { 0x21001ef6, 0x24000001 },
+  { 0x21001ef7, 0x1400ffff },
+  { 0x21001ef8, 0x24000001 },
+  { 0x21001ef9, 0x1400ffff },
+  { 0x13001f00, 0x14000008 },
+  { 0x13001f01, 0x14000008 },
+  { 0x13001f02, 0x14000008 },
+  { 0x13001f03, 0x14000008 },
+  { 0x13001f04, 0x14000008 },
+  { 0x13001f05, 0x14000008 },
+  { 0x13001f06, 0x14000008 },
+  { 0x13001f07, 0x14000008 },
+  { 0x13001f08, 0x2400fff8 },
+  { 0x13001f09, 0x2400fff8 },
+  { 0x13001f0a, 0x2400fff8 },
+  { 0x13001f0b, 0x2400fff8 },
+  { 0x13001f0c, 0x2400fff8 },
+  { 0x13001f0d, 0x2400fff8 },
+  { 0x13001f0e, 0x2400fff8 },
+  { 0x13001f0f, 0x2400fff8 },
+  { 0x13001f10, 0x14000008 },
+  { 0x13001f11, 0x14000008 },
+  { 0x13001f12, 0x14000008 },
+  { 0x13001f13, 0x14000008 },
+  { 0x13001f14, 0x14000008 },
+  { 0x13001f15, 0x14000008 },
+  { 0x13001f18, 0x2400fff8 },
+  { 0x13001f19, 0x2400fff8 },
+  { 0x13001f1a, 0x2400fff8 },
+  { 0x13001f1b, 0x2400fff8 },
+  { 0x13001f1c, 0x2400fff8 },
+  { 0x13001f1d, 0x2400fff8 },
+  { 0x13001f20, 0x14000008 },
+  { 0x13001f21, 0x14000008 },
+  { 0x13001f22, 0x14000008 },
+  { 0x13001f23, 0x14000008 },
+  { 0x13001f24, 0x14000008 },
+  { 0x13001f25, 0x14000008 },
+  { 0x13001f26, 0x14000008 },
+  { 0x13001f27, 0x14000008 },
+  { 0x13001f28, 0x2400fff8 },
+  { 0x13001f29, 0x2400fff8 },
+  { 0x13001f2a, 0x2400fff8 },
+  { 0x13001f2b, 0x2400fff8 },
+  { 0x13001f2c, 0x2400fff8 },
+  { 0x13001f2d, 0x2400fff8 },
+  { 0x13001f2e, 0x2400fff8 },
+  { 0x13001f2f, 0x2400fff8 },
+  { 0x13001f30, 0x14000008 },
+  { 0x13001f31, 0x14000008 },
+  { 0x13001f32, 0x14000008 },
+  { 0x13001f33, 0x14000008 },
+  { 0x13001f34, 0x14000008 },
+  { 0x13001f35, 0x14000008 },
+  { 0x13001f36, 0x14000008 },
+  { 0x13001f37, 0x14000008 },
+  { 0x13001f38, 0x2400fff8 },
+  { 0x13001f39, 0x2400fff8 },
+  { 0x13001f3a, 0x2400fff8 },
+  { 0x13001f3b, 0x2400fff8 },
+  { 0x13001f3c, 0x2400fff8 },
+  { 0x13001f3d, 0x2400fff8 },
+  { 0x13001f3e, 0x2400fff8 },
+  { 0x13001f3f, 0x2400fff8 },
+  { 0x13001f40, 0x14000008 },
+  { 0x13001f41, 0x14000008 },
+  { 0x13001f42, 0x14000008 },
+  { 0x13001f43, 0x14000008 },
+  { 0x13001f44, 0x14000008 },
+  { 0x13001f45, 0x14000008 },
+  { 0x13001f48, 0x2400fff8 },
+  { 0x13001f49, 0x2400fff8 },
+  { 0x13001f4a, 0x2400fff8 },
+  { 0x13001f4b, 0x2400fff8 },
+  { 0x13001f4c, 0x2400fff8 },
+  { 0x13001f4d, 0x2400fff8 },
+  { 0x13001f50, 0x14000000 },
+  { 0x13001f51, 0x14000008 },
+  { 0x13001f52, 0x14000000 },
+  { 0x13001f53, 0x14000008 },
+  { 0x13001f54, 0x14000000 },
+  { 0x13001f55, 0x14000008 },
+  { 0x13001f56, 0x14000000 },
+  { 0x13001f57, 0x14000008 },
+  { 0x13001f59, 0x2400fff8 },
+  { 0x13001f5b, 0x2400fff8 },
+  { 0x13001f5d, 0x2400fff8 },
+  { 0x13001f5f, 0x2400fff8 },
+  { 0x13001f60, 0x14000008 },
+  { 0x13001f61, 0x14000008 },
+  { 0x13001f62, 0x14000008 },
+  { 0x13001f63, 0x14000008 },
+  { 0x13001f64, 0x14000008 },
+  { 0x13001f65, 0x14000008 },
+  { 0x13001f66, 0x14000008 },
+  { 0x13001f67, 0x14000008 },
+  { 0x13001f68, 0x2400fff8 },
+  { 0x13001f69, 0x2400fff8 },
+  { 0x13001f6a, 0x2400fff8 },
+  { 0x13001f6b, 0x2400fff8 },
+  { 0x13001f6c, 0x2400fff8 },
+  { 0x13001f6d, 0x2400fff8 },
+  { 0x13001f6e, 0x2400fff8 },
+  { 0x13001f6f, 0x2400fff8 },
+  { 0x13001f70, 0x1400004a },
+  { 0x13001f71, 0x1400004a },
+  { 0x13001f72, 0x14000056 },
+  { 0x13001f73, 0x14000056 },
+  { 0x13001f74, 0x14000056 },
+  { 0x13001f75, 0x14000056 },
+  { 0x13001f76, 0x14000064 },
+  { 0x13001f77, 0x14000064 },
+  { 0x13001f78, 0x14000080 },
+  { 0x13001f79, 0x14000080 },
+  { 0x13001f7a, 0x14000070 },
+  { 0x13001f7b, 0x14000070 },
+  { 0x13001f7c, 0x1400007e },
+  { 0x13001f7d, 0x1400007e },
+  { 0x13001f80, 0x14000008 },
+  { 0x13001f81, 0x14000008 },
+  { 0x13001f82, 0x14000008 },
+  { 0x13001f83, 0x14000008 },
+  { 0x13001f84, 0x14000008 },
+  { 0x13001f85, 0x14000008 },
+  { 0x13001f86, 0x14000008 },
+  { 0x13001f87, 0x14000008 },
+  { 0x13001f88, 0x2000fff8 },
+  { 0x13001f89, 0x2000fff8 },
+  { 0x13001f8a, 0x2000fff8 },
+  { 0x13001f8b, 0x2000fff8 },
+  { 0x13001f8c, 0x2000fff8 },
+  { 0x13001f8d, 0x2000fff8 },
+  { 0x13001f8e, 0x2000fff8 },
+  { 0x13001f8f, 0x2000fff8 },
+  { 0x13001f90, 0x14000008 },
+  { 0x13001f91, 0x14000008 },
+  { 0x13001f92, 0x14000008 },
+  { 0x13001f93, 0x14000008 },
+  { 0x13001f94, 0x14000008 },
+  { 0x13001f95, 0x14000008 },
+  { 0x13001f96, 0x14000008 },
+  { 0x13001f97, 0x14000008 },
+  { 0x13001f98, 0x2000fff8 },
+  { 0x13001f99, 0x2000fff8 },
+  { 0x13001f9a, 0x2000fff8 },
+  { 0x13001f9b, 0x2000fff8 },
+  { 0x13001f9c, 0x2000fff8 },
+  { 0x13001f9d, 0x2000fff8 },
+  { 0x13001f9e, 0x2000fff8 },
+  { 0x13001f9f, 0x2000fff8 },
+  { 0x13001fa0, 0x14000008 },
+  { 0x13001fa1, 0x14000008 },
+  { 0x13001fa2, 0x14000008 },
+  { 0x13001fa3, 0x14000008 },
+  { 0x13001fa4, 0x14000008 },
+  { 0x13001fa5, 0x14000008 },
+  { 0x13001fa6, 0x14000008 },
+  { 0x13001fa7, 0x14000008 },
+  { 0x13001fa8, 0x2000fff8 },
+  { 0x13001fa9, 0x2000fff8 },
+  { 0x13001faa, 0x2000fff8 },
+  { 0x13001fab, 0x2000fff8 },
+  { 0x13001fac, 0x2000fff8 },
+  { 0x13001fad, 0x2000fff8 },
+  { 0x13001fae, 0x2000fff8 },
+  { 0x13001faf, 0x2000fff8 },
+  { 0x13001fb0, 0x14000008 },
+  { 0x13001fb1, 0x14000008 },
+  { 0x13001fb2, 0x14000000 },
+  { 0x13001fb3, 0x14000009 },
+  { 0x13001fb4, 0x14000000 },
+  { 0x13801fb6, 0x14000001 },
+  { 0x13001fb8, 0x2400fff8 },
+  { 0x13001fb9, 0x2400fff8 },
+  { 0x13001fba, 0x2400ffb6 },
+  { 0x13001fbb, 0x2400ffb6 },
+  { 0x13001fbc, 0x2000fff7 },
+  { 0x13001fbd, 0x60000000 },
+  { 0x13001fbe, 0x1400e3db },
+  { 0x13801fbf, 0x60000002 },
+  { 0x13001fc2, 0x14000000 },
+  { 0x13001fc3, 0x14000009 },
+  { 0x13001fc4, 0x14000000 },
+  { 0x13801fc6, 0x14000001 },
+  { 0x13001fc8, 0x2400ffaa },
+  { 0x13001fc9, 0x2400ffaa },
+  { 0x13001fca, 0x2400ffaa },
+  { 0x13001fcb, 0x2400ffaa },
+  { 0x13001fcc, 0x2000fff7 },
+  { 0x13801fcd, 0x60000002 },
+  { 0x13001fd0, 0x14000008 },
+  { 0x13001fd1, 0x14000008 },
+  { 0x13801fd2, 0x14000001 },
+  { 0x13801fd6, 0x14000001 },
+  { 0x13001fd8, 0x2400fff8 },
+  { 0x13001fd9, 0x2400fff8 },
+  { 0x13001fda, 0x2400ff9c },
+  { 0x13001fdb, 0x2400ff9c },
+  { 0x13801fdd, 0x60000002 },
+  { 0x13001fe0, 0x14000008 },
+  { 0x13001fe1, 0x14000008 },
+  { 0x13801fe2, 0x14000002 },
+  { 0x13001fe5, 0x14000007 },
+  { 0x13801fe6, 0x14000001 },
+  { 0x13001fe8, 0x2400fff8 },
+  { 0x13001fe9, 0x2400fff8 },
+  { 0x13001fea, 0x2400ff90 },
+  { 0x13001feb, 0x2400ff90 },
+  { 0x13001fec, 0x2400fff9 },
+  { 0x13801fed, 0x60000002 },
+  { 0x13001ff2, 0x14000000 },
+  { 0x13001ff3, 0x14000009 },
+  { 0x13001ff4, 0x14000000 },
+  { 0x13801ff6, 0x14000001 },
+  { 0x13001ff8, 0x2400ff80 },
+  { 0x13001ff9, 0x2400ff80 },
+  { 0x13001ffa, 0x2400ff82 },
+  { 0x13001ffb, 0x2400ff82 },
+  { 0x13001ffc, 0x2000fff7 },
+  { 0x13801ffd, 0x60000001 },
+  { 0x09802000, 0x7400000a },
+  { 0x0980200b, 0x04000004 },
+  { 0x09802010, 0x44000005 },
+  { 0x09802016, 0x54000001 },
+  { 0x09002018, 0x50000000 },
+  { 0x09002019, 0x4c000000 },
+  { 0x0900201a, 0x58000000 },
+  { 0x0980201b, 0x50000001 },
+  { 0x0900201d, 0x4c000000 },
+  { 0x0900201e, 0x58000000 },
+  { 0x0900201f, 0x50000000 },
+  { 0x09802020, 0x54000007 },
+  { 0x09002028, 0x6c000000 },
+  { 0x09002029, 0x70000000 },
+  { 0x0980202a, 0x04000004 },
+  { 0x0900202f, 0x74000000 },
+  { 0x09802030, 0x54000008 },
+  { 0x09002039, 0x50000000 },
+  { 0x0900203a, 0x4c000000 },
+  { 0x0980203b, 0x54000003 },
+  { 0x0980203f, 0x40000001 },
+  { 0x09802041, 0x54000002 },
+  { 0x09002044, 0x64000000 },
+  { 0x09002045, 0x58000000 },
+  { 0x09002046, 0x48000000 },
+  { 0x09802047, 0x5400000a },
+  { 0x09002052, 0x64000000 },
+  { 0x09002053, 0x54000000 },
+  { 0x09002054, 0x40000000 },
+  { 0x09802055, 0x54000009 },
+  { 0x0900205f, 0x74000000 },
+  { 0x09802060, 0x04000003 },
+  { 0x0980206a, 0x04000005 },
+  { 0x09002070, 0x3c000000 },
+  { 0x21002071, 0x14000000 },
+  { 0x09802074, 0x3c000005 },
+  { 0x0980207a, 0x64000002 },
+  { 0x0900207d, 0x58000000 },
+  { 0x0900207e, 0x48000000 },
+  { 0x2100207f, 0x14000000 },
+  { 0x09802080, 0x3c000009 },
+  { 0x0980208a, 0x64000002 },
+  { 0x0900208d, 0x58000000 },
+  { 0x0900208e, 0x48000000 },
+  { 0x21802090, 0x18000004 },
+  { 0x098020a0, 0x5c000015 },
+  { 0x1b8020d0, 0x3000000c },
+  { 0x1b8020dd, 0x2c000003 },
+  { 0x1b0020e1, 0x30000000 },
+  { 0x1b8020e2, 0x2c000002 },
+  { 0x1b8020e5, 0x30000006 },
+  { 0x09802100, 0x68000001 },
+  { 0x09002102, 0x24000000 },
+  { 0x09802103, 0x68000003 },
+  { 0x09002107, 0x24000000 },
+  { 0x09802108, 0x68000001 },
+  { 0x0900210a, 0x14000000 },
+  { 0x0980210b, 0x24000002 },
+  { 0x0980210e, 0x14000001 },
+  { 0x09802110, 0x24000002 },
+  { 0x09002113, 0x14000000 },
+  { 0x09002114, 0x68000000 },
+  { 0x09002115, 0x24000000 },
+  { 0x09802116, 0x68000002 },
+  { 0x09802119, 0x24000004 },
+  { 0x0980211e, 0x68000005 },
+  { 0x09002124, 0x24000000 },
+  { 0x09002125, 0x68000000 },
+  { 0x13002126, 0x2400e2a3 },
+  { 0x09002127, 0x68000000 },
+  { 0x09002128, 0x24000000 },
+  { 0x09002129, 0x68000000 },
+  { 0x2100212a, 0x2400df41 },
+  { 0x2100212b, 0x2400dfba },
+  { 0x0980212c, 0x24000001 },
+  { 0x0900212e, 0x68000000 },
+  { 0x0900212f, 0x14000000 },
+  { 0x09802130, 0x24000001 },
+  { 0x09002132, 0x68000000 },
+  { 0x09002133, 0x24000000 },
+  { 0x09002134, 0x14000000 },
+  { 0x09802135, 0x1c000003 },
+  { 0x09002139, 0x14000000 },
+  { 0x0980213a, 0x68000001 },
+  { 0x0980213c, 0x14000001 },
+  { 0x0980213e, 0x24000001 },
+  { 0x09802140, 0x64000004 },
+  { 0x09002145, 0x24000000 },
+  { 0x09802146, 0x14000003 },
+  { 0x0900214a, 0x68000000 },
+  { 0x0900214b, 0x64000000 },
+  { 0x0900214c, 0x68000000 },
+  { 0x09802153, 0x3c00000c },
+  { 0x09002160, 0x38000010 },
+  { 0x09002161, 0x38000010 },
+  { 0x09002162, 0x38000010 },
+  { 0x09002163, 0x38000010 },
+  { 0x09002164, 0x38000010 },
+  { 0x09002165, 0x38000010 },
+  { 0x09002166, 0x38000010 },
+  { 0x09002167, 0x38000010 },
+  { 0x09002168, 0x38000010 },
+  { 0x09002169, 0x38000010 },
+  { 0x0900216a, 0x38000010 },
+  { 0x0900216b, 0x38000010 },
+  { 0x0900216c, 0x38000010 },
+  { 0x0900216d, 0x38000010 },
+  { 0x0900216e, 0x38000010 },
+  { 0x0900216f, 0x38000010 },
+  { 0x09002170, 0x3800fff0 },
+  { 0x09002171, 0x3800fff0 },
+  { 0x09002172, 0x3800fff0 },
+  { 0x09002173, 0x3800fff0 },
+  { 0x09002174, 0x3800fff0 },
+  { 0x09002175, 0x3800fff0 },
+  { 0x09002176, 0x3800fff0 },
+  { 0x09002177, 0x3800fff0 },
+  { 0x09002178, 0x3800fff0 },
+  { 0x09002179, 0x3800fff0 },
+  { 0x0900217a, 0x3800fff0 },
+  { 0x0900217b, 0x3800fff0 },
+  { 0x0900217c, 0x3800fff0 },
+  { 0x0900217d, 0x3800fff0 },
+  { 0x0900217e, 0x3800fff0 },
+  { 0x0900217f, 0x3800fff0 },
+  { 0x09802180, 0x38000003 },
+  { 0x09802190, 0x64000004 },
+  { 0x09802195, 0x68000004 },
+  { 0x0980219a, 0x64000001 },
+  { 0x0980219c, 0x68000003 },
+  { 0x090021a0, 0x64000000 },
+  { 0x098021a1, 0x68000001 },
+  { 0x090021a3, 0x64000000 },
+  { 0x098021a4, 0x68000001 },
+  { 0x090021a6, 0x64000000 },
+  { 0x098021a7, 0x68000006 },
+  { 0x090021ae, 0x64000000 },
+  { 0x098021af, 0x6800001e },
+  { 0x098021ce, 0x64000001 },
+  { 0x098021d0, 0x68000001 },
+  { 0x090021d2, 0x64000000 },
+  { 0x090021d3, 0x68000000 },
+  { 0x090021d4, 0x64000000 },
+  { 0x098021d5, 0x6800001e },
+  { 0x098021f4, 0x6400010b },
+  { 0x09802300, 0x68000007 },
+  { 0x09802308, 0x64000003 },
+  { 0x0980230c, 0x68000013 },
+  { 0x09802320, 0x64000001 },
+  { 0x09802322, 0x68000006 },
+  { 0x09002329, 0x58000000 },
+  { 0x0900232a, 0x48000000 },
+  { 0x0980232b, 0x68000050 },
+  { 0x0900237c, 0x64000000 },
+  { 0x0980237d, 0x6800001d },
+  { 0x0980239b, 0x64000018 },
+  { 0x090023b4, 0x58000000 },
+  { 0x090023b5, 0x48000000 },
+  { 0x090023b6, 0x54000000 },
+  { 0x098023b7, 0x68000024 },
+  { 0x09802400, 0x68000026 },
+  { 0x09802440, 0x6800000a },
+  { 0x09802460, 0x3c00003b },
+  { 0x0980249c, 0x68000019 },
+  { 0x090024b6, 0x6800001a },
+  { 0x090024b7, 0x6800001a },
+  { 0x090024b8, 0x6800001a },
+  { 0x090024b9, 0x6800001a },
+  { 0x090024ba, 0x6800001a },
+  { 0x090024bb, 0x6800001a },
+  { 0x090024bc, 0x6800001a },
+  { 0x090024bd, 0x6800001a },
+  { 0x090024be, 0x6800001a },
+  { 0x090024bf, 0x6800001a },
+  { 0x090024c0, 0x6800001a },
+  { 0x090024c1, 0x6800001a },
+  { 0x090024c2, 0x6800001a },
+  { 0x090024c3, 0x6800001a },
+  { 0x090024c4, 0x6800001a },
+  { 0x090024c5, 0x6800001a },
+  { 0x090024c6, 0x6800001a },
+  { 0x090024c7, 0x6800001a },
+  { 0x090024c8, 0x6800001a },
+  { 0x090024c9, 0x6800001a },
+  { 0x090024ca, 0x6800001a },
+  { 0x090024cb, 0x6800001a },
+  { 0x090024cc, 0x6800001a },
+  { 0x090024cd, 0x6800001a },
+  { 0x090024ce, 0x6800001a },
+  { 0x090024cf, 0x6800001a },
+  { 0x090024d0, 0x6800ffe6 },
+  { 0x090024d1, 0x6800ffe6 },
+  { 0x090024d2, 0x6800ffe6 },
+  { 0x090024d3, 0x6800ffe6 },
+  { 0x090024d4, 0x6800ffe6 },
+  { 0x090024d5, 0x6800ffe6 },
+  { 0x090024d6, 0x6800ffe6 },
+  { 0x090024d7, 0x6800ffe6 },
+  { 0x090024d8, 0x6800ffe6 },
+  { 0x090024d9, 0x6800ffe6 },
+  { 0x090024da, 0x6800ffe6 },
+  { 0x090024db, 0x6800ffe6 },
+  { 0x090024dc, 0x6800ffe6 },
+  { 0x090024dd, 0x6800ffe6 },
+  { 0x090024de, 0x6800ffe6 },
+  { 0x090024df, 0x6800ffe6 },
+  { 0x090024e0, 0x6800ffe6 },
+  { 0x090024e1, 0x6800ffe6 },
+  { 0x090024e2, 0x6800ffe6 },
+  { 0x090024e3, 0x6800ffe6 },
+  { 0x090024e4, 0x6800ffe6 },
+  { 0x090024e5, 0x6800ffe6 },
+  { 0x090024e6, 0x6800ffe6 },
+  { 0x090024e7, 0x6800ffe6 },
+  { 0x090024e8, 0x6800ffe6 },
+  { 0x090024e9, 0x6800ffe6 },
+  { 0x098024ea, 0x3c000015 },
+  { 0x09802500, 0x680000b6 },
+  { 0x090025b7, 0x64000000 },
+  { 0x098025b8, 0x68000008 },
+  { 0x090025c1, 0x64000000 },
+  { 0x098025c2, 0x68000035 },
+  { 0x098025f8, 0x64000007 },
+  { 0x09802600, 0x6800006e },
+  { 0x0900266f, 0x64000000 },
+  { 0x09802670, 0x6800002c },
+  { 0x098026a0, 0x68000011 },
+  { 0x09802701, 0x68000003 },
+  { 0x09802706, 0x68000003 },
+  { 0x0980270c, 0x6800001b },
+  { 0x09802729, 0x68000022 },
+  { 0x0900274d, 0x68000000 },
+  { 0x0980274f, 0x68000003 },
+  { 0x09002756, 0x68000000 },
+  { 0x09802758, 0x68000006 },
+  { 0x09802761, 0x68000006 },
+  { 0x09002768, 0x58000000 },
+  { 0x09002769, 0x48000000 },
+  { 0x0900276a, 0x58000000 },
+  { 0x0900276b, 0x48000000 },
+  { 0x0900276c, 0x58000000 },
+  { 0x0900276d, 0x48000000 },
+  { 0x0900276e, 0x58000000 },
+  { 0x0900276f, 0x48000000 },
+  { 0x09002770, 0x58000000 },
+  { 0x09002771, 0x48000000 },
+  { 0x09002772, 0x58000000 },
+  { 0x09002773, 0x48000000 },
+  { 0x09002774, 0x58000000 },
+  { 0x09002775, 0x48000000 },
+  { 0x09802776, 0x3c00001d },
+  { 0x09002794, 0x68000000 },
+  { 0x09802798, 0x68000017 },
+  { 0x098027b1, 0x6800000d },
+  { 0x098027c0, 0x64000004 },
+  { 0x090027c5, 0x58000000 },
+  { 0x090027c6, 0x48000000 },
+  { 0x098027d0, 0x64000015 },
+  { 0x090027e6, 0x58000000 },
+  { 0x090027e7, 0x48000000 },
+  { 0x090027e8, 0x58000000 },
+  { 0x090027e9, 0x48000000 },
+  { 0x090027ea, 0x58000000 },
+  { 0x090027eb, 0x48000000 },
+  { 0x098027f0, 0x6400000f },
+  { 0x04802800, 0x680000ff },
+  { 0x09802900, 0x64000082 },
+  { 0x09002983, 0x58000000 },
+  { 0x09002984, 0x48000000 },
+  { 0x09002985, 0x58000000 },
+  { 0x09002986, 0x48000000 },
+  { 0x09002987, 0x58000000 },
+  { 0x09002988, 0x48000000 },
+  { 0x09002989, 0x58000000 },
+  { 0x0900298a, 0x48000000 },
+  { 0x0900298b, 0x58000000 },
+  { 0x0900298c, 0x48000000 },
+  { 0x0900298d, 0x58000000 },
+  { 0x0900298e, 0x48000000 },
+  { 0x0900298f, 0x58000000 },
+  { 0x09002990, 0x48000000 },
+  { 0x09002991, 0x58000000 },
+  { 0x09002992, 0x48000000 },
+  { 0x09002993, 0x58000000 },
+  { 0x09002994, 0x48000000 },
+  { 0x09002995, 0x58000000 },
+  { 0x09002996, 0x48000000 },
+  { 0x09002997, 0x58000000 },
+  { 0x09002998, 0x48000000 },
+  { 0x09802999, 0x6400003e },
+  { 0x090029d8, 0x58000000 },
+  { 0x090029d9, 0x48000000 },
+  { 0x090029da, 0x58000000 },
+  { 0x090029db, 0x48000000 },
+  { 0x098029dc, 0x6400001f },
+  { 0x090029fc, 0x58000000 },
+  { 0x090029fd, 0x48000000 },
+  { 0x098029fe, 0x64000101 },
+  { 0x09802b00, 0x68000013 },
+  { 0x11002c00, 0x24000030 },
+  { 0x11002c01, 0x24000030 },
+  { 0x11002c02, 0x24000030 },
+  { 0x11002c03, 0x24000030 },
+  { 0x11002c04, 0x24000030 },
+  { 0x11002c05, 0x24000030 },
+  { 0x11002c06, 0x24000030 },
+  { 0x11002c07, 0x24000030 },
+  { 0x11002c08, 0x24000030 },
+  { 0x11002c09, 0x24000030 },
+  { 0x11002c0a, 0x24000030 },
+  { 0x11002c0b, 0x24000030 },
+  { 0x11002c0c, 0x24000030 },
+  { 0x11002c0d, 0x24000030 },
+  { 0x11002c0e, 0x24000030 },
+  { 0x11002c0f, 0x24000030 },
+  { 0x11002c10, 0x24000030 },
+  { 0x11002c11, 0x24000030 },
+  { 0x11002c12, 0x24000030 },
+  { 0x11002c13, 0x24000030 },
+  { 0x11002c14, 0x24000030 },
+  { 0x11002c15, 0x24000030 },
+  { 0x11002c16, 0x24000030 },
+  { 0x11002c17, 0x24000030 },
+  { 0x11002c18, 0x24000030 },
+  { 0x11002c19, 0x24000030 },
+  { 0x11002c1a, 0x24000030 },
+  { 0x11002c1b, 0x24000030 },
+  { 0x11002c1c, 0x24000030 },
+  { 0x11002c1d, 0x24000030 },
+  { 0x11002c1e, 0x24000030 },
+  { 0x11002c1f, 0x24000030 },
+  { 0x11002c20, 0x24000030 },
+  { 0x11002c21, 0x24000030 },
+  { 0x11002c22, 0x24000030 },
+  { 0x11002c23, 0x24000030 },
+  { 0x11002c24, 0x24000030 },
+  { 0x11002c25, 0x24000030 },
+  { 0x11002c26, 0x24000030 },
+  { 0x11002c27, 0x24000030 },
+  { 0x11002c28, 0x24000030 },
+  { 0x11002c29, 0x24000030 },
+  { 0x11002c2a, 0x24000030 },
+  { 0x11002c2b, 0x24000030 },
+  { 0x11002c2c, 0x24000030 },
+  { 0x11002c2d, 0x24000030 },
+  { 0x11002c2e, 0x24000030 },
+  { 0x11002c30, 0x1400ffd0 },
+  { 0x11002c31, 0x1400ffd0 },
+  { 0x11002c32, 0x1400ffd0 },
+  { 0x11002c33, 0x1400ffd0 },
+  { 0x11002c34, 0x1400ffd0 },
+  { 0x11002c35, 0x1400ffd0 },
+  { 0x11002c36, 0x1400ffd0 },
+  { 0x11002c37, 0x1400ffd0 },
+  { 0x11002c38, 0x1400ffd0 },
+  { 0x11002c39, 0x1400ffd0 },
+  { 0x11002c3a, 0x1400ffd0 },
+  { 0x11002c3b, 0x1400ffd0 },
+  { 0x11002c3c, 0x1400ffd0 },
+  { 0x11002c3d, 0x1400ffd0 },
+  { 0x11002c3e, 0x1400ffd0 },
+  { 0x11002c3f, 0x1400ffd0 },
+  { 0x11002c40, 0x1400ffd0 },
+  { 0x11002c41, 0x1400ffd0 },
+  { 0x11002c42, 0x1400ffd0 },
+  { 0x11002c43, 0x1400ffd0 },
+  { 0x11002c44, 0x1400ffd0 },
+  { 0x11002c45, 0x1400ffd0 },
+  { 0x11002c46, 0x1400ffd0 },
+  { 0x11002c47, 0x1400ffd0 },
+  { 0x11002c48, 0x1400ffd0 },
+  { 0x11002c49, 0x1400ffd0 },
+  { 0x11002c4a, 0x1400ffd0 },
+  { 0x11002c4b, 0x1400ffd0 },
+  { 0x11002c4c, 0x1400ffd0 },
+  { 0x11002c4d, 0x1400ffd0 },
+  { 0x11002c4e, 0x1400ffd0 },
+  { 0x11002c4f, 0x1400ffd0 },
+  { 0x11002c50, 0x1400ffd0 },
+  { 0x11002c51, 0x1400ffd0 },
+  { 0x11002c52, 0x1400ffd0 },
+  { 0x11002c53, 0x1400ffd0 },
+  { 0x11002c54, 0x1400ffd0 },
+  { 0x11002c55, 0x1400ffd0 },
+  { 0x11002c56, 0x1400ffd0 },
+  { 0x11002c57, 0x1400ffd0 },
+  { 0x11002c58, 0x1400ffd0 },
+  { 0x11002c59, 0x1400ffd0 },
+  { 0x11002c5a, 0x1400ffd0 },
+  { 0x11002c5b, 0x1400ffd0 },
+  { 0x11002c5c, 0x1400ffd0 },
+  { 0x11002c5d, 0x1400ffd0 },
+  { 0x11002c5e, 0x1400ffd0 },
+  { 0x0a002c80, 0x24000001 },
+  { 0x0a002c81, 0x1400ffff },
+  { 0x0a002c82, 0x24000001 },
+  { 0x0a002c83, 0x1400ffff },
+  { 0x0a002c84, 0x24000001 },
+  { 0x0a002c85, 0x1400ffff },
+  { 0x0a002c86, 0x24000001 },
+  { 0x0a002c87, 0x1400ffff },
+  { 0x0a002c88, 0x24000001 },
+  { 0x0a002c89, 0x1400ffff },
+  { 0x0a002c8a, 0x24000001 },
+  { 0x0a002c8b, 0x1400ffff },
+  { 0x0a002c8c, 0x24000001 },
+  { 0x0a002c8d, 0x1400ffff },
+  { 0x0a002c8e, 0x24000001 },
+  { 0x0a002c8f, 0x1400ffff },
+  { 0x0a002c90, 0x24000001 },
+  { 0x0a002c91, 0x1400ffff },
+  { 0x0a002c92, 0x24000001 },
+  { 0x0a002c93, 0x1400ffff },
+  { 0x0a002c94, 0x24000001 },
+  { 0x0a002c95, 0x1400ffff },
+  { 0x0a002c96, 0x24000001 },
+  { 0x0a002c97, 0x1400ffff },
+  { 0x0a002c98, 0x24000001 },
+  { 0x0a002c99, 0x1400ffff },
+  { 0x0a002c9a, 0x24000001 },
+  { 0x0a002c9b, 0x1400ffff },
+  { 0x0a002c9c, 0x24000001 },
+  { 0x0a002c9d, 0x1400ffff },
+  { 0x0a002c9e, 0x24000001 },
+  { 0x0a002c9f, 0x1400ffff },
+  { 0x0a002ca0, 0x24000001 },
+  { 0x0a002ca1, 0x1400ffff },
+  { 0x0a002ca2, 0x24000001 },
+  { 0x0a002ca3, 0x1400ffff },
+  { 0x0a002ca4, 0x24000001 },
+  { 0x0a002ca5, 0x1400ffff },
+  { 0x0a002ca6, 0x24000001 },
+  { 0x0a002ca7, 0x1400ffff },
+  { 0x0a002ca8, 0x24000001 },
+  { 0x0a002ca9, 0x1400ffff },
+  { 0x0a002caa, 0x24000001 },
+  { 0x0a002cab, 0x1400ffff },
+  { 0x0a002cac, 0x24000001 },
+  { 0x0a002cad, 0x1400ffff },
+  { 0x0a002cae, 0x24000001 },
+  { 0x0a002caf, 0x1400ffff },
+  { 0x0a002cb0, 0x24000001 },
+  { 0x0a002cb1, 0x1400ffff },
+  { 0x0a002cb2, 0x24000001 },
+  { 0x0a002cb3, 0x1400ffff },
+  { 0x0a002cb4, 0x24000001 },
+  { 0x0a002cb5, 0x1400ffff },
+  { 0x0a002cb6, 0x24000001 },
+  { 0x0a002cb7, 0x1400ffff },
+  { 0x0a002cb8, 0x24000001 },
+  { 0x0a002cb9, 0x1400ffff },
+  { 0x0a002cba, 0x24000001 },
+  { 0x0a002cbb, 0x1400ffff },
+  { 0x0a002cbc, 0x24000001 },
+  { 0x0a002cbd, 0x1400ffff },
+  { 0x0a002cbe, 0x24000001 },
+  { 0x0a002cbf, 0x1400ffff },
+  { 0x0a002cc0, 0x24000001 },
+  { 0x0a002cc1, 0x1400ffff },
+  { 0x0a002cc2, 0x24000001 },
+  { 0x0a002cc3, 0x1400ffff },
+  { 0x0a002cc4, 0x24000001 },
+  { 0x0a002cc5, 0x1400ffff },
+  { 0x0a002cc6, 0x24000001 },
+  { 0x0a002cc7, 0x1400ffff },
+  { 0x0a002cc8, 0x24000001 },
+  { 0x0a002cc9, 0x1400ffff },
+  { 0x0a002cca, 0x24000001 },
+  { 0x0a002ccb, 0x1400ffff },
+  { 0x0a002ccc, 0x24000001 },
+  { 0x0a002ccd, 0x1400ffff },
+  { 0x0a002cce, 0x24000001 },
+  { 0x0a002ccf, 0x1400ffff },
+  { 0x0a002cd0, 0x24000001 },
+  { 0x0a002cd1, 0x1400ffff },
+  { 0x0a002cd2, 0x24000001 },
+  { 0x0a002cd3, 0x1400ffff },
+  { 0x0a002cd4, 0x24000001 },
+  { 0x0a002cd5, 0x1400ffff },
+  { 0x0a002cd6, 0x24000001 },
+  { 0x0a002cd7, 0x1400ffff },
+  { 0x0a002cd8, 0x24000001 },
+  { 0x0a002cd9, 0x1400ffff },
+  { 0x0a002cda, 0x24000001 },
+  { 0x0a002cdb, 0x1400ffff },
+  { 0x0a002cdc, 0x24000001 },
+  { 0x0a002cdd, 0x1400ffff },
+  { 0x0a002cde, 0x24000001 },
+  { 0x0a002cdf, 0x1400ffff },
+  { 0x0a002ce0, 0x24000001 },
+  { 0x0a002ce1, 0x1400ffff },
+  { 0x0a002ce2, 0x24000001 },
+  { 0x0a002ce3, 0x1400ffff },
+  { 0x0a002ce4, 0x14000000 },
+  { 0x0a802ce5, 0x68000005 },
+  { 0x0a802cf9, 0x54000003 },
+  { 0x0a002cfd, 0x3c000000 },
+  { 0x0a802cfe, 0x54000001 },
+  { 0x10002d00, 0x1400e3a0 },
+  { 0x10002d01, 0x1400e3a0 },
+  { 0x10002d02, 0x1400e3a0 },
+  { 0x10002d03, 0x1400e3a0 },
+  { 0x10002d04, 0x1400e3a0 },
+  { 0x10002d05, 0x1400e3a0 },
+  { 0x10002d06, 0x1400e3a0 },
+  { 0x10002d07, 0x1400e3a0 },
+  { 0x10002d08, 0x1400e3a0 },
+  { 0x10002d09, 0x1400e3a0 },
+  { 0x10002d0a, 0x1400e3a0 },
+  { 0x10002d0b, 0x1400e3a0 },
+  { 0x10002d0c, 0x1400e3a0 },
+  { 0x10002d0d, 0x1400e3a0 },
+  { 0x10002d0e, 0x1400e3a0 },
+  { 0x10002d0f, 0x1400e3a0 },
+  { 0x10002d10, 0x1400e3a0 },
+  { 0x10002d11, 0x1400e3a0 },
+  { 0x10002d12, 0x1400e3a0 },
+  { 0x10002d13, 0x1400e3a0 },
+  { 0x10002d14, 0x1400e3a0 },
+  { 0x10002d15, 0x1400e3a0 },
+  { 0x10002d16, 0x1400e3a0 },
+  { 0x10002d17, 0x1400e3a0 },
+  { 0x10002d18, 0x1400e3a0 },
+  { 0x10002d19, 0x1400e3a0 },
+  { 0x10002d1a, 0x1400e3a0 },
+  { 0x10002d1b, 0x1400e3a0 },
+  { 0x10002d1c, 0x1400e3a0 },
+  { 0x10002d1d, 0x1400e3a0 },
+  { 0x10002d1e, 0x1400e3a0 },
+  { 0x10002d1f, 0x1400e3a0 },
+  { 0x10002d20, 0x1400e3a0 },
+  { 0x10002d21, 0x1400e3a0 },
+  { 0x10002d22, 0x1400e3a0 },
+  { 0x10002d23, 0x1400e3a0 },
+  { 0x10002d24, 0x1400e3a0 },
+  { 0x10002d25, 0x1400e3a0 },
+  { 0x3a802d30, 0x1c000035 },
+  { 0x3a002d6f, 0x18000000 },
+  { 0x0f802d80, 0x1c000016 },
+  { 0x0f802da0, 0x1c000006 },
+  { 0x0f802da8, 0x1c000006 },
+  { 0x0f802db0, 0x1c000006 },
+  { 0x0f802db8, 0x1c000006 },
+  { 0x0f802dc0, 0x1c000006 },
+  { 0x0f802dc8, 0x1c000006 },
+  { 0x0f802dd0, 0x1c000006 },
+  { 0x0f802dd8, 0x1c000006 },
+  { 0x09802e00, 0x54000001 },
+  { 0x09002e02, 0x50000000 },
+  { 0x09002e03, 0x4c000000 },
+  { 0x09002e04, 0x50000000 },
+  { 0x09002e05, 0x4c000000 },
+  { 0x09802e06, 0x54000002 },
+  { 0x09002e09, 0x50000000 },
+  { 0x09002e0a, 0x4c000000 },
+  { 0x09002e0b, 0x54000000 },
+  { 0x09002e0c, 0x50000000 },
+  { 0x09002e0d, 0x4c000000 },
+  { 0x09802e0e, 0x54000008 },
+  { 0x09002e17, 0x44000000 },
+  { 0x09002e1c, 0x50000000 },
+  { 0x09002e1d, 0x4c000000 },
+  { 0x16802e80, 0x68000019 },
+  { 0x16802e9b, 0x68000058 },
+  { 0x16802f00, 0x680000d5 },
+  { 0x09802ff0, 0x6800000b },
+  { 0x09003000, 0x74000000 },
+  { 0x09803001, 0x54000002 },
+  { 0x09003004, 0x68000000 },
+  { 0x16003005, 0x18000000 },
+  { 0x09003006, 0x1c000000 },
+  { 0x16003007, 0x38000000 },
+  { 0x09003008, 0x58000000 },
+  { 0x09003009, 0x48000000 },
+  { 0x0900300a, 0x58000000 },
+  { 0x0900300b, 0x48000000 },
+  { 0x0900300c, 0x58000000 },
+  { 0x0900300d, 0x48000000 },
+  { 0x0900300e, 0x58000000 },
+  { 0x0900300f, 0x48000000 },
+  { 0x09003010, 0x58000000 },
+  { 0x09003011, 0x48000000 },
+  { 0x09803012, 0x68000001 },
+  { 0x09003014, 0x58000000 },
+  { 0x09003015, 0x48000000 },
+  { 0x09003016, 0x58000000 },
+  { 0x09003017, 0x48000000 },
+  { 0x09003018, 0x58000000 },
+  { 0x09003019, 0x48000000 },
+  { 0x0900301a, 0x58000000 },
+  { 0x0900301b, 0x48000000 },
+  { 0x0900301c, 0x44000000 },
+  { 0x0900301d, 0x58000000 },
+  { 0x0980301e, 0x48000001 },
+  { 0x09003020, 0x68000000 },
+  { 0x16803021, 0x38000008 },
+  { 0x1b80302a, 0x30000005 },
+  { 0x09003030, 0x44000000 },
+  { 0x09803031, 0x18000004 },
+  { 0x09803036, 0x68000001 },
+  { 0x16803038, 0x38000002 },
+  { 0x1600303b, 0x18000000 },
+  { 0x0900303c, 0x1c000000 },
+  { 0x0900303d, 0x54000000 },
+  { 0x0980303e, 0x68000001 },
+  { 0x1a803041, 0x1c000055 },
+  { 0x1b803099, 0x30000001 },
+  { 0x0980309b, 0x60000001 },
+  { 0x1a80309d, 0x18000001 },
+  { 0x1a00309f, 0x1c000000 },
+  { 0x090030a0, 0x44000000 },
+  { 0x1d8030a1, 0x1c000059 },
+  { 0x090030fb, 0x54000000 },
+  { 0x098030fc, 0x18000002 },
+  { 0x1d0030ff, 0x1c000000 },
+  { 0x03803105, 0x1c000027 },
+  { 0x17803131, 0x1c00005d },
+  { 0x09803190, 0x68000001 },
+  { 0x09803192, 0x3c000003 },
+  { 0x09803196, 0x68000009 },
+  { 0x038031a0, 0x1c000017 },
+  { 0x098031c0, 0x6800000f },
+  { 0x1d8031f0, 0x1c00000f },
+  { 0x17803200, 0x6800001e },
+  { 0x09803220, 0x3c000009 },
+  { 0x0980322a, 0x68000019 },
+  { 0x09003250, 0x68000000 },
+  { 0x09803251, 0x3c00000e },
+  { 0x17803260, 0x6800001f },
+  { 0x09803280, 0x3c000009 },
+  { 0x0980328a, 0x68000026 },
+  { 0x098032b1, 0x3c00000e },
+  { 0x098032c0, 0x6800003e },
+  { 0x09803300, 0x680000ff },
+  { 0x16803400, 0x1c0019b5 },
+  { 0x09804dc0, 0x6800003f },
+  { 0x16804e00, 0x1c0051bb },
+  { 0x3c80a000, 0x1c000014 },
+  { 0x3c00a015, 0x18000000 },
+  { 0x3c80a016, 0x1c000476 },
+  { 0x3c80a490, 0x68000036 },
+  { 0x0980a700, 0x60000016 },
+  { 0x3080a800, 0x1c000001 },
+  { 0x3000a802, 0x28000000 },
+  { 0x3080a803, 0x1c000002 },
+  { 0x3000a806, 0x30000000 },
+  { 0x3080a807, 0x1c000003 },
+  { 0x3000a80b, 0x30000000 },
+  { 0x3080a80c, 0x1c000016 },
+  { 0x3080a823, 0x28000001 },
+  { 0x3080a825, 0x30000001 },
+  { 0x3000a827, 0x28000000 },
+  { 0x3080a828, 0x68000003 },
+  { 0x1780ac00, 0x1c002ba3 },
+  { 0x0980d800, 0x1000037f },
+  { 0x0980db80, 0x1000007f },
+  { 0x0980dc00, 0x100003ff },
+  { 0x0980e000, 0x0c0018ff },
+  { 0x1680f900, 0x1c00012d },
+  { 0x1680fa30, 0x1c00003a },
+  { 0x1680fa70, 0x1c000069 },
+  { 0x2180fb00, 0x14000006 },
+  { 0x0180fb13, 0x14000004 },
+  { 0x1900fb1d, 0x1c000000 },
+  { 0x1900fb1e, 0x30000000 },
+  { 0x1980fb1f, 0x1c000009 },
+  { 0x1900fb29, 0x64000000 },
+  { 0x1980fb2a, 0x1c00000c },
+  { 0x1980fb38, 0x1c000004 },
+  { 0x1900fb3e, 0x1c000000 },
+  { 0x1980fb40, 0x1c000001 },
+  { 0x1980fb43, 0x1c000001 },
+  { 0x1980fb46, 0x1c00006b },
+  { 0x0080fbd3, 0x1c00016a },
+  { 0x0900fd3e, 0x58000000 },
+  { 0x0900fd3f, 0x48000000 },
+  { 0x0080fd50, 0x1c00003f },
+  { 0x0080fd92, 0x1c000035 },
+  { 0x0080fdf0, 0x1c00000b },
+  { 0x0000fdfc, 0x5c000000 },
+  { 0x0900fdfd, 0x68000000 },
+  { 0x1b80fe00, 0x3000000f },
+  { 0x0980fe10, 0x54000006 },
+  { 0x0900fe17, 0x58000000 },
+  { 0x0900fe18, 0x48000000 },
+  { 0x0900fe19, 0x54000000 },
+  { 0x1b80fe20, 0x30000003 },
+  { 0x0900fe30, 0x54000000 },
+  { 0x0980fe31, 0x44000001 },
+  { 0x0980fe33, 0x40000001 },
+  { 0x0900fe35, 0x58000000 },
+  { 0x0900fe36, 0x48000000 },
+  { 0x0900fe37, 0x58000000 },
+  { 0x0900fe38, 0x48000000 },
+  { 0x0900fe39, 0x58000000 },
+  { 0x0900fe3a, 0x48000000 },
+  { 0x0900fe3b, 0x58000000 },
+  { 0x0900fe3c, 0x48000000 },
+  { 0x0900fe3d, 0x58000000 },
+  { 0x0900fe3e, 0x48000000 },
+  { 0x0900fe3f, 0x58000000 },
+  { 0x0900fe40, 0x48000000 },
+  { 0x0900fe41, 0x58000000 },
+  { 0x0900fe42, 0x48000000 },
+  { 0x0900fe43, 0x58000000 },
+  { 0x0900fe44, 0x48000000 },
+  { 0x0980fe45, 0x54000001 },
+  { 0x0900fe47, 0x58000000 },
+  { 0x0900fe48, 0x48000000 },
+  { 0x0980fe49, 0x54000003 },
+  { 0x0980fe4d, 0x40000002 },
+  { 0x0980fe50, 0x54000002 },
+  { 0x0980fe54, 0x54000003 },
+  { 0x0900fe58, 0x44000000 },
+  { 0x0900fe59, 0x58000000 },
+  { 0x0900fe5a, 0x48000000 },
+  { 0x0900fe5b, 0x58000000 },
+  { 0x0900fe5c, 0x48000000 },
+  { 0x0900fe5d, 0x58000000 },
+  { 0x0900fe5e, 0x48000000 },
+  { 0x0980fe5f, 0x54000002 },
+  { 0x0900fe62, 0x64000000 },
+  { 0x0900fe63, 0x44000000 },
+  { 0x0980fe64, 0x64000002 },
+  { 0x0900fe68, 0x54000000 },
+  { 0x0900fe69, 0x5c000000 },
+  { 0x0980fe6a, 0x54000001 },
+  { 0x0080fe70, 0x1c000004 },
+  { 0x0080fe76, 0x1c000086 },
+  { 0x0900feff, 0x04000000 },
+  { 0x0980ff01, 0x54000002 },
+  { 0x0900ff04, 0x5c000000 },
+  { 0x0980ff05, 0x54000002 },
+  { 0x0900ff08, 0x58000000 },
+  { 0x0900ff09, 0x48000000 },
+  { 0x0900ff0a, 0x54000000 },
+  { 0x0900ff0b, 0x64000000 },
+  { 0x0900ff0c, 0x54000000 },
+  { 0x0900ff0d, 0x44000000 },
+  { 0x0980ff0e, 0x54000001 },
+  { 0x0980ff10, 0x34000009 },
+  { 0x0980ff1a, 0x54000001 },
+  { 0x0980ff1c, 0x64000002 },
+  { 0x0980ff1f, 0x54000001 },
+  { 0x2100ff21, 0x24000020 },
+  { 0x2100ff22, 0x24000020 },
+  { 0x2100ff23, 0x24000020 },
+  { 0x2100ff24, 0x24000020 },
+  { 0x2100ff25, 0x24000020 },
+  { 0x2100ff26, 0x24000020 },
+  { 0x2100ff27, 0x24000020 },
+  { 0x2100ff28, 0x24000020 },
+  { 0x2100ff29, 0x24000020 },
+  { 0x2100ff2a, 0x24000020 },
+  { 0x2100ff2b, 0x24000020 },
+  { 0x2100ff2c, 0x24000020 },
+  { 0x2100ff2d, 0x24000020 },
+  { 0x2100ff2e, 0x24000020 },
+  { 0x2100ff2f, 0x24000020 },
+  { 0x2100ff30, 0x24000020 },
+  { 0x2100ff31, 0x24000020 },
+  { 0x2100ff32, 0x24000020 },
+  { 0x2100ff33, 0x24000020 },
+  { 0x2100ff34, 0x24000020 },
+  { 0x2100ff35, 0x24000020 },
+  { 0x2100ff36, 0x24000020 },
+  { 0x2100ff37, 0x24000020 },
+  { 0x2100ff38, 0x24000020 },
+  { 0x2100ff39, 0x24000020 },
+  { 0x2100ff3a, 0x24000020 },
+  { 0x0900ff3b, 0x58000000 },
+  { 0x0900ff3c, 0x54000000 },
+  { 0x0900ff3d, 0x48000000 },
+  { 0x0900ff3e, 0x60000000 },
+  { 0x0900ff3f, 0x40000000 },
+  { 0x0900ff40, 0x60000000 },
+  { 0x2100ff41, 0x1400ffe0 },
+  { 0x2100ff42, 0x1400ffe0 },
+  { 0x2100ff43, 0x1400ffe0 },
+  { 0x2100ff44, 0x1400ffe0 },
+  { 0x2100ff45, 0x1400ffe0 },
+  { 0x2100ff46, 0x1400ffe0 },
+  { 0x2100ff47, 0x1400ffe0 },
+  { 0x2100ff48, 0x1400ffe0 },
+  { 0x2100ff49, 0x1400ffe0 },
+  { 0x2100ff4a, 0x1400ffe0 },
+  { 0x2100ff4b, 0x1400ffe0 },
+  { 0x2100ff4c, 0x1400ffe0 },
+  { 0x2100ff4d, 0x1400ffe0 },
+  { 0x2100ff4e, 0x1400ffe0 },
+  { 0x2100ff4f, 0x1400ffe0 },
+  { 0x2100ff50, 0x1400ffe0 },
+  { 0x2100ff51, 0x1400ffe0 },
+  { 0x2100ff52, 0x1400ffe0 },
+  { 0x2100ff53, 0x1400ffe0 },
+  { 0x2100ff54, 0x1400ffe0 },
+  { 0x2100ff55, 0x1400ffe0 },
+  { 0x2100ff56, 0x1400ffe0 },
+  { 0x2100ff57, 0x1400ffe0 },
+  { 0x2100ff58, 0x1400ffe0 },
+  { 0x2100ff59, 0x1400ffe0 },
+  { 0x2100ff5a, 0x1400ffe0 },
+  { 0x0900ff5b, 0x58000000 },
+  { 0x0900ff5c, 0x64000000 },
+  { 0x0900ff5d, 0x48000000 },
+  { 0x0900ff5e, 0x64000000 },
+  { 0x0900ff5f, 0x58000000 },
+  { 0x0900ff60, 0x48000000 },
+  { 0x0900ff61, 0x54000000 },
+  { 0x0900ff62, 0x58000000 },
+  { 0x0900ff63, 0x48000000 },
+  { 0x0980ff64, 0x54000001 },
+  { 0x1d80ff66, 0x1c000009 },
+  { 0x0900ff70, 0x18000000 },
+  { 0x1d80ff71, 0x1c00002c },
+  { 0x0980ff9e, 0x18000001 },
+  { 0x1780ffa0, 0x1c00001e },
+  { 0x1780ffc2, 0x1c000005 },
+  { 0x1780ffca, 0x1c000005 },
+  { 0x1780ffd2, 0x1c000005 },
+  { 0x1780ffda, 0x1c000002 },
+  { 0x0980ffe0, 0x5c000001 },
+  { 0x0900ffe2, 0x64000000 },
+  { 0x0900ffe3, 0x60000000 },
+  { 0x0900ffe4, 0x68000000 },
+  { 0x0980ffe5, 0x5c000001 },
+  { 0x0900ffe8, 0x68000000 },
+  { 0x0980ffe9, 0x64000003 },
+  { 0x0980ffed, 0x68000001 },
+  { 0x0980fff9, 0x04000002 },
+  { 0x0980fffc, 0x68000001 },
+  { 0x23810000, 0x1c00000b },
+  { 0x2381000d, 0x1c000019 },
+  { 0x23810028, 0x1c000012 },
+  { 0x2381003c, 0x1c000001 },
+  { 0x2381003f, 0x1c00000e },
+  { 0x23810050, 0x1c00000d },
+  { 0x23810080, 0x1c00007a },
+  { 0x09810100, 0x54000001 },
+  { 0x09010102, 0x68000000 },
+  { 0x09810107, 0x3c00002c },
+  { 0x09810137, 0x68000008 },
+  { 0x13810140, 0x38000034 },
+  { 0x13810175, 0x3c000003 },
+  { 0x13810179, 0x68000010 },
+  { 0x1301018a, 0x3c000000 },
+  { 0x29810300, 0x1c00001e },
+  { 0x29810320, 0x3c000003 },
+  { 0x12810330, 0x1c000019 },
+  { 0x1201034a, 0x38000000 },
+  { 0x3b810380, 0x1c00001d },
+  { 0x3b01039f, 0x54000000 },
+  { 0x2a8103a0, 0x1c000023 },
+  { 0x2a8103c8, 0x1c000007 },
+  { 0x2a0103d0, 0x68000000 },
+  { 0x2a8103d1, 0x38000004 },
+  { 0x0d010400, 0x24000028 },
+  { 0x0d010401, 0x24000028 },
+  { 0x0d010402, 0x24000028 },
+  { 0x0d010403, 0x24000028 },
+  { 0x0d010404, 0x24000028 },
+  { 0x0d010405, 0x24000028 },
+  { 0x0d010406, 0x24000028 },
+  { 0x0d010407, 0x24000028 },
+  { 0x0d010408, 0x24000028 },
+  { 0x0d010409, 0x24000028 },
+  { 0x0d01040a, 0x24000028 },
+  { 0x0d01040b, 0x24000028 },
+  { 0x0d01040c, 0x24000028 },
+  { 0x0d01040d, 0x24000028 },
+  { 0x0d01040e, 0x24000028 },
+  { 0x0d01040f, 0x24000028 },
+  { 0x0d010410, 0x24000028 },
+  { 0x0d010411, 0x24000028 },
+  { 0x0d010412, 0x24000028 },
+  { 0x0d010413, 0x24000028 },
+  { 0x0d010414, 0x24000028 },
+  { 0x0d010415, 0x24000028 },
+  { 0x0d010416, 0x24000028 },
+  { 0x0d010417, 0x24000028 },
+  { 0x0d010418, 0x24000028 },
+  { 0x0d010419, 0x24000028 },
+  { 0x0d01041a, 0x24000028 },
+  { 0x0d01041b, 0x24000028 },
+  { 0x0d01041c, 0x24000028 },
+  { 0x0d01041d, 0x24000028 },
+  { 0x0d01041e, 0x24000028 },
+  { 0x0d01041f, 0x24000028 },
+  { 0x0d010420, 0x24000028 },
+  { 0x0d010421, 0x24000028 },
+  { 0x0d010422, 0x24000028 },
+  { 0x0d010423, 0x24000028 },
+  { 0x0d010424, 0x24000028 },
+  { 0x0d010425, 0x24000028 },
+  { 0x0d010426, 0x24000028 },
+  { 0x0d010427, 0x24000028 },
+  { 0x0d010428, 0x1400ffd8 },
+  { 0x0d010429, 0x1400ffd8 },
+  { 0x0d01042a, 0x1400ffd8 },
+  { 0x0d01042b, 0x1400ffd8 },
+  { 0x0d01042c, 0x1400ffd8 },
+  { 0x0d01042d, 0x1400ffd8 },
+  { 0x0d01042e, 0x1400ffd8 },
+  { 0x0d01042f, 0x1400ffd8 },
+  { 0x0d010430, 0x1400ffd8 },
+  { 0x0d010431, 0x1400ffd8 },
+  { 0x0d010432, 0x1400ffd8 },
+  { 0x0d010433, 0x1400ffd8 },
+  { 0x0d010434, 0x1400ffd8 },
+  { 0x0d010435, 0x1400ffd8 },
+  { 0x0d010436, 0x1400ffd8 },
+  { 0x0d010437, 0x1400ffd8 },
+  { 0x0d010438, 0x1400ffd8 },
+  { 0x0d010439, 0x1400ffd8 },
+  { 0x0d01043a, 0x1400ffd8 },
+  { 0x0d01043b, 0x1400ffd8 },
+  { 0x0d01043c, 0x1400ffd8 },
+  { 0x0d01043d, 0x1400ffd8 },
+  { 0x0d01043e, 0x1400ffd8 },
+  { 0x0d01043f, 0x1400ffd8 },
+  { 0x0d010440, 0x1400ffd8 },
+  { 0x0d010441, 0x1400ffd8 },
+  { 0x0d010442, 0x1400ffd8 },
+  { 0x0d010443, 0x1400ffd8 },
+  { 0x0d010444, 0x1400ffd8 },
+  { 0x0d010445, 0x1400ffd8 },
+  { 0x0d010446, 0x1400ffd8 },
+  { 0x0d010447, 0x1400ffd8 },
+  { 0x0d010448, 0x1400ffd8 },
+  { 0x0d010449, 0x1400ffd8 },
+  { 0x0d01044a, 0x1400ffd8 },
+  { 0x0d01044b, 0x1400ffd8 },
+  { 0x0d01044c, 0x1400ffd8 },
+  { 0x0d01044d, 0x1400ffd8 },
+  { 0x0d01044e, 0x1400ffd8 },
+  { 0x0d01044f, 0x1400ffd8 },
+  { 0x2e810450, 0x1c00004d },
+  { 0x2c8104a0, 0x34000009 },
+  { 0x0b810800, 0x1c000005 },
+  { 0x0b010808, 0x1c000000 },
+  { 0x0b81080a, 0x1c00002b },
+  { 0x0b810837, 0x1c000001 },
+  { 0x0b01083c, 0x1c000000 },
+  { 0x0b01083f, 0x1c000000 },
+  { 0x1e010a00, 0x1c000000 },
+  { 0x1e810a01, 0x30000002 },
+  { 0x1e810a05, 0x30000001 },
+  { 0x1e810a0c, 0x30000003 },
+  { 0x1e810a10, 0x1c000003 },
+  { 0x1e810a15, 0x1c000002 },
+  { 0x1e810a19, 0x1c00001a },
+  { 0x1e810a38, 0x30000002 },
+  { 0x1e010a3f, 0x30000000 },
+  { 0x1e810a40, 0x3c000007 },
+  { 0x1e810a50, 0x54000008 },
+  { 0x0981d000, 0x680000f5 },
+  { 0x0981d100, 0x68000026 },
+  { 0x0981d12a, 0x6800003a },
+  { 0x0981d165, 0x28000001 },
+  { 0x1b81d167, 0x30000002 },
+  { 0x0981d16a, 0x68000002 },
+  { 0x0981d16d, 0x28000005 },
+  { 0x0981d173, 0x04000007 },
+  { 0x1b81d17b, 0x30000007 },
+  { 0x0981d183, 0x68000001 },
+  { 0x1b81d185, 0x30000006 },
+  { 0x0981d18c, 0x6800001d },
+  { 0x1b81d1aa, 0x30000003 },
+  { 0x0981d1ae, 0x6800002f },
+  { 0x1381d200, 0x68000041 },
+  { 0x1381d242, 0x30000002 },
+  { 0x1301d245, 0x68000000 },
+  { 0x0981d300, 0x68000056 },
+  { 0x0981d400, 0x24000019 },
+  { 0x0981d41a, 0x14000019 },
+  { 0x0981d434, 0x24000019 },
+  { 0x0981d44e, 0x14000006 },
+  { 0x0981d456, 0x14000011 },
+  { 0x0981d468, 0x24000019 },
+  { 0x0981d482, 0x14000019 },
+  { 0x0901d49c, 0x24000000 },
+  { 0x0981d49e, 0x24000001 },
+  { 0x0901d4a2, 0x24000000 },
+  { 0x0981d4a5, 0x24000001 },
+  { 0x0981d4a9, 0x24000003 },
+  { 0x0981d4ae, 0x24000007 },
+  { 0x0981d4b6, 0x14000003 },
+  { 0x0901d4bb, 0x14000000 },
+  { 0x0981d4bd, 0x14000006 },
+  { 0x0981d4c5, 0x1400000a },
+  { 0x0981d4d0, 0x24000019 },
+  { 0x0981d4ea, 0x14000019 },
+  { 0x0981d504, 0x24000001 },
+  { 0x0981d507, 0x24000003 },
+  { 0x0981d50d, 0x24000007 },
+  { 0x0981d516, 0x24000006 },
+  { 0x0981d51e, 0x14000019 },
+  { 0x0981d538, 0x24000001 },
+  { 0x0981d53b, 0x24000003 },
+  { 0x0981d540, 0x24000004 },
+  { 0x0901d546, 0x24000000 },
+  { 0x0981d54a, 0x24000006 },
+  { 0x0981d552, 0x14000019 },
+  { 0x0981d56c, 0x24000019 },
+  { 0x0981d586, 0x14000019 },
+  { 0x0981d5a0, 0x24000019 },
+  { 0x0981d5ba, 0x14000019 },
+  { 0x0981d5d4, 0x24000019 },
+  { 0x0981d5ee, 0x14000019 },
+  { 0x0981d608, 0x24000019 },
+  { 0x0981d622, 0x14000019 },
+  { 0x0981d63c, 0x24000019 },
+  { 0x0981d656, 0x14000019 },
+  { 0x0981d670, 0x24000019 },
+  { 0x0981d68a, 0x1400001b },
+  { 0x0981d6a8, 0x24000018 },
+  { 0x0901d6c1, 0x64000000 },
+  { 0x0981d6c2, 0x14000018 },
+  { 0x0901d6db, 0x64000000 },
+  { 0x0981d6dc, 0x14000005 },
+  { 0x0981d6e2, 0x24000018 },
+  { 0x0901d6fb, 0x64000000 },
+  { 0x0981d6fc, 0x14000018 },
+  { 0x0901d715, 0x64000000 },
+  { 0x0981d716, 0x14000005 },
+  { 0x0981d71c, 0x24000018 },
+  { 0x0901d735, 0x64000000 },
+  { 0x0981d736, 0x14000018 },
+  { 0x0901d74f, 0x64000000 },
+  { 0x0981d750, 0x14000005 },
+  { 0x0981d756, 0x24000018 },
+  { 0x0901d76f, 0x64000000 },
+  { 0x0981d770, 0x14000018 },
+  { 0x0901d789, 0x64000000 },
+  { 0x0981d78a, 0x14000005 },
+  { 0x0981d790, 0x24000018 },
+  { 0x0901d7a9, 0x64000000 },
+  { 0x0981d7aa, 0x14000018 },
+  { 0x0901d7c3, 0x64000000 },
+  { 0x0981d7c4, 0x14000005 },
+  { 0x0981d7ce, 0x34000031 },
+  { 0x16820000, 0x1c00a6d6 },
+  { 0x1682f800, 0x1c00021d },
+  { 0x090e0001, 0x04000000 },
+  { 0x098e0020, 0x0400005f },
+  { 0x1b8e0100, 0x300000ef },
+  { 0x098f0000, 0x0c00fffd },
+  { 0x09900000, 0x0c00fffd },
+};
diff --git a/plugin/plugin.rc b/plugin/plugin.rc
index b16be34..e5b7231 100644
--- a/plugin/plugin.rc
+++ b/plugin/plugin.rc
@@ -16,7 +16,7 @@
 #undef APSTUDIO_READONLY_SYMBOLS
 
 /////////////////////////////////////////////////////////////////////////////
-// Chinese (Simplified, PRC) resources
+// (壬й) resources
 
 #if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)
 LANGUAGE LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED
@@ -114,12 +114,12 @@ BEGIN
     0
 END
 
-#endif    // Chinese (Simplified, PRC) resources
+#endif    // (壬й) resources
 /////////////////////////////////////////////////////////////////////////////
 
 
 /////////////////////////////////////////////////////////////////////////////
-// English (United States) resources
+// Ӣ() resources
 
 #if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
 LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
@@ -131,8 +131,8 @@ LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
 //
 
 VS_VERSION_INFO VERSIONINFO
- FILEVERSION 1,3,0,0
- PRODUCTVERSION 1,3,0,0
+ FILEVERSION 1,3,1,1
+ PRODUCTVERSION 1,3,1,1
  FILEFLAGSMASK 0x3fL
 #ifdef _DEBUG
  FILEFLAGS 0x1L
@@ -150,13 +150,13 @@ BEGIN
             VALUE "CompanyName", "fireie@fireie.org"
             VALUE "FileDescription", "Fire IE DLL"
             VALUE "FileExtents", "*"
-            VALUE "FileVersion", "1.3.0.0"
+            VALUE "FileVersion", "1.3.1.1"
             VALUE "InternalName", "npfireie.dll"
             VALUE "LegalCopyright", "Copyright (C) 2012 fireie.org"
             VALUE "MIMEType", "application/fireie"
             VALUE "OriginalFilename", "npfireie.dll"
             VALUE "ProductName", "Fire IE DLL"
-            VALUE "ProductVersion", "1.3.0.0"
+            VALUE "ProductVersion", "1.3.1.1"
         END
     END
     BLOCK "VarFileInfo"
@@ -165,7 +165,7 @@ BEGIN
     END
 END
 
-#endif    // English (United States) resources
+#endif    // Ӣ() resources
 /////////////////////////////////////////////////////////////////////////////
 
 
diff --git a/plugin/re/RegExp.cpp b/plugin/re/RegExp.cpp
new file mode 100644
index 0000000..ade96d6
--- /dev/null
+++ b/plugin/re/RegExp.cpp
@@ -0,0 +1,262 @@
+/*
+This file is part of Fire-IE.
+
+Fire-IE is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Fire-IE is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Fire-IE.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+// RegExp.cpp : regular expression matching engine implementation file
+//
+
+#include "StdAfx.h"
+
+#include "RegExp.h"
+#include "jscre\JSRegExp.h"
+#include "strutils.h"
+
+using namespace re;
+using namespace jscre;
+using namespace std;
+using namespace strutils;
+
+static void* (*jscre_malloc)(size_t size) = malloc;
+static void (*jscre_free)(void* address) = free;
+
+RegExp::RegExp()
+{
+	m_strFullPattern = L"//";
+	m_bCompiled = false;
+	m_re = NULL;
+	setAttributes();
+}
+
+RegExp::RegExp(const wstring& strFullPattern)
+{
+	m_strFullPattern = strFullPattern;
+	m_bCompiled = false;
+	m_re = NULL;
+	setAttributes();
+	compile();
+}
+
+RegExp::RegExp(const RegExp& other)
+{
+	m_strFullPattern = other.m_strFullPattern;
+	m_bIgnoreCase = other.m_bIgnoreCase;
+	m_bMultiLine = other.m_bMultiLine;
+	m_bGlobal = other.m_bGlobal;
+	m_nLastPos = other.m_nLastPos;
+
+	m_re = NULL;
+	m_bCompiled = false;
+	if (other.m_bCompiled)
+		compile();
+}
+
+RegExp& RegExp::operator=(const RegExp& other)
+{
+	if (this == &other) return *this;
+
+	if (m_re) jsRegExpFree(m_re, jscre_free);
+
+	m_strFullPattern = other.m_strFullPattern;
+	m_bIgnoreCase = other.m_bIgnoreCase;
+	m_bMultiLine = other.m_bMultiLine;
+	m_bGlobal = other.m_bGlobal;
+	m_nLastPos = other.m_nLastPos;
+
+	m_re = NULL;
+	m_bCompiled = false;
+	if (other.m_bCompiled)
+		compile();
+
+	return *this;
+}
+
+RegExp::~RegExp()
+{
+	if (m_re) jsRegExpFree(m_re, jscre_free);
+}
+
+void RegExp::compile()
+{
+	if (m_bCompiled) return;
+
+	JSRegExp* re = NULL;
+	m_nSubPatterns = 0;
+	const char* errorMessage = NULL;
+
+	wstring pattern = getPattern();
+	re = jsRegExpCompile((const UChar*)pattern.c_str(), (int)pattern.length(),
+		m_bIgnoreCase ? JSRegExpIgnoreCase : JSRegExpDoNotIgnoreCase,
+		m_bMultiLine ? JSRegExpMultiline : JSRegExpSingleLine,
+		&m_nSubPatterns, &errorMessage, jscre_malloc, jscre_free);
+
+	if (re)
+	{
+		if (m_re) // in case of a re-compile
+		{
+			jsRegExpFree(m_re, jscre_free);
+		}
+		m_re = re;
+		m_bCompiled = true;
+	}
+	else throw RegExpCompileError(errorMessage);
+}
+
+void RegExp::compile(const wstring& strFullPattern)
+{
+	m_strFullPattern = strFullPattern;
+	setAttributes();
+	m_bCompiled = false;
+	compile();
+}
+
+void RegExp::compile(const wstring& strFullPattern, const wstring& strAttributes)
+{
+	m_strFullPattern = strFullPattern;
+	setAttributes(strAttributes);
+	m_bCompiled = false;
+	compile();
+}
+
+RegExpMatch* RegExp::exec(const wstring& str)
+{
+	return exec(str, m_nLastPos);
+}
+
+RegExpMatch* RegExp::exec(const wstring& str, int lastPos)
+{
+	if (!m_bCompiled) compile();
+	RegExpMatch* match = execCore(str, lastPos);
+	if (m_bGlobal)
+	{
+		// should record last match position
+		if (match)
+		{
+			int advance = (int)match->substrings[0].length();
+			if (advance < 1) advance = 1;
+			m_nLastPos = match->index + advance;
+		}
+		else
+			m_nLastPos = 0;
+	}
+	return match;
+}
+
+RegExpMatch* RegExp::exec(const wstring& str) const
+{
+	return exec(str, m_nLastPos);
+}
+
+RegExpMatch* RegExp::exec(const wstring& str, int lastPos) const
+{
+	if (!m_bCompiled) throw RegExpCompileError("cannot compile in constant function");
+	return execCore(str, lastPos);
+}
+
+RegExpMatch* RegExp::execCore(const wstring& str, int lastPos) const
+{
+	int numBackRefs = (int)m_nSubPatterns;
+	int offsetLength = (numBackRefs + 1) * 3;
+	int* offsets = new int[offsetLength];
+
+	int ret;
+	do {
+		ret = jsRegExpExecute(m_re, (const UChar*)str.c_str(), (int)str.length(), lastPos, offsets, offsetLength);
+		if (ret < 0) // Error or no match
+		{
+			delete [] offsets;
+			return NULL;
+		}
+		if (ret == 0) // offsets overflow, re-allocate the array and run again
+		{
+			delete [] offsets;
+			offsetLength *= 2;
+			offsets = new int[offsetLength];
+		}
+	} while (ret == 0);
+
+	numBackRefs = ret - 1;
+
+	// Matches
+	RegExpMatch* match = new RegExpMatch();
+	match->index = offsets[0];
+	match->input = str;
+	match->substrings.reserve(m_nSubPatterns + 1);
+	match->substrings.push_back(str.substr(offsets[0], offsets[1] - offsets[0]));
+	for (int i = 1; i <= numBackRefs; i++)
+	{
+		int l = offsets[i * 2], r = offsets[i * 2 + 1];
+		if (l >= 0 && r >= l && r <= (int)str.length())
+			match->substrings.push_back(str.substr(l, r - l));
+		else match->substrings.push_back(L"");
+	}
+	for (int i = numBackRefs + 1; i <= (int)m_nSubPatterns; i++)
+	{
+		match->substrings.push_back(L"");
+	}
+	delete [] offsets;
+	return match;
+}
+
+bool RegExp::test(const wstring& str)
+{
+	if (!m_bCompiled) compile();
+	return testCore(str);
+}
+
+bool RegExp::test(const wstring& str) const
+{
+	if (!m_bCompiled) throw RegExpCompileError("cannot compile in constant function");
+	return testCore(str);
+}
+
+bool RegExp::testCore(const wstring& str) const
+{
+	return 0 <= jsRegExpExecute(m_re, (const UChar*)str.c_str(), (int)str.length(), 0, NULL, 0);
+}
+
+void RegExp::setAttributes()
+{
+	size_t idx = m_strFullPattern.rfind(L'/');
+	wstring strAttributes;
+	if (idx != wstring::npos)
+		strAttributes = m_strFullPattern.substr(idx + 1);
+	setAttributes(strAttributes);
+}
+
+void RegExp::setAttributes(const wstring& strAttributes)
+{
+	m_nLastPos = 0;
+	m_bIgnoreCase = false;
+	m_bMultiLine = false;
+	m_bGlobal = false;
+	for (size_t idx = 0; idx < strAttributes.length(); idx++)
+	{
+		wchar_t ch = strAttributes[idx];
+		if (ch == L'i') m_bIgnoreCase = true;
+		if (ch == L'm') m_bMultiLine = true;
+		if (ch == L'g') m_bGlobal = true;
+	}
+}
+
+wstring RegExp::getPattern() const
+{
+	if (!startsWithChar(m_strFullPattern, L'/'))
+		return m_strFullPattern;
+	size_t idxStart = 1;
+	size_t idxEnd = m_strFullPattern.rfind(L'/');
+	if (idxEnd == wstring::npos || idxEnd <= idxStart) return L"";
+	return m_strFullPattern.substr(idxStart, idxEnd - idxStart);
+}
diff --git a/plugin/re/RegExp.h b/plugin/re/RegExp.h
new file mode 100644
index 0000000..351cc7b
--- /dev/null
+++ b/plugin/re/RegExp.h
@@ -0,0 +1,99 @@
+/*
+This file is part of Fire-IE.
+
+Fire-IE is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Fire-IE is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Fire-IE.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// RegExp.h : regular expression matching engine
+//
+
+#include <string>
+#include <vector>
+#include <stdexcept>
+
+namespace jscre {
+	struct JSRegExp;
+}
+
+namespace re {
+
+struct RegExpMatch {
+	int index;
+	std::wstring input;
+	std::vector<std::wstring> substrings;
+};
+
+class RegExp {
+public:
+	RegExp();
+	RegExp(const std::wstring& strFullPattern);
+	RegExp(const RegExp&);
+	~RegExp();
+
+	RegExp& operator=(const RegExp&);
+
+	// Compiles the regular expression
+	void compile();
+	void compile(const std::wstring& strFullPattern);
+	void compile(const std::wstring& strFullPattern, const std::wstring& attributes);
+
+	bool isGlobal() const { return m_bGlobal; }
+	bool ifIgnoreCase() const { return m_bIgnoreCase; }
+	bool isMultiLine() const { return m_bMultiLine; }
+	int getLastIndex() const { return m_nLastPos; }
+	std::wstring getSource() const { return m_strFullPattern; }
+
+	// do regexp matching, caller is responsible to free RegExpMatch*
+	RegExpMatch* exec(const std::wstring& str);
+	RegExpMatch* exec(const std::wstring& str, int lastPos);
+	// should use const version in multi-threading environment
+	RegExpMatch* exec(const std::wstring& str) const; 
+	RegExpMatch* exec(const std::wstring& str, int lastPos) const;
+	// do regexp testing
+	bool test(const std::wstring& str);
+	bool test(const std::wstring& str) const; // should use const version in multi-threading environment
+private:
+	// the compiled regular expression
+	jscre::JSRegExp* m_re;
+
+	// pattern with attributes
+	std::wstring m_strFullPattern;
+	bool m_bIgnoreCase;
+	bool m_bMultiLine;
+	bool m_bGlobal;
+
+	// lazy compile
+	bool m_bCompiled;
+
+	// last position, for global RegExp's
+	int m_nLastPos;
+	// number of sub patterns, from compiled info
+	unsigned int m_nSubPatterns;
+private:
+	std::wstring getPattern() const;
+	void setAttributes();
+	void setAttributes(const std::wstring& strAttributes);
+
+	RegExpMatch* execCore(const std::wstring& str, int lastPos) const;
+	bool testCore(const std::wstring& str) const;
+};
+
+class RegExpCompileError : public std::runtime_error {
+public:
+	RegExpCompileError(const char* what) : std::runtime_error(what) {}
+};
+
+} // namespace re
diff --git a/plugin/re/strutils.cpp b/plugin/re/strutils.cpp
new file mode 100644
index 0000000..727e7a4
--- /dev/null
+++ b/plugin/re/strutils.cpp
@@ -0,0 +1,189 @@
+/*
+This file is part of Fire-IE.
+
+Fire-IE is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Fire-IE is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Fire-IE.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+// strutils.cpp : wstring utilities
+//
+
+#include "StdAfx.h"
+
+#include <ctype.h>
+#include "RegExp.h"
+
+using namespace std;
+
+namespace re { namespace strutils {
+
+// See https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_string_as_a_parameter
+// Some tricky test cases:
+// "abcdefghijklmn".replace(/(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)(n)/, "$001"): "$001"
+// "abcdefghijklmn".replace(/(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)(n)/, "$01"): "a"
+// "abcdefghijklmn".replace(/(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)(n)/, "$10"): "j"
+// "abcdefghijklmn".replace(/(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)(n)/, "$15"): "a5"
+// "abcdefghijklmn".replace(/(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)(n)/, "$20"): "b0"
+void insertReplacedString(wstring& builder, const wstring& base, const wstring& str, const RegExpMatch* match)
+{
+	const vector<wstring>& substrings = match->substrings;
+	const wstring& mstr = substrings[0];
+	for (size_t i = 0; i < str.length(); i++)
+	{
+		if (str[i] == L'$' && str.length() > i + 1)
+		{
+			wchar_t ch = str[++i];
+			switch (ch)
+			{
+			case L'$': // insert a '$'
+				builder.push_back(ch);
+				break;
+			case L'&': // insert the matched string
+				builder.append(mstr);
+				break;
+			case L'`': // insert the portion preceding the matched string
+				builder.append(base.begin(), base.begin() + match->index);
+				break;
+			case L'\'': // insert the portion following the matched string
+				builder.append(base.begin() + match->index + mstr.length(), base.end());
+				break;
+			default:
+				if (ch >= L'0' && ch <= L'9')
+				{
+					int expidx = 0;
+					wchar_t ch2 = str.length() > i + 1 ? str[i + 1] : L'\0';
+					if (ch2 >= L'0' && ch2 <= L'9')
+					{
+						expidx = ch2 - L'0' + 10 * (ch - L'0');
+						// if expidx overflows, fall back to single-digit
+						if (expidx == 0 || expidx >= (int)substrings.size())
+						{
+							expidx = ch - L'0';
+							ch2 = 0;
+						}
+					}
+					else
+					{
+						ch2 = 0;
+						expidx = ch - L'0';
+					}
+					// substrings.size() is 1 bigger than actual sub matches
+					if (expidx < (int)substrings.size() && expidx > 0)
+					{
+						const wstring& submstr = substrings[expidx];
+						builder.append(submstr);
+						if (ch2) ++i;
+						break;
+					}
+				}
+				// $ escape fails, output as is
+				builder.push_back(L'$');
+				builder.push_back(ch);
+			}
+		}
+		else builder.push_back(str[i]);
+	}
+}
+
+wstring replace(const wstring& base, const RegExp& re, const wstring& str)
+{
+	std::vector<RegExpMatch*> matches;
+	if (re.isGlobal())
+	{
+		RegExpMatch* match = re.exec(base, 0);
+		while (match)
+		{
+			matches.push_back(match);
+			int advance = (int)match->substrings[0].length();
+			if (advance < 1) advance = 1;
+			match = re.exec(base, match->index + advance);
+		}
+	}
+	else
+	{
+		RegExpMatch* match = re.exec(base);
+		if (match) matches.push_back(match);
+	}
+
+	// do the replace
+	wstring builder;
+	size_t lastPos = 0;
+	for (size_t i = 0; i < matches.size(); i++)
+	{
+		RegExpMatch* match = matches[i];
+		builder.append(base.begin() + lastPos, base.begin() + match->index);
+		insertReplacedString(builder, base, str, match);
+		lastPos = match->index + match->substrings[0].length();
+	}
+	builder.append(base.begin() + lastPos, base.end());
+
+	for (size_t i = 0; i < matches.size(); i++)
+	{
+		delete matches[i];
+	}
+	return builder;
+}
+
+vector<wstring> split(const wstring& base, const wstring& separator)
+{
+	if (!base.length()) return vector<wstring>();
+
+	std::vector<wstring> res;
+	size_t idx = 0;
+	while (true)
+	{
+		size_t pos = base.find(separator, idx);
+		if (pos == wstring::npos) break;
+		res.push_back(base.substr(idx, pos - idx));
+		idx = pos + separator.length();
+	}
+	res.push_back(base.substr(idx, base.length() - idx));
+	return res;
+}
+
+wstring toUpperCase(wstring str)
+{
+	if (str.length())
+		_wcsupr_s(&str[0], str.length() + 1);
+	return str;
+}
+
+wstring toLowerCase(wstring str)
+{
+	if (str.length())
+		_wcslwr_s(&str[0], str.length() + 1);
+	return str;
+}
+
+RegExpMatch* match(const wstring& base, const RegExp& re)
+{
+	if (!re.isGlobal()) return re.exec(base);
+
+	RegExpMatch* res = new RegExpMatch();
+	res->index = 0;
+
+	RegExpMatch* match = re.exec(base, 0);
+	while (match)
+	{
+		res->substrings.push_back(match->substrings[0]);
+		int advance = (int)match->substrings[0].length();
+		if (advance < 1) advance = 1;
+		int lastPos = match->index + advance;
+		delete match;
+		match = re.exec(base, lastPos);
+	}
+
+	return res;
+}
+
+} } // namespace re::strutils
diff --git a/plugin/re/strutils.h b/plugin/re/strutils.h
new file mode 100644
index 0000000..2a3a316
--- /dev/null
+++ b/plugin/re/strutils.h
@@ -0,0 +1,54 @@
+/*
+This file is part of Fire-IE.
+
+Fire-IE is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Fire-IE is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Fire-IE.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// strutils.h : wstring utilities
+//
+
+#include <string>
+#include <vector>
+
+namespace re {
+	class RegExp;
+	struct RegExpMatch;
+
+	namespace strutils {
+		inline bool startsWith(const std::wstring& base, const std::wstring& str)
+		{
+			return base.length() >= str.length() && base.substr(0, str.length()) == str;
+		}
+		inline bool endsWith(const std::wstring& base, const std::wstring& str)
+		{
+			return base.length() >= str.length() && base.substr(base.length() - str.length()) == str;
+		}
+		inline bool startsWithChar(const std::wstring& base, wchar_t ch)
+		{
+			return base.length() && base.front() == ch;
+		}
+		inline bool endsWithChar(const std::wstring& base, wchar_t ch)
+		{
+			return base.length() && base.back() == ch;
+		}
+
+		std::wstring replace(const std::wstring& base, const RegExp& re, const std::wstring& str);
+		std::vector<std::wstring> split(const std::wstring& base, const std::wstring& separator);
+		RegExpMatch* match(const std::wstring& base, const RegExp& re);
+		std::wstring toUpperCase(std::wstring str);
+		std::wstring toLowerCase(std::wstring str);
+	}
+}
diff --git a/plugin/regdom-libs/dkim-regdom.cpp b/plugin/regdom-libs/dkim-regdom.cpp
new file mode 100644
index 0000000..c0c16d6
--- /dev/null
+++ b/plugin/regdom-libs/dkim-regdom.cpp
@@ -0,0 +1,215 @@
+/*
+ * Calculate the effective registered domain of a fully qualified domain name.
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to you under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at:
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Florian Sager, 03.01.2009, sager@agitos.de
+ * Christian Heindl, 29.12.2008, heindlc@agitos.de
+ * Ward van Wanrooij, 04.04.2010, ward@ward.nu
+ *
+ */
+
+#include <cstdlib>
+#include <cstdio>
+#include <cstring>
+#include <algorithm>
+
+#include "dkim-regdom.h"
+
+using namespace std;
+
+namespace Utils { namespace regdom {
+
+extern int readTldString(tldnode*, const wchar_t*, int, int);
+extern const tldnode* findTldNode(const tldnode*, const wchar_t*, int len);
+
+wchar_t ALL[] = L"*";
+wchar_t THIS[] = L"!";
+
+// wchar_t* tldString = "root(3:ac(5:com,edu,gov,net,ad(3:nom,co!,*)),de,com)";
+
+// helper function to parse node in tldString
+int readTldString(tldnode* node, const wchar_t* s, int len, int pos) {
+
+	int start = pos;
+	int state = 0;
+
+	memset(node, 0, sizeof(tldnode));
+	do {
+		wchar_t c = *(s+pos);
+
+		switch(state) {
+			case 0: // general read
+
+				if (c==L',' || c==L')' || c==L'(') {
+					// add last domain
+					int count = node->attr == THIS ? pos - start : pos - start + 1;
+					node->dom = (wchar_t*) malloc(count * sizeof(wchar_t));
+					wcsncpy_s(node->dom, count, s+start, _TRUNCATE);
+
+					if (c==L'(') {
+						// read number of children
+						start = pos;
+						state = 1;
+					} else if (c==L')' || c==L',') {
+						// return to parent domains
+						return pos;
+					}
+
+				} else if (c==L'!') {
+					node->attr=THIS;
+				}
+
+				break;
+			case 1: // reading number of elements (<number>:
+
+				if (c==L':') {
+					int count = pos - start;
+					wchar_t* buf = (wchar_t*) malloc(count * sizeof(wchar_t));
+					wcsncpy_s(buf, count, s+start+1, _TRUNCATE);
+					node->num_children = wcstol(buf, NULL, 10);
+					free(buf);
+
+					// allocate space for children
+					node->subnodes = (tldnode**) malloc(node->num_children * sizeof(tldnode*));
+
+					int i;
+					for (i=0; i<node->num_children; i++) {
+						tldnode* subnode = (tldnode*)malloc(sizeof(tldnode));
+						pos = readTldString(subnode, s, len, pos + 1);
+						node->subnodes[i] = subnode;
+					}
+
+					// sort alphabetically for better search performance
+					sort(node->subnodes, node->subnodes + node->num_children,
+						[] (const tldnode* node1, const tldnode* node2) -> bool {
+							// asterisks always comes first
+							if (wcscmp(node1->dom, ALL) == 0) return true;
+							if (wcscmp(node2->dom, ALL) == 0) return false;
+							
+							return wcscmp(node1->dom, node2->dom) < 0;
+						}
+					);
+
+					return pos + 1;
+				}
+
+				break;
+		}
+
+		pos++;
+	} while (pos < len);
+
+	return pos;
+}
+
+// reads TLDs once at daemon startup
+const tldnode* readTldTree(const wchar_t* tlds) {
+	tldnode* root = (tldnode *)malloc(sizeof(tldnode));
+
+	readTldString(root, tlds, (int)wcslen(tlds), 0);
+
+	return root;
+}
+
+#ifdef DEBUG
+
+void printTldTree(const tldnode* node, const wchar_t * spacer) {
+	if (node->num_children != 0) {
+		// has children
+		wprintf(L"%ls%ls:\n", spacer, node->dom);
+
+		int i;
+		for(i = 0; i < node->num_children; i++) {
+			wchar_t dest[100];
+			swprintf(dest, L"  %ls", spacer);
+
+			printTldTree(node->subnodes[i], dest);
+		}
+	} else {
+		// no children
+		wprintf(L"%ls%ls: %ls\n", spacer, node->dom, node->attr);
+	}
+}
+
+#endif /* DEBUG */
+
+void freeTldTree(const tldnode* node) {
+
+	if (node->num_children != 0) {
+		int i;
+		for(i = 0; i < node->num_children; i++) {
+			freeTldTree(node->subnodes[i]);
+		}
+	}
+	free(node->dom);
+	free(const_cast<tldnode*>(node));
+}
+
+// binary search for domain (and * if available)
+const tldnode* findTldNode(const tldnode* parent, const wchar_t* subdom, int len) {
+	if (!parent->num_children) return NULL;
+
+	const tldnode* allNode = 
+		wcscmp(parent->subnodes[0]->dom, ALL) == 0 ? parent->subnodes[0] : NULL;
+
+	int l = allNode ? 1 : 0;
+	int h = parent->num_children;
+	while (l < h) {
+		int m = (l + h) / 2;
+		int cmp = wcsncmp(subdom, parent->subnodes[m]->dom, len);
+		if (cmp == 0 && !parent->subnodes[m]->dom[len])
+			return parent->subnodes[m];
+		if (cmp > 0)
+			l = m + 1;
+		else
+			h = m;
+	}
+	return allNode;
+}
+
+const wchar_t* getRegisteredDomain(const wchar_t* signingDomain, const tldnode* tree) {
+	// split domain by . separator, and find tld simutaneously
+	const wchar_t* sDbegin = signingDomain;
+	const wchar_t* sDend = signingDomain + wcslen(signingDomain);
+	reverse_iterator<const wchar_t*> sDrbegin(sDend);
+	reverse_iterator<const wchar_t*> sDrend(sDbegin);
+
+	reverse_iterator<const wchar_t*> next;
+	
+	const tldnode* subtree = tree;
+
+	while (sDrend != (next = find(sDrbegin, sDrend, L'.'))) {
+		const tldnode* subnode = 
+			findTldNode(subtree, next.base(), (int)(sDrbegin.base() - next.base()));
+		if (subnode == NULL || (subnode->num_children == 1 && subnode->subnodes[0]->attr == THIS))
+			return sDrbegin.base() != sDend ? next.base() : NULL;
+		subtree = subnode;
+		sDrbegin = next + 1;
+	}
+
+	if (sDrbegin.base() == sDend)
+		return NULL;
+
+	const tldnode* subnode = 
+		findTldNode(subtree, sDrend.base(), (int)(sDrbegin.base() - sDrend.base()));
+	if (subnode == NULL || (subnode->num_children == 1 && subnode->subnodes[0]->attr == THIS))
+		return sDrend.base();
+
+	return NULL;
+}
+
+} } // namespace Utils::regdom
diff --git a/plugin/regdom-libs/dkim-regdom.h b/plugin/regdom-libs/dkim-regdom.h
new file mode 100644
index 0000000..6203969
--- /dev/null
+++ b/plugin/regdom-libs/dkim-regdom.h
@@ -0,0 +1,48 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to you under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at:
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ *
+ * Christian Heindl, 29.12.2008, heindlc@agitos.de
+ * Florian Sager, 03.01.2009, sager@agitos.de
+ * Ward van Wanrooij, 04.04.2010, ward@ward.nu
+ *
+ */
+
+#pragma once
+
+namespace Utils { namespace regdom {
+
+/* DATA TYPES */
+struct tldnode_el {
+	wchar_t* dom;
+	wchar_t* attr;
+
+	int num_children;
+	struct tldnode_el** subnodes;
+};
+
+typedef struct tldnode_el tldnode;
+
+/* PROTOTYPES */
+extern const tldnode* readTldTree(const wchar_t*);
+extern const wchar_t* getRegisteredDomain(const wchar_t*, const tldnode*);
+extern void freeTldTree(const tldnode*);
+
+#ifdef DEBUG
+extern void printTldTree(const tldnode*, const wchar_t *);
+#endif /* DEBUG */
+
+} } // namespace Utils::regdom
diff --git a/plugin/regdom-libs/tld-canon.h b/plugin/regdom-libs/tld-canon.h
new file mode 100644
index 0000000..0d5af9d
--- /dev/null
+++ b/plugin/regdom-libs/tld-canon.h
@@ -0,0 +1,975 @@
+﻿// This Source Code Form is subject to the terms of the Mozilla Public
+// License, v. 2.0. If a copy of the MPL was not distributed with this
+// file, You can obtain one at http://mozilla.org/MPL/2.0/.
+// ===BEGIN ICANN DOMAINS===
+// ac : http://en.wikipedia.org/wiki/.ac
+// ad : http://en.wikipedia.org/wiki/.ad
+// ae : http://en.wikipedia.org/wiki/.ae
+// see also: "Domain Name Eligibility Policy" at http://www.aeda.ae/eng/aepolicy.php
+// aero : see http://www.information.aero/index.php?id=66
+// af : http://www.nic.af/help.jsp
+// ag : http://www.nic.ag/prices.htm
+// ai : http://nic.com.ai/
+// al : http://www.ert.gov.al/ert_alb/faq_det.html?Id=31
+// am : http://en.wikipedia.org/wiki/.am
+// an : http://www.una.an/an_domreg/default.asp
+// ao : http://en.wikipedia.org/wiki/.ao
+// http://www.dns.ao/REGISTR.DOC
+// aq : http://en.wikipedia.org/wiki/.aq
+// ar : http://en.wikipedia.org/wiki/.ar
+// arpa : http://en.wikipedia.org/wiki/.arpa
+// Confirmed by registry <iana-questions@icann.org> 2008-06-18
+// as : http://en.wikipedia.org/wiki/.as
+// asia : http://en.wikipedia.org/wiki/.asia
+// at : http://en.wikipedia.org/wiki/.at
+// Confirmed by registry <it@nic.at> 2008-06-17
+// au : http://en.wikipedia.org/wiki/.au
+// http://www.auda.org.au/
+// 2LDs
+// Historic 2LDs (closed to new registration, but sites still exist)
+// CGDNs - http://www.cgdn.org.au/
+// 3LDs
+// Removed at request of Shae.Donelan@services.nsw.gov.au, 2010-03-04
+// nsw.gov.au
+// aw : http://en.wikipedia.org/wiki/.aw
+// ax : http://en.wikipedia.org/wiki/.ax
+// az : http://en.wikipedia.org/wiki/.az
+// ba : http://en.wikipedia.org/wiki/.ba
+// bb : http://en.wikipedia.org/wiki/.bb
+// bd : http://en.wikipedia.org/wiki/.bd
+// be : http://en.wikipedia.org/wiki/.be
+// Confirmed by registry <tech@dns.be> 2008-06-08
+// bf : http://en.wikipedia.org/wiki/.bf
+// bg : http://en.wikipedia.org/wiki/.bg
+// https://www.register.bg/user/static/rules/en/index.html
+// bh : http://en.wikipedia.org/wiki/.bh
+// bi : http://en.wikipedia.org/wiki/.bi
+// http://whois.nic.bi/
+// biz : http://en.wikipedia.org/wiki/.biz
+// bj : http://en.wikipedia.org/wiki/.bj
+// bm : http://www.bermudanic.bm/dnr-text.txt
+// bn : http://en.wikipedia.org/wiki/.bn
+// bo : http://www.nic.bo/
+// br : http://registro.br/dominio/dpn.html
+// Updated by registry <fneves@registro.br> 2011-03-01
+// bs : http://www.nic.bs/rules.html
+// bt : http://en.wikipedia.org/wiki/.bt
+// bv : No registrations at this time.
+// Submitted by registry <jarle@uninett.no> 2006-06-16
+// bw : http://en.wikipedia.org/wiki/.bw
+// http://www.gobin.info/domainname/bw.doc
+// list of other 2nd level tlds ?
+// by : http://en.wikipedia.org/wiki/.by
+// http://tld.by/rules_2006_en.html
+// list of other 2nd level tlds ?
+// Official information does not indicate that com.by is a reserved
+// second-level domain, but it's being used as one (see www.google.com.by and
+// www.yahoo.com.by, for example), so we list it here for safety's sake.
+// http://hoster.by/
+// bz : http://en.wikipedia.org/wiki/.bz
+// http://www.belizenic.bz/
+// ca : http://en.wikipedia.org/wiki/.ca
+// ca geographical names
+// gc.ca: http://en.wikipedia.org/wiki/.gc.ca
+// see also: http://registry.gc.ca/en/SubdomainFAQ
+// cat : http://en.wikipedia.org/wiki/.cat
+// cc : http://en.wikipedia.org/wiki/.cc
+// cd : http://en.wikipedia.org/wiki/.cd
+// see also: https://www.nic.cd/domain/insertDomain_2.jsp?act=1
+// cf : http://en.wikipedia.org/wiki/.cf
+// cg : http://en.wikipedia.org/wiki/.cg
+// ch : http://en.wikipedia.org/wiki/.ch
+// ci : http://en.wikipedia.org/wiki/.ci
+// http://www.nic.ci/index.php?page=charte
+// ck : http://en.wikipedia.org/wiki/.ck
+// cl : http://en.wikipedia.org/wiki/.cl
+// cm : http://en.wikipedia.org/wiki/.cm
+// cn : http://en.wikipedia.org/wiki/.cn
+// Submitted by registry <tanyaling@cnnic.cn> 2008-06-11
+// cn geographic names
+// co : http://en.wikipedia.org/wiki/.co
+// Submitted by registry <tecnico@uniandes.edu.co> 2008-06-11
+// com : http://en.wikipedia.org/wiki/.com
+// coop : http://en.wikipedia.org/wiki/.coop
+// cr : http://www.nic.cr/niccr_publico/showRegistroDominiosScreen.do
+// cu : http://en.wikipedia.org/wiki/.cu
+// cv : http://en.wikipedia.org/wiki/.cv
+// cx : http://en.wikipedia.org/wiki/.cx
+// list of other 2nd level tlds ?
+// cy : http://en.wikipedia.org/wiki/.cy
+// cz : http://en.wikipedia.org/wiki/.cz
+// de : http://en.wikipedia.org/wiki/.de
+// Confirmed by registry <ops@denic.de> (with technical
+// reservations) 2008-07-01
+// dj : http://en.wikipedia.org/wiki/.dj
+// dk : http://en.wikipedia.org/wiki/.dk
+// Confirmed by registry <robert@dk-hostmaster.dk> 2008-06-17
+// dm : http://en.wikipedia.org/wiki/.dm
+// do : http://en.wikipedia.org/wiki/.do
+// dz : http://en.wikipedia.org/wiki/.dz
+// ec : http://www.nic.ec/reg/paso1.asp
+// Submitted by registry <vabboud@nic.ec> 2008-07-04
+// edu : http://en.wikipedia.org/wiki/.edu
+// ee : http://www.eenet.ee/EENet/dom_reeglid.html#lisa_B
+// eg : http://en.wikipedia.org/wiki/.eg
+// er : http://en.wikipedia.org/wiki/.er
+// es : https://www.nic.es/site_ingles/ingles/dominios/index.html
+// et : http://en.wikipedia.org/wiki/.et
+// eu : http://en.wikipedia.org/wiki/.eu
+// fi : http://en.wikipedia.org/wiki/.fi
+// aland.fi : http://en.wikipedia.org/wiki/.ax
+// This domain is being phased out in favor of .ax. As there are still many
+// domains under aland.fi, we still keep it on the list until aland.fi is
+// completely removed.
+// TODO: Check for updates (expected to be phased out around Q1/2009)
+// fj : http://en.wikipedia.org/wiki/.fj
+// fk : http://en.wikipedia.org/wiki/.fk
+// fm : http://en.wikipedia.org/wiki/.fm
+// fo : http://en.wikipedia.org/wiki/.fo
+// fr : http://www.afnic.fr/
+// domaines descriptifs : http://www.afnic.fr/obtenir/chartes/nommage-fr/annexe-descriptifs
+// domaines sectoriels : http://www.afnic.fr/obtenir/chartes/nommage-fr/annexe-sectoriels
+// ga : http://en.wikipedia.org/wiki/.ga
+// gb : This registry is effectively dormant
+// Submitted by registry <Damien.Shaw@ja.net> 2008-06-12
+// gd : http://en.wikipedia.org/wiki/.gd
+// ge : http://www.nic.net.ge/policy_en.pdf
+// gf : http://en.wikipedia.org/wiki/.gf
+// gg : http://www.channelisles.net/applic/avextn.shtml
+// gh : http://en.wikipedia.org/wiki/.gh
+// see also: http://www.nic.gh/reg_now.php
+// Although domains directly at second level are not possible at the moment,
+// they have been possible for some time and may come back.
+// gi : http://www.nic.gi/rules.html
+// gl : http://en.wikipedia.org/wiki/.gl
+// http://nic.gl
+// gm : http://www.nic.gm/htmlpages%5Cgm-policy.htm
+// gn : http://psg.com/dns/gn/gn.txt
+// Submitted by registry <randy@psg.com> 2008-06-17
+// gov : http://en.wikipedia.org/wiki/.gov
+// gp : http://www.nic.gp/index.php?lang=en
+// gq : http://en.wikipedia.org/wiki/.gq
+// gr : https://grweb.ics.forth.gr/english/1617-B-2005.html
+// Submitted by registry <segred@ics.forth.gr> 2008-06-09
+// gs : http://en.wikipedia.org/wiki/.gs
+// gt : http://www.gt/politicas.html
+// gu : http://gadao.gov.gu/registration.txt
+// gw : http://en.wikipedia.org/wiki/.gw
+// gy : http://en.wikipedia.org/wiki/.gy
+// http://registry.gy/
+// hk : https://www.hkdnr.hk
+// Submitted by registry <hk.tech@hkirc.hk> 2008-06-11
+// hm : http://en.wikipedia.org/wiki/.hm
+// hn : http://www.nic.hn/politicas/ps02,,05.html
+// hr : http://www.dns.hr/documents/pdf/HRTLD-regulations.pdf
+// ht : http://www.nic.ht/info/charte.cfm
+// hu : http://www.domain.hu/domain/English/sld.html
+// Confirmed by registry <pasztor@iszt.hu> 2008-06-12
+// id : http://en.wikipedia.org/wiki/.id
+// see also: https://register.pandi.or.id/
+// ie : http://en.wikipedia.org/wiki/.ie
+// il : http://en.wikipedia.org/wiki/.il
+// im : https://www.nic.im/pdfs/imfaqs.pdf
+// in : http://en.wikipedia.org/wiki/.in
+// see also: http://www.inregistry.in/policies/
+// Please note, that nic.in is not an offical eTLD, but used by most
+// government institutions.
+// info : http://en.wikipedia.org/wiki/.info
+// int : http://en.wikipedia.org/wiki/.int
+// Confirmed by registry <iana-questions@icann.org> 2008-06-18
+// io : http://www.nic.io/rules.html
+// list of other 2nd level tlds ?
+// iq : http://www.cmc.iq/english/iq/iqregister1.htm
+// ir : http://www.nic.ir/Terms_and_Conditions_ir,_Appendix_1_Domain_Rules
+// Also see http://www.nic.ir/Internationalized_Domain_Names
+// Two <iran>.ir entries added at request of <tech-team@nic.ir>, 2010-04-16
+// xn--mgba3a4f16a.ir (<iran>.ir, Persian YEH)
+// xn--mgba3a4fra.ir (<iran>.ir, Arabic YEH)
+// is : http://www.isnic.is/domain/rules.php
+// Confirmed by registry <marius@isgate.is> 2008-12-06
+// it : http://en.wikipedia.org/wiki/.it
+// list of reserved geo-names : 
+// http://www.nic.it/documenti/regolamenti-e-linee-guida/regolamento-assegnazione-versione-6.0.pdf
+// (There is also a list of reserved geo-names corresponding to Italian 
+// municipalities : http://www.nic.it/documenti/appendice-c.pdf , but it is
+// not included here.)
+// je : http://www.channelisles.net/applic/avextn.shtml
+// jm : http://www.com.jm/register.html
+// jo : http://www.dns.jo/Registration_policy.aspx
+// jobs : http://en.wikipedia.org/wiki/.jobs
+// jp : http://en.wikipedia.org/wiki/.jp
+// http://jprs.co.jp/en/jpdomain.html
+// Updated by registry <info@jprs.jp> 2012-05-28
+// jp organizational type names
+// jp preficture type names
+// jp geographic type names
+// http://jprs.jp/doc/rule/saisoku-1.html
+// 4th level registration
+// ke : http://www.kenic.or.ke/index.php?option=com_content&task=view&id=117&Itemid=145
+// kg : http://www.domain.kg/dmn_n.html
+// kh : http://www.mptc.gov.kh/dns_registration.htm
+// ki : http://www.ki/dns/index.html
+// km : http://en.wikipedia.org/wiki/.km
+// http://www.domaine.km/documents/charte.doc
+// These are only mentioned as proposed suggestions at domaine.km, but
+// http://en.wikipedia.org/wiki/.km says they're available for registration:
+// kn : http://en.wikipedia.org/wiki/.kn
+// http://www.dot.kn/domainRules.html
+// kp : http://www.kcce.kp/en_index.php
+// kr : http://en.wikipedia.org/wiki/.kr
+// see also: http://domain.nida.or.kr/eng/registration.jsp
+// kr geographical names
+// kw : http://en.wikipedia.org/wiki/.kw
+// ky : http://www.icta.ky/da_ky_reg_dom.php
+// Confirmed by registry <kysupport@perimeterusa.com> 2008-06-17
+// kz : http://en.wikipedia.org/wiki/.kz
+// see also: http://www.nic.kz/rules/index.jsp
+// la : http://en.wikipedia.org/wiki/.la
+// Submitted by registry <gavin.brown@nic.la> 2008-06-10
+// lb : http://en.wikipedia.org/wiki/.lb
+// Submitted by registry <randy@psg.com> 2008-06-17
+// lc : http://en.wikipedia.org/wiki/.lc
+// see also: http://www.nic.lc/rules.htm
+// li : http://en.wikipedia.org/wiki/.li
+// lk : http://www.nic.lk/seclevpr.html
+// lr : http://psg.com/dns/lr/lr.txt
+// Submitted by registry <randy@psg.com> 2008-06-17
+// ls : http://en.wikipedia.org/wiki/.ls
+// lt : http://en.wikipedia.org/wiki/.lt
+// gov.lt : http://www.gov.lt/index_en.php
+// lu : http://www.dns.lu/en/
+// lv : http://www.nic.lv/DNS/En/generic.php
+// ly : http://www.nic.ly/regulations.php
+// ma : http://en.wikipedia.org/wiki/.ma
+// http://www.anrt.ma/fr/admin/download/upload/file_fr782.pdf
+// mc : http://www.nic.mc/
+// md : http://en.wikipedia.org/wiki/.md
+// me : http://en.wikipedia.org/wiki/.me
+// mg : http://www.nic.mg/tarif.htm
+// mh : http://en.wikipedia.org/wiki/.mh
+// mil : http://en.wikipedia.org/wiki/.mil
+// mk : http://en.wikipedia.org/wiki/.mk
+// see also: http://dns.marnet.net.mk/postapka.php
+// ml : http://www.gobin.info/domainname/ml-template.doc
+// see also: http://en.wikipedia.org/wiki/.ml
+// mm : http://en.wikipedia.org/wiki/.mm
+// mn : http://en.wikipedia.org/wiki/.mn
+// mo : http://www.monic.net.mo/
+// mobi : http://en.wikipedia.org/wiki/.mobi
+// mp : http://www.dot.mp/
+// Confirmed by registry <dcamacho@saipan.com> 2008-06-17
+// mq : http://en.wikipedia.org/wiki/.mq
+// mr : http://en.wikipedia.org/wiki/.mr
+// ms : http://en.wikipedia.org/wiki/.ms
+// mt : https://www.nic.org.mt/dotmt/
+// mu : http://en.wikipedia.org/wiki/.mu
+// museum : http://about.museum/naming/
+// http://index.museum/
+// mv : http://en.wikipedia.org/wiki/.mv
+// "mv" included because, contra Wikipedia, google.mv exists.
+// mw : http://www.registrar.mw/
+// mx : http://www.nic.mx/
+// Submitted by registry <farias@nic.mx> 2008-06-19
+// my : http://www.mynic.net.my/
+// mz : http://www.gobin.info/domainname/mz-template.doc
+// na : http://www.na-nic.com.na/
+// http://www.info.na/domain/
+// name : has 2nd-level tlds, but there's no list of them
+// nc : http://www.cctld.nc/
+// ne : http://en.wikipedia.org/wiki/.ne
+// net : http://en.wikipedia.org/wiki/.net
+// nf : http://en.wikipedia.org/wiki/.nf
+// ng : http://psg.com/dns/ng/
+// Submitted by registry <randy@psg.com> 2008-06-17
+// ni : http://www.nic.ni/dominios.htm
+// nl : http://www.domain-registry.nl/ace.php/c,728,122,,,,Home.html
+// Confirmed by registry <Antoin.Verschuren@sidn.nl> (with technical
+// reservations) 2008-06-08
+// BV.nl will be a registry for dutch BV's (besloten vennootschap)
+// no : http://www.norid.no/regelverk/index.en.html
+// The Norwegian registry has declined to notify us of updates. The web pages
+// referenced below are the official source of the data. There is also an
+// announce mailing list: 
+// https://postlister.uninett.no/sympa/info/norid-diskusjon
+// Norid generic domains : http://www.norid.no/regelverk/vedlegg-c.en.html
+// Non-Norid generic domains : http://www.norid.no/regelverk/vedlegg-d.en.html
+// no geographical names : http://www.norid.no/regelverk/vedlegg-b.en.html
+// counties
+// primary and lower secondary schools per county
+// cities
+// communities
+// np : http://www.mos.com.np/register.html
+// nr : http://cenpac.net.nr/dns/index.html
+// Confirmed by registry <technician@cenpac.net.nr> 2008-06-17
+// nu : http://en.wikipedia.org/wiki/.nu
+// nz : http://en.wikipedia.org/wiki/.nz
+// om : http://en.wikipedia.org/wiki/.om
+// org : http://en.wikipedia.org/wiki/.org
+// pa : http://www.nic.pa/
+// Some additional second level "domains" resolve directly as hostnames, such as
+// pannet.pa, so we add a rule for "pa".
+// pe : https://www.nic.pe/InformeFinalComision.pdf
+// pf : http://www.gobin.info/domainname/formulaire-pf.pdf
+// pg : http://en.wikipedia.org/wiki/.pg
+// ph : http://www.domains.ph/FAQ2.asp
+// Submitted by registry <jed@email.com.ph> 2008-06-13
+// pk : http://pk5.pknic.net.pk/pk5/msgNamepk.PK
+// pl : http://www.dns.pl/english/
+// NASK functional domains (nask.pl / dns.pl) : http://www.dns.pl/english/dns-funk.html
+// ICM functional domains (icm.edu.pl)
+// Government domains (administred by ippt.gov.pl)
+// other functional domains
+// NASK geographical domains : http://www.dns.pl/english/dns-regiony.html
+// TASK geographical domains (www.task.gda.pl/uslugi/dns)
+// other geographical domains
+// pm : http://www.afnic.fr/medias/documents/AFNIC-naming-policy2012.pdf
+// pn : http://www.government.pn/PnRegistry/policies.htm
+// pr : http://www.nic.pr/index.asp?f=1
+// these aren't mentioned on nic.pr, but on http://en.wikipedia.org/wiki/.pr
+// pro : http://www.nic.pro/support_faq.htm
+// ps : http://en.wikipedia.org/wiki/.ps
+// http://www.nic.ps/registration/policy.html#reg
+// pt : http://online.dns.pt/dns/start_dns
+// pw : http://en.wikipedia.org/wiki/.pw
+// py : http://www.nic.py/faq_a.html#faq_b
+// qa : http://domains.qa/en/
+// re : http://www.afnic.re/obtenir/chartes/nommage-re/annexe-descriptifs
+// ro : http://www.rotld.ro/
+// rs : http://en.wikipedia.org/wiki/.rs
+// ru : http://www.cctld.ru/ru/docs/aktiv_8.php
+// Industry domains
+// Geographical domains
+// More geographical domains
+// State domains
+// Technical domains
+// rw : http://www.nic.rw/cgi-bin/policy.pl
+// sa : http://www.nic.net.sa/
+// sb : http://www.sbnic.net.sb/
+// Submitted by registry <lee.humphries@telekom.com.sb> 2008-06-08
+// sc : http://www.nic.sc/
+// sd : http://www.isoc.sd/sudanic.isoc.sd/billing_pricing.htm
+// Submitted by registry <admin@isoc.sd> 2008-06-17
+// se : http://en.wikipedia.org/wiki/.se
+// Submitted by registry <Patrik.Wallstrom@iis.se> 2008-06-24
+// sg : http://www.nic.net.sg/page/registration-policies-procedures-and-guidelines
+// sh : http://www.nic.sh/registrar.html
+// si : http://en.wikipedia.org/wiki/.si
+// sj : No registrations at this time.
+// Submitted by registry <jarle@uninett.no> 2008-06-16
+// sk : http://en.wikipedia.org/wiki/.sk
+// list of 2nd level domains ?
+// sl : http://www.nic.sl
+// Submitted by registry <adam@neoip.com> 2008-06-12
+// sm : http://en.wikipedia.org/wiki/.sm
+// sn : http://en.wikipedia.org/wiki/.sn
+// so : http://www.soregistry.com/
+// sr : http://en.wikipedia.org/wiki/.sr
+// st : http://www.nic.st/html/policyrules/
+// su : http://en.wikipedia.org/wiki/.su
+// sv : http://www.svnet.org.sv/svpolicy.html
+// sx : http://en.wikipedia.org/wiki/.sx
+// Confirmed by registry <jcvignes@openregistry.com> 2012-05-31
+// sy : http://en.wikipedia.org/wiki/.sy
+// see also: http://www.gobin.info/domainname/sy.doc
+// sz : http://en.wikipedia.org/wiki/.sz
+// http://www.sispa.org.sz/
+// tc : http://en.wikipedia.org/wiki/.tc
+// td : http://en.wikipedia.org/wiki/.td
+// tel: http://en.wikipedia.org/wiki/.tel
+// http://www.telnic.org/
+// tf : http://en.wikipedia.org/wiki/.tf
+// tg : http://en.wikipedia.org/wiki/.tg
+// http://www.nic.tg/
+// th : http://en.wikipedia.org/wiki/.th
+// Submitted by registry <krit@thains.co.th> 2008-06-17
+// tj : http://www.nic.tj/policy.html
+// tk : http://en.wikipedia.org/wiki/.tk
+// tl : http://en.wikipedia.org/wiki/.tl
+// tm : http://www.nic.tm/local.html
+// tn : http://en.wikipedia.org/wiki/.tn
+// http://whois.ati.tn/
+// to : http://en.wikipedia.org/wiki/.to
+// Submitted by registry <egullich@colo.to> 2008-06-17
+// tr : http://en.wikipedia.org/wiki/.tr
+// Used by government in the TRNC
+// http://en.wikipedia.org/wiki/.nc.tr
+// travel : http://en.wikipedia.org/wiki/.travel
+// tt : http://www.nic.tt/
+// tv : http://en.wikipedia.org/wiki/.tv
+// Not listing any 2LDs as reserved since none seem to exist in practice,
+// Wikipedia notwithstanding.
+// tw : http://en.wikipedia.org/wiki/.tw
+// tz : http://en.wikipedia.org/wiki/.tz
+// Submitted by registry <randy@psg.com> 2008-06-17
+// Updated from http://www.tznic.or.tz/index.php/domains.html 2010-10-25
+// ua : https://hostmaster.ua/policy/?ua
+// Submitted by registry <dk@cctld.ua> 2012-04-27
+// ua 2LD
+// ua geographic names
+// https://hostmaster.ua/2ld/
+// Private registries in .ua
+// ug : https://www.registry.co.ug/
+// uk : http://en.wikipedia.org/wiki/.uk
+// us : http://en.wikipedia.org/wiki/.us
+// us geographic names
+// The registrar notes several more specific domains available in each state,
+// such as state.*.us, dst.*.us, etc., but resolution of these is somewhat
+// haphazard; in some states these domains resolve as addresses, while in others
+// only subdomains are available, or even nothing at all. We include the
+// most common ones where it's clear that different sites are different
+// entities.
+// k12.hi.us  Hawaii has a state-wide DOE login: bug 614565
+// k12.ma.us contains school districts in Massachusetts. The 4LDs are 
+//  managed indepedently except for private (PVT), charter (CHTR) and
+//  parochial (PAROCH) schools.  Those are delegated dorectly to the 
+//  5LD operators.   <k12-ma-hostmaster _ at _ rsuc.gweep.net>
+// uy : http://www.nic.org.uy/
+// uz : http://www.reg.uz/
+// va : http://en.wikipedia.org/wiki/.va
+// vc : http://en.wikipedia.org/wiki/.vc
+// Submitted by registry <kshah@ca.afilias.info> 2008-06-13
+// ve : http://registro.nic.ve/nicve/registro/index.html
+// vg : http://en.wikipedia.org/wiki/.vg
+// vi : http://www.nic.vi/newdomainform.htm
+// http://www.nic.vi/Domain_Rules/body_domain_rules.html indicates some other
+// TLDs are "reserved", such as edu.vi and gov.vi, but doesn't actually say they
+// are available for registration (which they do not seem to be).
+// vn : https://www.dot.vn/vnnic/vnnic/domainregistration.jsp
+// vu : http://en.wikipedia.org/wiki/.vu
+// list of 2nd level tlds ?
+// wf : http://www.afnic.fr/medias/documents/AFNIC-naming-policy2012.pdf
+// ws : http://en.wikipedia.org/wiki/.ws
+// http://samoanic.ws/index.dhtml
+// yt : http://www.afnic.fr/medias/documents/AFNIC-naming-policy2012.pdf
+// IDN ccTLDs
+// Please sort by ISO 3166 ccTLD, then punicode string
+// when submitting patches and follow this format:
+// <Punicode> ("<english word>" <language>) : <ISO 3166 ccTLD>
+// [optional sponsoring org]
+// <URL>
+// xn--mgbaam7a8h ("Emerat" Arabic) : AE
+// http://nic.ae/english/arabicdomain/rules.jsp
+// xn--54b7fta0cc ("Bangla" Bangla) : BD  
+// xn--fiqs8s ("China" Chinese-Han-Simplified <.Zhonggou>) : CN 
+// CNNIC
+// http://cnnic.cn/html/Dir/2005/10/11/3218.htm
+// xn--fiqz9s ("China" Chinese-Han-Traditional <.Zhonggou>) : CN
+// CNNIC
+// http://cnnic.cn/html/Dir/2005/10/11/3218.htm
+// xn--lgbbat1ad8j ("Algeria / Al Jazair" Arabic) : DZ  
+// xn--wgbh1c ("Egypt" Arabic .masr) : EG
+// http://www.dotmasr.eg/
+// xn--node ("ge" Georgian (Mkhedruli)) : GE  
+// xn--j6w193g ("Hong Kong" Chinese-Han) : HK
+// https://www2.hkirc.hk/register/rules.jsp
+// xn--h2brj9c ("Bharat" Devanagari) : IN  
+// India
+// xn--mgbbh1a71e ("Bharat" Arabic) : IN  
+// India
+// xn--fpcrj9c3d ("Bharat" Telugu) : IN  
+// India
+// xn--gecrj9c ("Bharat" Gujarati) : IN  
+// India
+// xn--s9brj9c ("Bharat" Gurmukhi) : IN  
+// India
+// xn--45brj9c ("Bharat" Bengali) : IN  
+// India
+// xn--xkc2dl3a5ee0h ("India" Tamil) : IN  
+// India
+// xn--mgba3a4f16a ("Iran" Persian) : IR  
+// xn--mgba3a4fra ("Iran" Arabic) : IR  
+// xn--mgbayh7gpa ("al-Ordon" Arabic) : JO
+// National Information Technology Center (NITC) 
+// Royal Scientific Society, Al-Jubeiha
+// xn--3e0b707e ("Republic of Korea" Hangul) : KR  
+// xn--fzc2c9e2c ("Lanka" Sinhalese-Sinhala) : LK
+// http://nic.lk
+// xn--xkc2al3hye2a ("Ilangai" Tamil) : LK
+// http://nic.lk
+// xn--mgbc0a9azcg ("Morocco / al-Maghrib" Arabic) : MA  
+// xn--mgb9awbf ("Oman" Arabic) : OM  
+// xn--ygbi2ammx ("Falasteen" Arabic) : PS
+// The Palestinian National Internet Naming Authority (PNINA)
+// http://www.pnina.ps
+// xn--90a3ac ("srb" Cyrillic) : RS  
+// xn--p1ai ("rf" Russian-Cyrillic) : RU
+// http://www.cctld.ru/en/docs/rulesrf.php
+// xn--wgbl6a ("Qatar" Arabic) : QA
+// http://www.ict.gov.qa/
+// xn--mgberp4a5d4ar ("AlSaudiah" Arabic) : SA
+// http://www.nic.net.sa/
+// xn--mgberp4a5d4a87g ("AlSaudiah" Arabic) variant : SA  
+// xn--mgbqly7c0a67fbc ("AlSaudiah" Arabic) variant : SA  
+// xn--mgbqly7cvafr ("AlSaudiah" Arabic) variant : SA  
+// xn--ogbpf8fl ("Syria" Arabic) : SY  
+// xn--mgbtf8fl ("Syria" Arabic) variant : SY  
+// xn--yfro4i67o Singapore ("Singapore" Chinese-Han) : SG
+// xn--clchc0ea0b2g2a9gcd ("Singapore" Tamil) : SG
+// xn--o3cw4h ("Thai" Thai) : TH
+// http://www.thnic.co.th
+// xn--pgbs0dh ("Tunis") : TN
+// http://nic.tn
+// xn--kpry57d ("Taiwan" Chinese-Han-Traditional) : TW
+// http://www.twnic.net/english/dn/dn_07a.htm
+// xn--kprw13d ("Taiwan" Chinese-Han-Simplified) : TW
+// http://www.twnic.net/english/dn/dn_07a.htm
+// xn--nnx388a ("Taiwan") variant : TW  
+// xn--j1amh ("ukr" Cyrillic) : UA  
+// xn--mgb2ddes ("AlYemen" Arabic) : YE  
+// xxx : http://icmregistry.com
+// ye : http://www.y.net.ye/services/domain_name.htm
+// za : http://www.zadna.org.za/slds.html
+// zm : http://en.wikipedia.org/wiki/.zm
+// zw : http://en.wikipedia.org/wiki/.zw
+// ===END ICANN DOMAINS===
+// ===BEGIN PRIVATE DOMAINS===
+// info.at : http://www.info.at/
+// priv.at : http://www.nic.priv.at/
+// Submitted by registry <lendl@nic.at> 2008-06-09
+// co.ca : http://registry.co.ca
+// CentralNic : http://www.centralnic.com/names/domains
+// Confirmed by registry <gavin.brown@centralnic.com> 2011-09-27
+// Opera Software, A.S.A.
+// Requested by Yngve Pettersen <yngve@opera.com> 2009-11-26
+// Google, Inc.
+// Requested by Eduardo Vela <evn@google.com> 2010-09-06
+// iki.fi : Submitted by Hannu Aronsson <haa@iki.fi> 2009-11-05
+// c.la : http://www.c.la/
+// ZaNiC : http://www.za.net/
+// Confirmed by registry <hostmaster@nic.za.net> 2009-10-03
+// CoDNS B.V.
+// Added 2010-05-23.
+// Mainseek Sp. z o.o. : http://www.co.pl/
+// DynDNS.com : http://www.dyndns.com/services/dns/dyndns/
+// ===END PRIVATE DOMAINS===
+
+// Generated using Firefox scratchpad (see tldStringGen.scratchpad.js)
+// Visual Studio doesn't support strings larger than 64Kbytes or
+// single string literal larger than 2Kbytes
+wchar_t tldString[] = {
+	L'r',L'o',L'o',L't',L'(',L'3',L'0',L'8',L':',L'a',L'c',L'(',L'6',L':',L'c',L'o',L'm',L',',L'e',L'd',L'u',L',',L'g',L'o',L'v',L',',L'n',L'e',L't',L',',L'm',L'i',L'l',L',',L'o',L'r',L'g',L')',L',',L'a',L'd',L'(',L'1',L':',L'n',L'o',L'm',L')',L',',L'a',L'e',L'(',L'7',L':',L'c',L'o',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L',',L's',L'c',L'h',L',',L'a',L'c',L',',L'g',L'o',L'v',L',',L'm',L'i',L'l',L')',L',',L'a',L'e',L'r',L'o',L'(',L'8',L'9',L':',L'a',L'c',L'c',L'i',L'd',L'e',L'n',L't',L'-',L'i',L'n',
+	L'v',L'e',L's',L't',L'i',L'g',L'a',L't',L'i',L'o',L'n',L',',L'a',L'c',L'c',L'i',L'd',L'e',L'n',L't',L'-',L'p',L'r',L'e',L'v',L'e',L'n',L't',L'i',L'o',L'n',L',',L'a',L'e',L'r',L'o',L'b',L'a',L't',L'i',L'c',L',',L'a',L'e',L'r',L'o',L'c',L'l',L'u',L'b',L',',L'a',L'e',L'r',L'o',L'd',L'r',L'o',L'm',L'e',L',',L'a',L'g',L'e',L'n',L't',L's',L',',L'a',L'i',L'r',L'c',L'r',L'a',L'f',L't',L',',L'a',L'i',L'r',L'l',L'i',L'n',L'e',L',',L'a',L'i',L'r',L'p',L'o',L'r',L't',L',',L'a',L'i',L'r',L'-',L's',L'u',L'r',
+	L'v',L'e',L'i',L'l',L'l',L'a',L'n',L'c',L'e',L',',L'a',L'i',L'r',L't',L'r',L'a',L'f',L'f',L'i',L'c',L',',L'a',L'i',L'r',L'-',L't',L'r',L'a',L'f',L'f',L'i',L'c',L'-',L'c',L'o',L'n',L't',L'r',L'o',L'l',L',',L'a',L'm',L'b',L'u',L'l',L'a',L'n',L'c',L'e',L',',L'a',L'm',L'u',L's',L'e',L'm',L'e',L'n',L't',L',',L'a',L's',L's',L'o',L'c',L'i',L'a',L't',L'i',L'o',L'n',L',',L'a',L'u',L't',L'h',L'o',L'r',L',',L'b',L'a',L'l',L'l',L'o',L'o',L'n',L'i',L'n',L'g',L',',L'b',L'r',L'o',L'k',L'e',L'r',L',',L'c',L'a',
+	L'a',L',',L'c',L'a',L'r',L'g',L'o',L',',L'c',L'a',L't',L'e',L'r',L'i',L'n',L'g',L',',L'c',L'e',L'r',L't',L'i',L'f',L'i',L'c',L'a',L't',L'i',L'o',L'n',L',',L'c',L'h',L'a',L'm',L'p',L'i',L'o',L'n',L's',L'h',L'i',L'p',L',',L'c',L'h',L'a',L'r',L't',L'e',L'r',L',',L'c',L'i',L'v',L'i',L'l',L'a',L'v',L'i',L'a',L't',L'i',L'o',L'n',L',',L'c',L'l',L'u',L'b',L',',L'c',L'o',L'n',L'f',L'e',L'r',L'e',L'n',L'c',L'e',L',',L'c',L'o',L'n',L's',L'u',L'l',L't',L'a',L'n',L't',L',',L'c',L'o',L'n',L's',L'u',L'l',L't',
+	L'i',L'n',L'g',L',',L'c',L'o',L'n',L't',L'r',L'o',L'l',L',',L'c',L'o',L'u',L'n',L'c',L'i',L'l',L',',L'c',L'r',L'e',L'w',L',',L'd',L'e',L's',L'i',L'g',L'n',L',',L'd',L'g',L'c',L'a',L',',L'e',L'd',L'u',L'c',L'a',L't',L'o',L'r',L',',L'e',L'm',L'e',L'r',L'g',L'e',L'n',L'c',L'y',L',',L'e',L'n',L'g',L'i',L'n',L'e',L',',L'e',L'n',L'g',L'i',L'n',L'e',L'e',L'r',L',',L'e',L'n',L't',L'e',L'r',L't',L'a',L'i',L'n',L'm',L'e',L'n',L't',L',',L'e',L'q',L'u',L'i',L'p',L'm',L'e',L'n',L't',L',',L'e',L'x',L'c',L'h',
+	L'a',L'n',L'g',L'e',L',',L'e',L'x',L'p',L'r',L'e',L's',L's',L',',L'f',L'e',L'd',L'e',L'r',L'a',L't',L'i',L'o',L'n',L',',L'f',L'l',L'i',L'g',L'h',L't',L',',L'f',L'r',L'e',L'i',L'g',L'h',L't',L',',L'f',L'u',L'e',L'l',L',',L'g',L'l',L'i',L'd',L'i',L'n',L'g',L',',L'g',L'o',L'v',L'e',L'r',L'n',L'm',L'e',L'n',L't',L',',L'g',L'r',L'o',L'u',L'n',L'd',L'h',L'a',L'n',L'd',L'l',L'i',L'n',L'g',L',',L'g',L'r',L'o',L'u',L'p',L',',L'h',L'a',L'n',L'g',L'g',L'l',L'i',L'd',L'i',L'n',L'g',L',',L'h',L'o',L'm',L'e',
+	L'b',L'u',L'i',L'l',L't',L',',L'i',L'n',L's',L'u',L'r',L'a',L'n',L'c',L'e',L',',L'j',L'o',L'u',L'r',L'n',L'a',L'l',L',',L'j',L'o',L'u',L'r',L'n',L'a',L'l',L'i',L's',L't',L',',L'l',L'e',L'a',L's',L'i',L'n',L'g',L',',L'l',L'o',L'g',L'i',L's',L't',L'i',L'c',L's',L',',L'm',L'a',L'g',L'a',L'z',L'i',L'n',L'e',L',',L'm',L'a',L'i',L'n',L't',L'e',L'n',L'a',L'n',L'c',L'e',L',',L'm',L'a',L'r',L'k',L'e',L't',L'p',L'l',L'a',L'c',L'e',L',',L'm',L'e',L'd',L'i',L'a',L',',L'm',L'i',L'c',L'r',L'o',L'l',L'i',L'g',
+	L'h',L't',L',',L'm',L'o',L'd',L'e',L'l',L'l',L'i',L'n',L'g',L',',L'n',L'a',L'v',L'i',L'g',L'a',L't',L'i',L'o',L'n',L',',L'p',L'a',L'r',L'a',L'c',L'h',L'u',L't',L'i',L'n',L'g',L',',L'p',L'a',L'r',L'a',L'g',L'l',L'i',L'd',L'i',L'n',L'g',L',',L'p',L'a',L's',L's',L'e',L'n',L'g',L'e',L'r',L'-',L'a',L's',L's',L'o',L'c',L'i',L'a',L't',L'i',L'o',L'n',L',',L'p',L'i',L'l',L'o',L't',L',',L'p',L'r',L'e',L's',L's',L',',L'p',L'r',L'o',L'd',L'u',L'c',L't',L'i',L'o',L'n',L',',L'r',L'e',L'c',L'r',L'e',L'a',L't',
+	L'i',L'o',L'n',L',',L'r',L'e',L'p',L'b',L'o',L'd',L'y',L',',L'r',L'e',L's',L',',L'r',L'e',L's',L'e',L'a',L'r',L'c',L'h',L',',L'r',L'o',L't',L'o',L'r',L'c',L'r',L'a',L'f',L't',L',',L's',L'a',L'f',L'e',L't',L'y',L',',L's',L'c',L'i',L'e',L'n',L't',L'i',L's',L't',L',',L's',L'e',L'r',L'v',L'i',L'c',L'e',L's',L',',L's',L'h',L'o',L'w',L',',L's',L'k',L'y',L'd',L'i',L'v',L'i',L'n',L'g',L',',L's',L'o',L'f',L't',L'w',L'a',L'r',L'e',L',',L's',L't',L'u',L'd',L'e',L'n',L't',L',',L't',L'a',L'x',L'i',L',',L't',
+	L'r',L'a',L'd',L'e',L'r',L',',L't',L'r',L'a',L'd',L'i',L'n',L'g',L',',L't',L'r',L'a',L'i',L'n',L'e',L'r',L',',L'u',L'n',L'i',L'o',L'n',L',',L'w',L'o',L'r',L'k',L'i',L'n',L'g',L'g',L'r',L'o',L'u',L'p',L',',L'w',L'o',L'r',L'k',L's',L')',L',',L'a',L'f',L'(',L'5',L':',L'g',L'o',L'v',L',',L'c',L'o',L'm',L',',L'o',L'r',L'g',L',',L'n',L'e',L't',L',',L'e',L'd',L'u',L')',L',',L'a',L'g',L'(',L'5',L':',L'c',L'o',L'm',L',',L'o',L'r',L'g',L',',L'n',L'e',L't',L',',L'c',L'o',L',',L'n',L'o',L'm',L')',L',',L'a',
+	L'i',L'(',L'4',L':',L'o',L'f',L'f',L',',L'c',L'o',L'm',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L')',L',',L'a',L'l',L'(',L'6',L':',L'c',L'o',L'm',L',',L'e',L'd',L'u',L',',L'g',L'o',L'v',L',',L'm',L'i',L'l',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L')',L',',L'a',L'm',L',',L'a',L'n',L'(',L'4',L':',L'c',L'o',L'm',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L',',L'e',L'd',L'u',L')',L',',L'a',L'o',L'(',L'6',L':',L'e',L'd',L',',L'g',L'v',L',',L'o',L'g',L',',L'c',L'o',L',',L'p',L'b',L',',L'i',L't',L')',L',',
+	L'a',L'q',L',',L'a',L'r',L'(',L'1',L'0',L':',L'*',L',',L'c',L'o',L'n',L'g',L'r',L'e',L's',L'o',L'd',L'e',L'l',L'a',L'l',L'e',L'n',L'g',L'u',L'a',L'3',L'(',L'1',L':',L'!',L')',L',',L'e',L'd',L'u',L'c',L'(',L'1',L':',L'!',L')',L',',L'g',L'o',L'b',L'i',L'e',L'r',L'n',L'o',L'e',L'l',L'e',L'c',L't',L'r',L'o',L'n',L'i',L'c',L'o',L'(',L'1',L':',L'!',L')',L',',L'm',L'e',L'c',L'o',L'n',L'(',L'1',L':',L'!',L')',L',',L'n',L'a',L'c',L'i',L'o',L'n',L'(',L'1',L':',L'!',L')',L',',L'n',L'i',L'c',L'(',L'1',L':',
+	L'!',L')',L',',L'p',L'r',L'o',L'm',L'o',L'c',L'i',L'o',L'n',L'(',L'1',L':',L'!',L')',L',',L'r',L'e',L't',L'i',L'n',L'a',L'(',L'1',L':',L'!',L')',L',',L'u',L'b',L'a',L'(',L'1',L':',L'!',L')',L')',L',',L'a',L'r',L'p',L'a',L'(',L'6',L':',L'e',L'1',L'6',L'4',L',',L'i',L'n',L'-',L'a',L'd',L'd',L'r',L',',L'i',L'p',L'6',L',',L'i',L'r',L'i',L's',L',',L'u',L'r',L'i',L',',L'u',L'r',L'n',L')',L',',L'a',L's',L'(',L'1',L':',L'g',L'o',L'v',L')',L',',L'a',L's',L'i',L'a',L',',L'a',L't',L'(',L'7',L':',L'a',L'c',
+	L',',L'c',L'o',L',',L'g',L'v',L',',L'o',L'r',L',',L'b',L'i',L'z',L',',L'i',L'n',L'f',L'o',L',',L'p',L'r',L'i',L'v',L')',L',',L'a',L'u',L'(',L'1',L'9',L':',L'c',L'o',L'm',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L',',L'e',L'd',L'u',L'(',L'8',L':',L'a',L'c',L't',L',',L'n',L's',L'w',L',',L'n',L't',L',',L'q',L'l',L'd',L',',L's',L'a',L',',L't',L'a',L's',L',',L'v',L'i',L'c',L',',L'w',L'a',L')',L',',L'g',L'o',L'v',L'(',L'7',L':',L'a',L'c',L't',L',',L'n',L't',L',',L'q',L'l',L'd',L',',L's',L'a',L',',L't',
+	L'a',L's',L',',L'v',L'i',L'c',L',',L'w',L'a',L')',L',',L'c',L's',L'i',L'r',L'o',L',',L'a',L's',L'n',L',',L'i',L'd',L',',L'i',L'n',L'f',L'o',L',',L'c',L'o',L'n',L'f',L',',L'o',L'z',L',',L'a',L'c',L't',L',',L'n',L's',L'w',L',',L'n',L't',L',',L'q',L'l',L'd',L',',L's',L'a',L',',L't',L'a',L's',L',',L'v',L'i',L'c',L',',L'w',L'a',L')',L',',L'a',L'w',L'(',L'1',L':',L'c',L'o',L'm',L')',L',',L'a',L'x',L',',L'a',L'z',L'(',L'1',L'2',L':',L'c',L'o',L'm',L',',L'n',L'e',L't',L',',L'i',L'n',L't',L',',L'g',L'o',
+	L'v',L',',L'o',L'r',L'g',L',',L'e',L'd',L'u',L',',L'i',L'n',L'f',L'o',L',',L'p',L'p',L',',L'm',L'i',L'l',L',',L'n',L'a',L'm',L'e',L',',L'p',L'r',L'o',L',',L'b',L'i',L'z',L')',L',',L'b',L'a',L'(',L'1',L'0',L':',L'o',L'r',L'g',L',',L'n',L'e',L't',L',',L'e',L'd',L'u',L',',L'g',L'o',L'v',L',',L'm',L'i',L'l',L',',L'u',L'n',L's',L'a',L',',L'u',L'n',L'b',L'i',L',',L'c',L'o',L',',L'c',L'o',L'm',L',',L'r',L's',L')',L',',L'b',L'b',L'(',L'8',L':',L'b',L'i',L'z',L',',L'c',L'o',L'm',L',',L'e',L'd',L'u',L',',
+	L'g',L'o',L'v',L',',L'i',L'n',L'f',L'o',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L',',L's',L't',L'o',L'r',L'e',L')',L',',L'b',L'd',L'(',L'1',L':',L'*',L')',L',',L'b',L'e',L'(',L'1',L':',L'a',L'c',L')',L',',L'b',L'f',L'(',L'1',L':',L'g',L'o',L'v',L')',L',',L'b',L'g',L'(',L'3',L'6',L':',L'a',L',',L'b',L',',L'c',L',',L'd',L',',L'e',L',',L'f',L',',L'g',L',',L'h',L',',L'i',L',',L'j',L',',L'k',L',',L'l',L',',L'm',L',',L'n',L',',L'o',L',',L'p',L',',L'q',L',',L'r',L',',L's',L',',L't',L',',L'u',L',',L'v',
+	L',',L'w',L',',L'x',L',',L'y',L',',L'z',L',',L'0',L',',L'1',L',',L'2',L',',L'3',L',',L'4',L',',L'5',L',',L'6',L',',L'7',L',',L'8',L',',L'9',L')',L',',L'b',L'h',L'(',L'5',L':',L'c',L'o',L'm',L',',L'e',L'd',L'u',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L',',L'g',L'o',L'v',L')',L',',L'b',L'i',L'(',L'5',L':',L'c',L'o',L',',L'c',L'o',L'm',L',',L'e',L'd',L'u',L',',L'o',L'r',L',',L'o',L'r',L'g',L')',L',',L'b',L'i',L'z',L'(',L'7',L':',L'd',L'y',L'n',L'd',L'n',L's',L',',L'f',L'o',L'r',L'-',L'b',L'e',L't',
+	L't',L'e',L'r',L',',L'f',L'o',L'r',L'-',L'm',L'o',L'r',L'e',L',',L'f',L'o',L'r',L'-',L's',L'o',L'm',L'e',L',',L'f',L'o',L'r',L'-',L't',L'h',L'e',L',',L's',L'e',L'l',L'f',L'i',L'p',L',',L'w',L'e',L'b',L'h',L'o',L'p',L')',L',',L'b',L'j',L'(',L'3',L':',L'a',L's',L's',L'o',L',',L'b',L'a',L'r',L'r',L'e',L'a',L'u',L',',L'g',L'o',L'u',L'v',L')',L',',L'b',L'm',L'(',L'5',L':',L'c',L'o',L'm',L',',L'e',L'd',L'u',L',',L'g',L'o',L'v',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L')',L',',L'b',L'n',L'(',L'1',L':',
+	L'*',L')',L',',L'b',L'o',L'(',L'9',L':',L'c',L'o',L'm',L',',L'e',L'd',L'u',L',',L'g',L'o',L'v',L',',L'g',L'o',L'b',L',',L'i',L'n',L't',L',',L'o',L'r',L'g',L',',L'n',L'e',L't',L',',L'm',L'i',L'l',L',',L't',L'v',L')',L',',L'b',L'r',L'(',L'6',L'9',L':',L'a',L'd',L'm',L',',L'a',L'd',L'v',L',',L'a',L'g',L'r',L',',L'a',L'm',L',',L'a',L'r',L'q',L',',L'a',L'r',L't',L',',L'a',L't',L'o',L',',L'b',L',',L'b',L'i',L'o',L',',L'b',L'l',L'o',L'g',L',',L'b',L'm',L'd',L',',L'c',L'i',L'm',L',',L'c',L'n',L'g',L',',
+	L'c',L'n',L't',L',',L'c',L'o',L'm',L',',L'c',L'o',L'o',L'p',L',',L'e',L'c',L'n',L',',L'e',L'c',L'o',L',',L'e',L'd',L'u',L',',L'e',L'm',L'p',L',',L'e',L'n',L'g',L',',L'e',L's',L'p',L',',L'e',L't',L'c',L',',L'e',L't',L'i',L',',L'f',L'a',L'r',L',',L'f',L'l',L'o',L'g',L',',L'f',L'm',L',',L'f',L'n',L'd',L',',L'f',L'o',L't',L',',L'f',L's',L't',L',',L'g',L'1',L'2',L',',L'g',L'g',L'f',L',',L'g',L'o',L'v',L',',L'i',L'm',L'b',L',',L'i',L'n',L'd',L',',L'i',L'n',L'f',L',',L'j',L'o',L'r',L',',L'j',L'u',L's',
+	L',',L'l',L'e',L'g',L',',L'l',L'e',L'l',L',',L'm',L'a',L't',L',',L'm',L'e',L'd',L',',L'm',L'i',L'l',L',',L'm',L'u',L's',L',',L'n',L'e',L't',L',',L'n',L'o',L'm',L',',L'n',L'o',L't',L',',L'n',L't',L'r',L',',L'o',L'd',L'o',L',',L'o',L'r',L'g',L',',L'p',L'p',L'g',L',',L'p',L'r',L'o',L',',L'p',L's',L'c',L',',L'p',L's',L'i',L',',L'q',L's',L'l',L',',L'r',L'a',L'd',L'i',L'o',L',',L'r',L'e',L'c',L',',L's',L'l',L'g',L',',L's',L'r',L'v',L',',L't',L'a',L'x',L'i',L',',L't',L'e',L'o',L',',L't',L'm',L'p',L',',
+	L't',L'r',L'd',L',',L't',L'u',L'r',L',',L't',L'v',L',',L'v',L'e',L't',L',',L'v',L'l',L'o',L'g',L',',L'w',L'i',L'k',L'i',L',',L'z',L'l',L'g',L')',L',',L'b',L's',L'(',L'5',L':',L'c',L'o',L'm',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L',',L'e',L'd',L'u',L',',L'g',L'o',L'v',L')',L',',L'b',L't',L'(',L'5',L':',L'c',L'o',L'm',L',',L'e',L'd',L'u',L',',L'g',L'o',L'v',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L')',L',',L'b',L'w',L'(',L'2',L':',L'c',L'o',L',',L'o',L'r',L'g',L')',L',',L'b',L'y',L'(',L'4',L':',
+	L'g',L'o',L'v',L',',L'm',L'i',L'l',L',',L'c',L'o',L'm',L',',L'o',L'f',L')',L',',L'b',L'z',L'(',L'5',L':',L'c',L'o',L'm',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L',',L'e',L'd',L'u',L',',L'g',L'o',L'v',L')',L',',L'c',L'a',L'(',L'1',L'6',L':',L'a',L'b',L',',L'b',L'c',L',',L'm',L'b',L',',L'n',L'b',L',',L'n',L'f',L',',L'n',L'l',L',',L'n',L's',L',',L'n',L't',L',',L'n',L'u',L',',L'o',L'n',L',',L'p',L'e',L',',L'q',L'c',L',',L's',L'k',L',',L'y',L'k',L',',L'g',L'c',L',',L'c',L'o',L')',L',',L'c',L'a',L't',
+	L',',L'c',L'c',L'(',L'4',L':',L'f',L't',L'p',L'a',L'c',L'c',L'e',L's',L's',L',',L'g',L'a',L'm',L'e',L'-',L's',L'e',L'r',L'v',L'e',L'r',L',',L'm',L'y',L'p',L'h',L'o',L't',L'o',L's',L',',L's',L'c',L'r',L'a',L'p',L'p',L'i',L'n',L'g',L')',L',',L'c',L'd',L'(',L'1',L':',L'g',L'o',L'v',L')',L',',L'c',L'f',L',',L'c',L'g',L',',L'c',L'h',L',',L'c',L'i',L'(',L'1',L'5',L':',L'o',L'r',L'g',L',',L'o',L'r',L',',L'c',L'o',L'm',L',',L'c',L'o',L',',L'e',L'd',L'u',L',',L'e',L'd',L',',L'a',L'c',L',',L'n',L'e',L't',
+	L',',L'g',L'o',L',',L'a',L's',L's',L'o',L',',L'a',L'é',L'r',L'o',L'p',L'o',L'r',L't',L',',L'i',L'n',L't',L',',L'p',L'r',L'e',L's',L's',L'e',L',',L'm',L'd',L',',L'g',L'o',L'u',L'v',L')',L',',L'c',L'k',L'(',L'2',L':',L'*',L',',L'w',L'w',L'w',L'(',L'1',L':',L'!',L')',L')',L',',L'c',L'l',L'(',L'4',L':',L'g',L'o',L'v',L',',L'g',L'o',L'b',L',',L'c',L'o',L',',L'm',L'i',L'l',L')',L',',L'c',L'm',L'(',L'1',L':',L'g',L'o',L'v',L')',L',',L'c',L'n',L'(',L'4',L'4',L':',L'a',L'c',L',',L'c',L'o',L'm',L',',L'e',
+	L'd',L'u',L',',L'g',L'o',L'v',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L',',L'm',L'i',L'l',L',',L'公',L'司',L',',L'网',L'络',L',',L'網',L'絡',L',',L'a',L'h',L',',L'b',L'j',L',',L'c',L'q',L',',L'f',L'j',L',',L'g',L'd',L',',L'g',L's',L',',L'g',L'z',L',',L'g',L'x',L',',L'h',L'a',L',',L'h',L'b',L',',L'h',L'e',L',',L'h',L'i',L',',L'h',L'l',L',',L'h',L'n',L',',L'j',L'l',L',',L'j',L's',L',',L'j',L'x',L',',L'l',L'n',L',',L'n',L'm',L',',L'n',L'x',L',',L'q',L'h',L',',L's',L'c',L',',L's',L'd',L',',L's',L'h',L',',
+	L's',L'n',L',',L's',L'x',L',',L't',L'j',L',',L'x',L'j',L',',L'x',L'z',L',',L'y',L'n',L',',L'z',L'j',L',',L'h',L'k',L',',L'm',L'o',L',',L't',L'w',L')',L',',L'c',L'o',L'(',L'1',L'3',L':',L'a',L'r',L't',L's',L',',L'c',L'o',L'm',L',',L'e',L'd',L'u',L',',L'f',L'i',L'r',L'm',L',',L'g',L'o',L'v',L',',L'i',L'n',L'f',L'o',L',',L'i',L'n',L't',L',',L'm',L'i',L'l',L',',L'n',L'e',L't',L',',L'n',L'o',L'm',L',',L'o',L'r',L'g',L',',L'r',L'e',L'c',L',',L'w',L'e',L'b',L')',L',',L'c',L'o',L'm',L'(',L'1',L'7',L'1',
+	L':',L'a',L'r',L',',L'b',L'r',L',',L'c',L'n',L',',L'd',L'e',L',',L'e',L'u',L',',L'g',L'b',L',',L'g',L'r',L',',L'h',L'u',L',',L'j',L'p',L'n',L',',L'k',L'r',L',',L'n',L'o',L',',L'q',L'c',L',',L'r',L'u',L',',L's',L'a',L',',L's',L'e',L',',L'u',L'k',L',',L'u',L's',L',',L'u',L'y',L',',L'z',L'a',L',',L'o',L'p',L'e',L'r',L'a',L'u',L'n',L'i',L't',L'e',L',',L'a',L'p',L'p',L's',L'p',L'o',L't',L',',L'd',L'y',L'n',L'd',L'n',L's',L'-',L'a',L't',L'-',L'h',L'o',L'm',L'e',L',',L'd',L'y',L'n',L'd',L'n',L's',L'-',
+	L'a',L't',L'-',L'w',L'o',L'r',L'k',L',',L'd',L'y',L'n',L'd',L'n',L's',L'-',L'b',L'l',L'o',L'g',L',',L'd',L'y',L'n',L'd',L'n',L's',L'-',L'f',L'r',L'e',L'e',L',',L'd',L'y',L'n',L'd',L'n',L's',L'-',L'h',L'o',L'm',L'e',L',',L'd',L'y',L'n',L'd',L'n',L's',L'-',L'i',L'p',L',',L'd',L'y',L'n',L'd',L'n',L's',L'-',L'm',L'a',L'i',L'l',L',',L'd',L'y',L'n',L'd',L'n',L's',L'-',L'o',L'f',L'f',L'i',L'c',L'e',L',',L'd',L'y',L'n',L'd',L'n',L's',L'-',L'p',L'i',L'c',L's',L',',L'd',L'y',L'n',L'd',L'n',L's',L'-',L'r',
+	L'e',L'm',L'o',L't',L'e',L',',L'd',L'y',L'n',L'd',L'n',L's',L'-',L's',L'e',L'r',L'v',L'e',L'r',L',',L'd',L'y',L'n',L'd',L'n',L's',L'-',L'w',L'e',L'b',L',',L'd',L'y',L'n',L'd',L'n',L's',L'-',L'w',L'i',L'k',L'i',L',',L'd',L'y',L'n',L'd',L'n',L's',L'-',L'w',L'o',L'r',L'k',L',',L'b',L'l',L'o',L'g',L'd',L'n',L's',L',',L'c',L'e',L'c',L'h',L'i',L'r',L'e',L',',L'd',L'n',L's',L'a',L'l',L'i',L'a',L's',L',',L'd',L'n',L's',L'd',L'o',L'j',L'o',L',',L'd',L'o',L'e',L's',L'n',L't',L'e',L'x',L'i',L's',L't',L',',
+	L'd',L'o',L'n',L't',L'e',L'x',L'i',L's',L't',L',',L'd',L'o',L'o',L'm',L'd',L'n',L's',L',',L'd',L'y',L'n',L'-',L'o',L'-',L's',L'a',L'u',L'r',L',',L'd',L'y',L'n',L'a',L'l',L'i',L'a',L's',L',',L'e',L's',L't',L'-',L'a',L'-',L'l',L'a',L'-',L'm',L'a',L'i',L's',L'o',L'n',L',',L'e',L's',L't',L'-',L'a',L'-',L'l',L'a',L'-',L'm',L'a',L's',L'i',L'o',L'n',L',',L'e',L's',L't',L'-',L'l',L'e',L'-',L'p',L'a',L't',L'r',L'o',L'n',L',',L'e',L's',L't',L'-',L'm',L'o',L'n',L'-',L'b',L'l',L'o',L'g',L'u',L'e',L'u',L'r',
+	L',',L'f',L'r',L'o',L'm',L'-',L'a',L'k',L',',L'f',L'r',L'o',L'm',L'-',L'a',L'l',L',',L'f',L'r',L'o',L'm',L'-',L'a',L'r',L',',L'f',L'r',L'o',L'm',L'-',L'c',L'a',L',',L'f',L'r',L'o',L'm',L'-',L'c',L't',L',',L'f',L'r',L'o',L'm',L'-',L'd',L'c',L',',L'f',L'r',L'o',L'm',L'-',L'd',L'e',L',',L'f',L'r',L'o',L'm',L'-',L'f',L'l',L',',L'f',L'r',L'o',L'm',L'-',L'g',L'a',L',',L'f',L'r',L'o',L'm',L'-',L'h',L'i',L',',L'f',L'r',L'o',L'm',L'-',L'i',L'a',L',',L'f',L'r',L'o',L'm',L'-',L'i',L'd',L',',L'f',L'r',L'o',
+	L'm',L'-',L'i',L'l',L',',L'f',L'r',L'o',L'm',L'-',L'i',L'n',L',',L'f',L'r',L'o',L'm',L'-',L'k',L's',L',',L'f',L'r',L'o',L'm',L'-',L'k',L'y',L',',L'f',L'r',L'o',L'm',L'-',L'm',L'a',L',',L'f',L'r',L'o',L'm',L'-',L'm',L'd',L',',L'f',L'r',L'o',L'm',L'-',L'm',L'i',L',',L'f',L'r',L'o',L'm',L'-',L'm',L'n',L',',L'f',L'r',L'o',L'm',L'-',L'm',L'o',L',',L'f',L'r',L'o',L'm',L'-',L'm',L's',L',',L'f',L'r',L'o',L'm',L'-',L'm',L't',L',',L'f',L'r',L'o',L'm',L'-',L'n',L'c',L',',L'f',L'r',L'o',L'm',L'-',L'n',L'd',
+	L',',L'f',L'r',L'o',L'm',L'-',L'n',L'e',L',',L'f',L'r',L'o',L'm',L'-',L'n',L'h',L',',L'f',L'r',L'o',L'm',L'-',L'n',L'j',L',',L'f',L'r',L'o',L'm',L'-',L'n',L'm',L',',L'f',L'r',L'o',L'm',L'-',L'n',L'v',L',',L'f',L'r',L'o',L'm',L'-',L'o',L'h',L',',L'f',L'r',L'o',L'm',L'-',L'o',L'k',L',',L'f',L'r',L'o',L'm',L'-',L'o',L'r',L',',L'f',L'r',L'o',L'm',L'-',L'p',L'a',L',',L'f',L'r',L'o',L'm',L'-',L'p',L'r',L',',L'f',L'r',L'o',L'm',L'-',L'r',L'i',L',',L'f',L'r',L'o',L'm',L'-',L's',L'c',L',',L'f',L'r',L'o',
+	L'm',L'-',L's',L'd',L',',L'f',L'r',L'o',L'm',L'-',L't',L'n',L',',L'f',L'r',L'o',L'm',L'-',L't',L'x',L',',L'f',L'r',L'o',L'm',L'-',L'u',L't',L',',L'f',L'r',L'o',L'm',L'-',L'v',L'a',L',',L'f',L'r',L'o',L'm',L'-',L'v',L't',L',',L'f',L'r',L'o',L'm',L'-',L'w',L'a',L',',L'f',L'r',L'o',L'm',L'-',L'w',L'i',L',',L'f',L'r',L'o',L'm',L'-',L'w',L'v',L',',L'f',L'r',L'o',L'm',L'-',L'w',L'y',L',',L'g',L'e',L't',L'm',L'y',L'i',L'p',L',',L'g',L'o',L't',L'd',L'n',L's',L',',L'h',L'o',L'b',L'b',L'y',L'-',L's',L'i',
+	L't',L'e',L',',L'h',L'o',L'm',L'e',L'l',L'i',L'n',L'u',L'x',L',',L'h',L'o',L'm',L'e',L'u',L'n',L'i',L'x',L',',L'i',L'a',L'm',L'a',L'l',L'l',L'a',L'm',L'a',L',',L'i',L's',L'-',L'a',L'-',L'a',L'n',L'a',L'r',L'c',L'h',L'i',L's',L't',L',',L'i',L's',L'-',L'a',L'-',L'b',L'l',L'o',L'g',L'g',L'e',L'r',L',',L'i',L's',L'-',L'a',L'-',L'b',L'o',L'o',L'k',L'k',L'e',L'e',L'p',L'e',L'r',L',',L'i',L's',L'-',L'a',L'-',L'b',L'u',L'l',L'l',L's',L'-',L'f',L'a',L'n',L',',L'i',L's',L'-',L'a',L'-',L'c',L'a',L't',L'e',
+	L'r',L'e',L'r',L',',L'i',L's',L'-',L'a',L'-',L'c',L'h',L'e',L'f',L',',L'i',L's',L'-',L'a',L'-',L'c',L'o',L'n',L's',L'e',L'r',L'v',L'a',L't',L'i',L'v',L'e',L',',L'i',L's',L'-',L'a',L'-',L'c',L'p',L'a',L',',L'i',L's',L'-',L'a',L'-',L'c',L'u',L'b',L'i',L'c',L'l',L'e',L'-',L's',L'l',L'a',L'v',L'e',L',',L'i',L's',L'-',L'a',L'-',L'd',L'e',L'm',L'o',L'c',L'r',L'a',L't',L',',L'i',L's',L'-',L'a',L'-',L'd',L'e',L's',L'i',L'g',L'n',L'e',L'r',L',',L'i',L's',L'-',L'a',L'-',L'd',L'o',L'c',L't',L'o',L'r',L',',
+	L'i',L's',L'-',L'a',L'-',L'f',L'i',L'n',L'a',L'n',L'c',L'i',L'a',L'l',L'a',L'd',L'v',L'i',L's',L'o',L'r',L',',L'i',L's',L'-',L'a',L'-',L'g',L'e',L'e',L'k',L',',L'i',L's',L'-',L'a',L'-',L'g',L'r',L'e',L'e',L'n',L',',L'i',L's',L'-',L'a',L'-',L'g',L'u',L'r',L'u',L',',L'i',L's',L'-',L'a',L'-',L'h',L'a',L'r',L'd',L'-',L'w',L'o',L'r',L'k',L'e',L'r',L',',L'i',L's',L'-',L'a',L'-',L'h',L'u',L'n',L't',L'e',L'r',L',',L'i',L's',L'-',L'a',L'-',L'l',L'a',L'n',L'd',L's',L'c',L'a',L'p',L'e',L'r',L',',L'i',L's',
+	L'-',L'a',L'-',L'l',L'a',L'w',L'y',L'e',L'r',L',',L'i',L's',L'-',L'a',L'-',L'l',L'i',L'b',L'e',L'r',L'a',L'l',L',',L'i',L's',L'-',L'a',L'-',L'l',L'i',L'b',L'e',L'r',L't',L'a',L'r',L'i',L'a',L'n',L',',L'i',L's',L'-',L'a',L'-',L'l',L'l',L'a',L'm',L'a',L',',L'i',L's',L'-',L'a',L'-',L'm',L'u',L's',L'i',L'c',L'i',L'a',L'n',L',',L'i',L's',L'-',L'a',L'-',L'n',L'a',L's',L'c',L'a',L'r',L'f',L'a',L'n',L',',L'i',L's',L'-',L'a',L'-',L'n',L'u',L'r',L's',L'e',L',',L'i',L's',L'-',L'a',L'-',L'p',L'a',L'i',L'n',
+	L't',L'e',L'r',L',',L'i',L's',L'-',L'a',L'-',L'p',L'e',L'r',L's',L'o',L'n',L'a',L'l',L't',L'r',L'a',L'i',L'n',L'e',L'r',L',',L'i',L's',L'-',L'a',L'-',L'p',L'h',L'o',L't',L'o',L'g',L'r',L'a',L'p',L'h',L'e',L'r',L',',L'i',L's',L'-',L'a',L'-',L'p',L'l',L'a',L'y',L'e',L'r',L',',L'i',L's',L'-',L'a',L'-',L'r',L'e',L'p',L'u',L'b',L'l',L'i',L'c',L'a',L'n',L',',L'i',L's',L'-',L'a',L'-',L'r',L'o',L'c',L'k',L's',L't',L'a',L'r',L',',L'i',L's',L'-',L'a',L'-',L's',L'o',L'c',L'i',L'a',L'l',L'i',L's',L't',L',',
+	L'i',L's',L'-',L'a',L'-',L's',L't',L'u',L'd',L'e',L'n',L't',L',',L'i',L's',L'-',L'a',L'-',L't',L'e',L'a',L'c',L'h',L'e',L'r',L',',L'i',L's',L'-',L'a',L'-',L't',L'e',L'c',L'h',L'i',L'e',L',',L'i',L's',L'-',L'a',L'-',L't',L'h',L'e',L'r',L'a',L'p',L'i',L's',L't',L',',L'i',L's',L'-',L'a',L'n',L'-',L'a',L'c',L'c',L'o',L'u',L'n',L't',L'a',L'n',L't',L',',L'i',L's',L'-',L'a',L'n',L'-',L'a',L'c',L't',L'o',L'r',L',',L'i',L's',L'-',L'a',L'n',L'-',L'a',L'c',L't',L'r',L'e',L's',L's',L',',L'i',L's',L'-',L'a',
+	L'n',L'-',L'a',L'n',L'a',L'r',L'c',L'h',L'i',L's',L't',L',',L'i',L's',L'-',L'a',L'n',L'-',L'a',L'r',L't',L'i',L's',L't',L',',L'i',L's',L'-',L'a',L'n',L'-',L'e',L'n',L'g',L'i',L'n',L'e',L'e',L'r',L',',L'i',L's',L'-',L'a',L'n',L'-',L'e',L'n',L't',L'e',L'r',L't',L'a',L'i',L'n',L'e',L'r',L',',L'i',L's',L'-',L'c',L'e',L'r',L't',L'i',L'f',L'i',L'e',L'd',L',',L'i',L's',L'-',L'g',L'o',L'n',L'e',L',',L'i',L's',L'-',L'i',L'n',L't',L'o',L'-',L'a',L'n',L'i',L'm',L'e',L',',L'i',L's',L'-',L'i',L'n',L't',L'o',
+	L'-',L'c',L'a',L'r',L's',L',',L'i',L's',L'-',L'i',L'n',L't',L'o',L'-',L'c',L'a',L'r',L't',L'o',L'o',L'n',L's',L',',L'i',L's',L'-',L'i',L'n',L't',L'o',L'-',L'g',L'a',L'm',L'e',L's',L',',L'i',L's',L'-',L'l',L'e',L'e',L't',L',',L'i',L's',L'-',L'n',L'o',L't',L'-',L'c',L'e',L'r',L't',L'i',L'f',L'i',L'e',L'd',L',',L'i',L's',L'-',L's',L'l',L'i',L'c',L'k',L',',L'i',L's',L'-',L'u',L'b',L'e',L'r',L'l',L'e',L'e',L't',L',',L'i',L's',L'-',L'w',L'i',L't',L'h',L'-',L't',L'h',L'e',L'b',L'a',L'n',L'd',L',',L'i',
+	L's',L'a',L'-',L'g',L'e',L'e',L'k',L',',L'i',L's',L'a',L'-',L'h',L'o',L'c',L'k',L'e',L'y',L'n',L'u',L't',L',',L'i',L's',L's',L'm',L'a',L'r',L't',L'e',L'r',L't',L'h',L'a',L'n',L'y',L'o',L'u',L',',L'l',L'i',L'k',L'e',L's',L'-',L'p',L'i',L'e',L',',L'l',L'i',L'k',L'e',L's',L'c',L'a',L'n',L'd',L'y',L',',L'n',L'e',L'a',L't',L'-',L'u',L'r',L'l',L',',L's',L'a',L'v',L'e',L's',L'-',L't',L'h',L'e',L'-',L'w',L'h',L'a',L'l',L'e',L's',L',',L's',L'e',L'l',L'f',L'i',L'p',L',',L's',L'e',L'l',L'l',L's',L'-',L'f',
+	L'o',L'r',L'-',L'l',L'e',L's',L's',L',',L's',L'e',L'l',L'l',L's',L'-',L'f',L'o',L'r',L'-',L'u',L',',L's',L'e',L'r',L'v',L'e',L'b',L'b',L's',L',',L's',L'i',L'm',L'p',L'l',L'e',L'-',L'u',L'r',L'l',L',',L's',L'p',L'a',L'c',L'e',L'-',L't',L'o',L'-',L'r',L'e',L'n',L't',L',',L't',L'e',L'a',L'c',L'h',L'e',L's',L'-',L'y',L'o',L'g',L'a',L',',L'w',L'r',L'i',L't',L'e',L's',L't',L'h',L'i',L's',L'b',L'l',L'o',L'g',L')',L',',L'c',L'o',L'o',L'p',L',',L'c',L'r',L'(',L'7',L':',L'a',L'c',L',',L'c',L'o',L',',L'e',
+	L'd',L',',L'f',L'i',L',',L'g',L'o',L',',L'o',L'r',L',',L's',L'a',L')',L',',L'c',L'u',L'(',L'6',L':',L'c',L'o',L'm',L',',L'e',L'd',L'u',L',',L'o',L'r',L'g',L',',L'n',L'e',L't',L',',L'g',L'o',L'v',L',',L'i',L'n',L'f',L')',L',',L'c',L'v',L',',L'c',L'x',L'(',L'2',L':',L'g',L'o',L'v',L',',L'a',L't',L'h',L')',L',',L'c',L'y',L'(',L'1',L':',L'*',L')',L',',L'c',L'z',L',',L'd',L'e',L'(',L'7',L':',L'c',L'o',L'm',L',',L'f',L'u',L'e',L't',L't',L'e',L'r',L't',L'd',L'a',L's',L'n',L'e',L't',L'z',L',',L'i',L's',
+	L't',L'e',L'i',L'n',L'g',L'e',L'e',L'k',L',',L'i',L's',L't',L'm',L'e',L'i',L'n',L',',L'l',L'e',L'b',L't',L'i',L'm',L'n',L'e',L't',L'z',L',',L'l',L'e',L'i',L't',L'u',L'n',L'g',L's',L'e',L'n',L',',L't',L'r',L'a',L'e',L'u',L'm',L't',L'g',L'e',L'r',L'a',L'd',L'e',L')',L',',L'd',L'j',L',',L'd',L'k',L',',L'd',L'm',L'(',L'5',L':',L'c',L'o',L'm',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L',',L'e',L'd',L'u',L',',L'g',L'o',L'v',L')',L',',L'd',L'o',L'(',L'1',L'0',L':',L'a',L'r',L't',L',',L'c',L'o',L'm',L',',
+	L'e',L'd',L'u',L',',L'g',L'o',L'b',L',',L'g',L'o',L'v',L',',L'm',L'i',L'l',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L',',L's',L'l',L'd',L',',L'w',L'e',L'b',L')',L',',L'd',L'z',L'(',L'8',L':',L'c',L'o',L'm',L',',L'o',L'r',L'g',L',',L'n',L'e',L't',L',',L'g',L'o',L'v',L',',L'e',L'd',L'u',L',',L'a',L's',L's',L'o',L',',L'p',L'o',L'l',L',',L'a',L'r',L't',L')',L',',L'e',L'c',L'(',L'1',L'2',L':',L'c',L'o',L'm',L',',L'i',L'n',L'f',L'o',L',',L'n',L'e',L't',L',',L'f',L'i',L'n',L',',L'k',L'1',L'2',L',',L'm',
+	L'e',L'd',L',',L'p',L'r',L'o',L',',L'o',L'r',L'g',L',',L'e',L'd',L'u',L',',L'g',L'o',L'v',L',',L'g',L'o',L'b',L',',L'm',L'i',L'l',L')',L',',L'e',L'd',L'u',L',',L'e',L'e',L'(',L'1',L'0',L':',L'e',L'd',L'u',L',',L'g',L'o',L'v',L',',L'r',L'i',L'i',L'k',L',',L'l',L'i',L'b',L',',L'm',L'e',L'd',L',',L'c',L'o',L'm',L',',L'p',L'r',L'i',L',',L'a',L'i',L'p',L',',L'o',L'r',L'g',L',',L'f',L'i',L'e',L')',L',',L'e',L'g',L'(',L'9',L':',L'c',L'o',L'm',L',',L'e',L'd',L'u',L',',L'e',L'u',L'n',L',',L'g',L'o',L'v',
+	L',',L'm',L'i',L'l',L',',L'n',L'a',L'm',L'e',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L',',L's',L'c',L'i',L')',L',',L'e',L'r',L'(',L'1',L':',L'*',L')',L',',L'e',L's',L'(',L'5',L':',L'c',L'o',L'm',L',',L'n',L'o',L'm',L',',L'o',L'r',L'g',L',',L'g',L'o',L'b',L',',L'e',L'd',L'u',L')',L',',L'e',L't',L'(',L'1',L':',L'*',L')',L',',L'e',L'u',L',',L'f',L'i',L'(',L'2',L':',L'a',L'l',L'a',L'n',L'd',L',',L'i',L'k',L'i',L')',L',',L'f',L'j',L'(',L'1',L':',L'*',L')',L',',L'f',L'k',L'(',L'1',L':',L'*',L')',L',',
+	L'f',L'm',L',',L'f',L'o',L',',L'f',L'r',L'(',L'2',L'3',L':',L'c',L'o',L'm',L',',L'a',L's',L's',L'o',L',',L'n',L'o',L'm',L',',L'p',L'r',L'd',L',',L'p',L'r',L'e',L's',L's',L'e',L',',L't',L'm',L',',L'a',L'e',L'r',L'o',L'p',L'o',L'r',L't',L',',L'a',L's',L's',L'e',L'd',L'i',L'c',L',',L'a',L'v',L'o',L'c',L'a',L't',L',',L'a',L'v',L'o',L'u',L'e',L's',L',',L'c',L'c',L'i',L',',L'c',L'h',L'a',L'm',L'b',L'a',L'g',L'r',L'i',L',',L'c',L'h',L'i',L'r',L'u',L'r',L'g',L'i',L'e',L'n',L's',L'-',L'd',L'e',L'n',L't',
+	L'i',L's',L't',L'e',L's',L',',L'e',L'x',L'p',L'e',L'r',L't',L's',L'-',L'c',L'o',L'm',L'p',L't',L'a',L'b',L'l',L'e',L's',L',',L'g',L'e',L'o',L'm',L'e',L't',L'r',L'e',L'-',L'e',L'x',L'p',L'e',L'r',L't',L',',L'g',L'o',L'u',L'v',L',',L'g',L'r',L'e',L't',L'a',L',',L'h',L'u',L'i',L's',L's',L'i',L'e',L'r',L'-',L'j',L'u',L's',L't',L'i',L'c',L'e',L',',L'm',L'e',L'd',L'e',L'c',L'i',L'n',L',',L'n',L'o',L't',L'a',L'i',L'r',L'e',L's',L',',L'p',L'h',L'a',L'r',L'm',L'a',L'c',L'i',L'e',L'n',L',',L'p',L'o',L'r',
+	L't',L',',L'v',L'e',L't',L'e',L'r',L'i',L'n',L'a',L'i',L'r',L'e',L')',L',',L'g',L'a',L',',L'g',L'd',L',',L'g',L'e',L'(',L'7',L':',L'c',L'o',L'm',L',',L'e',L'd',L'u',L',',L'g',L'o',L'v',L',',L'o',L'r',L'g',L',',L'm',L'i',L'l',L',',L'n',L'e',L't',L',',L'p',L'v',L't',L')',L',',L'g',L'f',L',',L'g',L'g',L'(',L'5',L':',L'c',L'o',L',',L'o',L'r',L'g',L',',L'n',L'e',L't',L',',L's',L'c',L'h',L',',L'g',L'o',L'v',L')',L',',L'g',L'h',L'(',L'5',L':',L'c',L'o',L'm',L',',L'e',L'd',L'u',L',',L'g',L'o',L'v',L',',
+	L'o',L'r',L'g',L',',L'm',L'i',L'l',L')',L',',L'g',L'i',L'(',L'6',L':',L'c',L'o',L'm',L',',L'l',L't',L'd',L',',L'g',L'o',L'v',L',',L'm',L'o',L'd',L',',L'e',L'd',L'u',L',',L'o',L'r',L'g',L')',L',',L'g',L'l',L',',L'g',L'm',L',',L'g',L'n',L'(',L'6',L':',L'a',L'c',L',',L'c',L'o',L'm',L',',L'e',L'd',L'u',L',',L'g',L'o',L'v',L',',L'o',L'r',L'g',L',',L'n',L'e',L't',L')',L',',L'g',L'o',L'v',L',',L'g',L'p',L'(',L'6',L':',L'c',L'o',L'm',L',',L'n',L'e',L't',L',',L'm',L'o',L'b',L'i',L',',L'e',L'd',L'u',L',',
+	L'o',L'r',L'g',L',',L'a',L's',L's',L'o',L')',L',',L'g',L'q',L',',L'g',L'r',L'(',L'5',L':',L'c',L'o',L'm',L',',L'e',L'd',L'u',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L',',L'g',L'o',L'v',L')',L',',L'g',L's',L',',L'g',L't',L'(',L'2',L':',L'*',L',',L'w',L'w',L'w',L'(',L'1',L':',L'!',L')',L')',L',',L'g',L'u',L'(',L'1',L':',L'*',L')',L',',L'g',L'w',L',',L'g',L'y',L'(',L'3',L':',L'c',L'o',L',',L'c',L'o',L'm',L',',L'n',L'e',L't',L')',L',',L'h',L'k',L'(',L'2',L'1',L':',L'c',L'o',L'm',L',',L'e',L'd',L'u',
+	L',',L'g',L'o',L'v',L',',L'i',L'd',L'v',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L',',L'公',L'司',L',',L'教',L'育',L',',L'敎',L'育',L',',L'政',L'府',L',',L'個',L'人',L',',L'个',L'人',L',',L'箇',L'人',L',',L'網',L'络',L',',L'网',L'络',L',',L'组',L'織',L',',L'網',L'絡',L',',L'网',L'絡',L',',L'组',L'织',L',',L'組',L'織',L',',L'組',L'织',L')',L',',L'h',L'm',L',',L'h',L'n',L'(',L'6',L':',L'c',L'o',L'm',L',',L'e',L'd',L'u',L',',L'o',L'r',L'g',L',',L'n',L'e',L't',L',',L'm',L'i',L'l',L',',L'g',L'o',L'b',L')',L',',L'h',L'r',L'(',L'4',
+	L':',L'i',L'z',L',',L'f',L'r',L'o',L'm',L',',L'n',L'a',L'm',L'e',L',',L'c',L'o',L'm',L')',L',',L'h',L't',L'(',L'1',L'7',L':',L'c',L'o',L'm',L',',L's',L'h',L'o',L'p',L',',L'f',L'i',L'r',L'm',L',',L'i',L'n',L'f',L'o',L',',L'a',L'd',L'u',L'l',L't',L',',L'n',L'e',L't',L',',L'p',L'r',L'o',L',',L'o',L'r',L'g',L',',L'm',L'e',L'd',L',',L'a',L'r',L't',L',',L'c',L'o',L'o',L'p',L',',L'p',L'o',L'l',L',',L'a',L's',L's',L'o',L',',L'e',L'd',L'u',L',',L'r',L'e',L'l',L',',L'g',L'o',L'u',L'v',L',',L'p',L'e',L'r',
+	L's',L'o',L')',L',',L'h',L'u',L'(',L'3',L'1',L':',L'c',L'o',L',',L'i',L'n',L'f',L'o',L',',L'o',L'r',L'g',L',',L'p',L'r',L'i',L'v',L',',L's',L'p',L'o',L'r',L't',L',',L't',L'm',L',',L'2',L'0',L'0',L'0',L',',L'a',L'g',L'r',L'a',L'r',L',',L'b',L'o',L'l',L't',L',',L'c',L'a',L's',L'i',L'n',L'o',L',',L'c',L'i',L't',L'y',L',',L'e',L'r',L'o',L't',L'i',L'c',L'a',L',',L'e',L'r',L'o',L't',L'i',L'k',L'a',L',',L'f',L'i',L'l',L'm',L',',L'f',L'o',L'r',L'u',L'm',L',',L'g',L'a',L'm',L'e',L's',L',',L'h',L'o',L't',
+	L'e',L'l',L',',L'i',L'n',L'g',L'a',L't',L'l',L'a',L'n',L',',L'j',L'o',L'g',L'a',L's',L'z',L',',L'k',L'o',L'n',L'y',L'v',L'e',L'l',L'o',L',',L'l',L'a',L'k',L'a',L's',L',',L'm',L'e',L'd',L'i',L'a',L',',L'n',L'e',L'w',L's',L',',L'r',L'e',L'k',L'l',L'a',L'm',L',',L's',L'e',L'x',L',',L's',L'h',L'o',L'p',L',',L's',L'u',L'l',L'i',L',',L's',L'z',L'e',L'x',L',',L't',L'o',L'z',L's',L'd',L'e',L',',L'u',L't',L'a',L'z',L'a',L's',L',',L'v',L'i',L'd',L'e',L'o',L')',L',',L'i',L'd',L'(',L'8',L':',L'a',L'c',L',',
+	L'c',L'o',L',',L'g',L'o',L',',L'm',L'i',L'l',L',',L'n',L'e',L't',L',',L'o',L'r',L',',L's',L'c',L'h',L',',L'w',L'e',L'b',L')',L',',L'i',L'e',L'(',L'1',L':',L'g',L'o',L'v',L')',L',',L'i',L'l',L'(',L'1',L':',L'*',L')',L',',L'i',L'm',L'(',L'6',L':',L'c',L'o',L'(',L'2',L':',L'l',L't',L'd',L',',L'p',L'l',L'c',L')',L',',L'n',L'e',L't',L',',L'g',L'o',L'v',L',',L'o',L'r',L'g',L',',L'n',L'i',L'c',L',',L'a',L'c',L')',L',',L'i',L'n',L'(',L'1',L'2',L':',L'c',L'o',L',',L'f',L'i',L'r',L'm',L',',L'n',L'e',L't',
+	L',',L'o',L'r',L'g',L',',L'g',L'e',L'n',L',',L'i',L'n',L'd',L',',L'n',L'i',L'c',L',',L'a',L'c',L',',L'e',L'd',L'u',L',',L'r',L'e',L's',L',',L'g',L'o',L'v',L',',L'm',L'i',L'l',L')',L',',L'i',L'n',L'f',L'o',L'(',L'1',L'0',L':',L'd',L'y',L'n',L'd',L'n',L's',L',',L'b',L'a',L'r',L'r',L'e',L'l',L'-',L'o',L'f',L'-',L'k',L'n',L'o',L'w',L'l',L'e',L'd',L'g',L'e',L',',L'b',L'a',L'r',L'r',L'e',L'l',L'l',L'-',L'o',L'f',L'-',L'k',L'n',L'o',L'w',L'l',L'e',L'd',L'g',L'e',L',',L'f',L'o',L'r',L'-',L'o',L'u',L'r',
+	L',',L'g',L'r',L'o',L'k',L's',L'-',L't',L'h',L'e',L',',L'g',L'r',L'o',L'k',L's',L'-',L't',L'h',L'i',L's',L',',L'h',L'e',L'r',L'e',L'-',L'f',L'o',L'r',L'-',L'm',L'o',L'r',L'e',L',',L'k',L'n',L'o',L'w',L's',L'i',L't',L'a',L'l',L'l',L',',L's',L'e',L'l',L'f',L'i',L'p',L',',L'w',L'e',L'b',L'h',L'o',L'p',L')',L',',L'i',L'n',L't',L'(',L'1',L':',L'e',L'u',L')',L',',L'i',L'o',L'(',L'1',L':',L'c',L'o',L'm',L')',L',',L'i',L'q',L'(',L'6',L':',L'g',L'o',L'v',L',',L'e',L'd',L'u',L',',L'm',L'i',L'l',L',',L'c',
+	L'o',L'm',L',',L'o',L'r',L'g',L',',L'n',L'e',L't',L')',L',',L'i',L'r',L'(',L'9',L':',L'a',L'c',L',',L'c',L'o',L',',L'g',L'o',L'v',L',',L'i',L'd',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L',',L's',L'c',L'h',L',',L'ا',L'ی',L'ر',L'ا',L'ن',L',',L'ا',L'ي',L'ر',L'ا',L'ن',L')',L',',L'i',L's',L'(',L'6',L':',L'n',L'e',L't',L',',L'c',L'o',L'm',L',',L'e',L'd',L'u',L',',L'g',L'o',L'v',L',',L'o',L'r',L'g',L',',L'i',L'n',L't',L')',L',',L'i',L't',L'(',L'2',L'7',L'7',L':',L'g',L'o',L'v',L',',L'e',L'd',L'u',L',',
+	L'a',L'g',L'r',L'i',L'g',L'e',L'n',L't',L'o',L',',L'a',L'g',L',',L'a',L'l',L'e',L's',L's',L'a',L'n',L'd',L'r',L'i',L'a',L',',L'a',L'l',L',',L'a',L'n',L'c',L'o',L'n',L'a',L',',L'a',L'n',L',',L'a',L'o',L's',L't',L'a',L',',L'a',L'o',L's',L't',L'e',L',',L'a',L'o',L',',L'a',L'r',L'e',L'z',L'z',L'o',L',',L'a',L'r',L',',L'a',L's',L'c',L'o',L'l',L'i',L'-',L'p',L'i',L'c',L'e',L'n',L'o',L',',L'a',L's',L'c',L'o',L'l',L'i',L'p',L'i',L'c',L'e',L'n',L'o',L',',L'a',L'p',L',',L'a',L's',L't',L'i',L',',L'a',L't',
+	L',',L'a',L'v',L'e',L'l',L'l',L'i',L'n',L'o',L',',L'a',L'v',L',',L'b',L'a',L'r',L'i',L',',L'b',L'a',L',',L'a',L'n',L'd',L'r',L'i',L'a',L'-',L'b',L'a',L'r',L'l',L'e',L't',L't',L'a',L'-',L't',L'r',L'a',L'n',L'i',L',',L'a',L'n',L'd',L'r',L'i',L'a',L'b',L'a',L'r',L'l',L'e',L't',L't',L'a',L't',L'r',L'a',L'n',L'i',L',',L't',L'r',L'a',L'n',L'i',L'-',L'b',L'a',L'r',L'l',L'e',L't',L't',L'a',L'-',L'a',L'n',L'd',L'r',L'i',L'a',L',',L't',L'r',L'a',L'n',L'i',L'b',L'a',L'r',L'l',L'e',L't',L't',L'a',L'a',L'n',
+	L'd',L'r',L'i',L'a',L',',L'b',L'a',L'r',L'l',L'e',L't',L't',L'a',L'-',L't',L'r',L'a',L'n',L'i',L'-',L'a',L'n',L'd',L'r',L'i',L'a',L',',L'b',L'a',L'r',L'l',L'e',L't',L't',L'a',L't',L'r',L'a',L'n',L'i',L'a',L'n',L'd',L'r',L'i',L'a',L',',L'a',L'n',L'd',L'r',L'i',L'a',L'-',L't',L'r',L'a',L'n',L'i',L'-',L'b',L'a',L'r',L'l',L'e',L't',L't',L'a',L',',L'a',L'n',L'd',L'r',L'i',L'a',L't',L'r',L'a',L'n',L'i',L'b',L'a',L'r',L'l',L'e',L't',L't',L'a',L',',L't',L'r',L'a',L'n',L'i',L'-',L'a',L'n',L'd',L'r',L'i',
+	L'a',L'-',L'b',L'a',L'r',L'l',L'e',L't',L't',L'a',L',',L't',L'r',L'a',L'n',L'i',L'a',L'n',L'd',L'r',L'i',L'a',L'b',L'a',L'r',L'l',L'e',L't',L't',L'a',L',',L'b',L't',L',',L'b',L'e',L'l',L'l',L'u',L'n',L'o',L',',L'b',L'l',L',',L'b',L'e',L'n',L'e',L'v',L'e',L'n',L't',L'o',L',',L'b',L'n',L',',L'b',L'e',L'r',L'g',L'a',L'm',L'o',L',',L'b',L'g',L',',L'b',L'i',L'e',L'l',L'l',L'a',L',',L'b',L'i',L',',L'b',L'o',L'l',L'o',L'g',L'n',L'a',L',',L'b',L'o',L',',L'b',L'o',L'l',L'z',L'a',L'n',L'o',L',',L'b',L'o',
+	L'z',L'e',L'n',L',',L'b',L'a',L'l',L's',L'a',L'n',L',',L'a',L'l',L't',L'o',L'-',L'a',L'd',L'i',L'g',L'e',L',',L'a',L'l',L't',L'o',L'a',L'd',L'i',L'g',L'e',L',',L's',L'u',L'e',L'd',L't',L'i',L'r',L'o',L'l',L',',L'b',L'z',L',',L'b',L'r',L'e',L's',L'c',L'i',L'a',L',',L'b',L's',L',',L'b',L'r',L'i',L'n',L'd',L'i',L's',L'i',L',',L'b',L'r',L',',L'c',L'a',L'g',L'l',L'i',L'a',L'r',L'i',L',',L'c',L'a',L',',L'c',L'a',L'l',L't',L'a',L'n',L'i',L's',L's',L'e',L't',L't',L'a',L',',L'c',L'l',L',',L'c',L'a',L'm',
+	L'p',L'o',L'b',L'a',L's',L's',L'o',L',',L'c',L'b',L',',L'c',L'a',L'r',L'b',L'o',L'n',L'i',L'a',L'i',L'g',L'l',L'e',L's',L'i',L'a',L's',L',',L'c',L'a',L'r',L'b',L'o',L'n',L'i',L'a',L'-',L'i',L'g',L'l',L'e',L's',L'i',L'a',L's',L',',L'i',L'g',L'l',L'e',L's',L'i',L'a',L's',L'-',L'c',L'a',L'r',L'b',L'o',L'n',L'i',L'a',L',',L'i',L'g',L'l',L'e',L's',L'i',L'a',L's',L'c',L'a',L'r',L'b',L'o',L'n',L'i',L'a',L',',L'c',L'i',L',',L'c',L'a',L's',L'e',L'r',L't',L'a',L',',L'c',L'e',L',',L'c',L'a',L't',L'a',L'n',
+	L'i',L'a',L',',L'c',L't',L',',L'c',L'a',L't',L'a',L'n',L'z',L'a',L'r',L'o',L',',L'c',L'z',L',',L'c',L'h',L'i',L'e',L't',L'i',L',',L'c',L'h',L',',L'c',L'o',L'm',L'o',L',',L'c',L'o',L',',L'c',L'o',L's',L'e',L'n',L'z',L'a',L',',L'c',L's',L',',L'c',L'r',L'e',L'm',L'o',L'n',L'a',L',',L'c',L'r',L',',L'c',L'r',L'o',L't',L'o',L'n',L'e',L',',L'k',L'r',L',',L'c',L'u',L'n',L'e',L'o',L',',L'c',L'n',L',',L'd',L'e',L'l',L'l',L'-',L'o',L'g',L'l',L'i',L'a',L's',L't',L'r',L'a',L',',L'd',L'e',L'l',L'l',L'o',L'g',
+	L'l',L'i',L'a',L's',L't',L'r',L'a',L',',L'o',L'g',L'l',L'i',L'a',L's',L't',L'r',L'a',L',',L'o',L'g',L',',L'e',L'n',L'n',L'a',L',',L'e',L'n',L',',L'f',L'e',L'r',L'r',L'a',L'r',L'a',L',',L'f',L'e',L',',L'f',L'e',L'r',L'm',L'o',L',',L'f',L'm',L',',L'f',L'i',L'r',L'e',L'n',L'z',L'e',L',',L'f',L'l',L'o',L'r',L'e',L'n',L'c',L'e',L',',L'f',L'i',L',',L'f',L'o',L'g',L'g',L'i',L'a',L',',L'f',L'g',L',',L'f',L'o',L'r',L'l',L'i',L'-',L'c',L'e',L's',L'e',L'n',L'a',L',',L'f',L'o',L'r',L'l',L'i',L'c',L'e',L's',
+	L'e',L'n',L'a',L',',L'c',L'e',L's',L'e',L'n',L'a',L'-',L'f',L'o',L'r',L'l',L'i',L',',L'c',L'e',L's',L'e',L'n',L'a',L'f',L'o',L'r',L'l',L'i',L',',L'f',L'c',L',',L'f',L'r',L'o',L's',L'i',L'n',L'o',L'n',L'e',L',',L'f',L'r',L',',L'g',L'e',L'n',L'o',L'v',L'a',L',',L'g',L'e',L'n',L'o',L'a',L',',L'g',L'e',L',',L'g',L'o',L'r',L'i',L'z',L'i',L'a',L',',L'g',L'o',L',',L'g',L'r',L'o',L's',L's',L'e',L't',L'o',L',',L'g',L'r',L',',L'i',L'm',L'p',L'e',L'r',L'i',L'a',L',',L'i',L'm',L',',L'i',L's',L'e',L'r',L'n',
+	L'i',L'a',L',',L'i',L's',L',',L'l',L'a',L'q',L'u',L'i',L'l',L'a',L',',L'a',L'q',L'u',L'i',L'l',L'a',L',',L'a',L'q',L',',L'l',L'a',L'-',L's',L'p',L'e',L'z',L'i',L'a',L',',L'l',L'a',L's',L'p',L'e',L'z',L'i',L'a',L',',L's',L'p',L',',L'l',L'a',L't',L'i',L'n',L'a',L',',L'l',L't',L',',L'l',L'e',L'c',L'c',L'e',L',',L'l',L'e',L',',L'l',L'e',L'c',L'c',L'o',L',',L'l',L'c',L',',L'l',L'i',L'v',L'o',L'r',L'n',L'o',L',',L'l',L'i',L',',L'l',L'o',L'd',L'i',L',',L'l',L'o',L',',L'l',L'u',L'c',L'c',L'a',L',',L'l',
+	L'u',L',',L'm',L'a',L'c',L'e',L'r',L'a',L't',L'a',L',',L'm',L'c',L',',L'm',L'a',L'n',L't',L'o',L'v',L'a',L',',L'm',L'n',L',',L'm',L'a',L's',L's',L'a',L'-',L'c',L'a',L'r',L'r',L'a',L'r',L'a',L',',L'm',L'a',L's',L's',L'a',L'c',L'a',L'r',L'r',L'a',L'r',L'a',L',',L'c',L'a',L'r',L'r',L'a',L'r',L'a',L'-',L'm',L'a',L's',L's',L'a',L',',L'c',L'a',L'r',L'r',L'a',L'r',L'a',L'm',L'a',L's',L's',L'a',L',',L'm',L's',L',',L'm',L'a',L't',L'e',L'r',L'a',L',',L'm',L't',L',',L'm',L'e',L'd',L'i',L'o',L'-',L'c',L'a',
+	L'm',L'p',L'i',L'd',L'a',L'n',L'o',L',',L'm',L'e',L'd',L'i',L'o',L'c',L'a',L'm',L'p',L'i',L'd',L'a',L'n',L'o',L',',L'c',L'a',L'm',L'p',L'i',L'd',L'a',L'n',L'o',L'-',L'm',L'e',L'd',L'i',L'o',L',',L'c',L'a',L'm',L'p',L'i',L'd',L'a',L'n',L'o',L'm',L'e',L'd',L'i',L'o',L',',L'v',L's',L',',L'm',L'e',L's',L's',L'i',L'n',L'a',L',',L'm',L'e',L',',L'm',L'i',L'l',L'a',L'n',L'o',L',',L'm',L'i',L'l',L'a',L'n',L',',L'm',L'i',L',',L'm',L'o',L'd',L'e',L'n',L'a',L',',L'm',L'o',L',',L'm',L'o',L'n',L'z',L'a',L',',
+	L'm',L'o',L'n',L'z',L'a',L'-',L'b',L'r',L'i',L'a',L'n',L'z',L'a',L',',L'm',L'o',L'n',L'z',L'a',L'b',L'r',L'i',L'a',L'n',L'z',L'a',L',',L'm',L'o',L'n',L'z',L'a',L'e',L'b',L'r',L'i',L'a',L'n',L'z',L'a',L',',L'm',L'o',L'n',L'z',L'a',L'e',L'd',L'e',L'l',L'l',L'a',L'b',L'r',L'i',L'a',L'n',L'z',L'a',L',',L'm',L'o',L'n',L'z',L'a',L'-',L'e',L'-',L'd',L'e',L'l',L'l',L'a',L'-',L'b',L'r',L'i',L'a',L'n',L'z',L'a',L',',L'm',L'b',L',',L'n',L'a',L'p',L'o',L'l',L'i',L',',L'n',L'a',L'p',L'l',L'e',L's',L',',L'n',
+	L'a',L',',L'n',L'o',L'v',L'a',L'r',L'a',L',',L'n',L'o',L',',L'n',L'u',L'o',L'r',L'o',L',',L'n',L'u',L',',L'o',L'r',L'i',L's',L't',L'a',L'n',L'o',L',',L'o',L'r',L',',L'p',L'a',L'd',L'o',L'v',L'a',L',',L'p',L'a',L'd',L'u',L'a',L',',L'p',L'd',L',',L'p',L'a',L'l',L'e',L'r',L'm',L'o',L',',L'p',L'a',L',',L'p',L'a',L'r',L'm',L'a',L',',L'p',L'r',L',',L'p',L'a',L'v',L'i',L'a',L',',L'p',L'v',L',',L'p',L'e',L'r',L'u',L'g',L'i',L'a',L',',L'p',L'g',L',',L'p',L'e',L's',L'c',L'a',L'r',L'a',L',',L'p',L'e',L',',
+	L'p',L'e',L's',L'a',L'r',L'o',L'-',L'u',L'r',L'b',L'i',L'n',L'o',L',',L'p',L'e',L's',L'a',L'r',L'o',L'u',L'r',L'b',L'i',L'n',L'o',L',',L'u',L'r',L'b',L'i',L'n',L'o',L'-',L'p',L'e',L's',L'a',L'r',L'o',L',',L'u',L'r',L'b',L'i',L'n',L'o',L'p',L'e',L's',L'a',L'r',L'o',L',',L'p',L'u',L',',L'p',L'i',L'a',L'c',L'e',L'n',L'z',L'a',L',',L'p',L'c',L',',L'p',L'i',L's',L'a',L',',L'p',L'i',L',',L'p',L'i',L's',L't',L'o',L'i',L'a',L',',L'p',L't',L',',L'p',L'o',L'r',L'd',L'e',L'n',L'o',L'n',L'e',L',',L'p',L'n',
+	L',',L'p',L'o',L't',L'e',L'n',L'z',L'a',L',',L'p',L'z',L',',L'p',L'r',L'a',L't',L'o',L',',L'p',L'o',L',',L'r',L'a',L'g',L'u',L's',L'a',L',',L'r',L'g',L',',L'r',L'a',L'v',L'e',L'n',L'n',L'a',L',',L'r',L'a',L',',L'r',L'e',L'g',L'g',L'i',L'o',L'-',L'c',L'a',L'l',L'a',L'b',L'r',L'i',L'a',L',',L'r',L'e',L'g',L'g',L'i',L'o',L'c',L'a',L'l',L'a',L'b',L'r',L'i',L'a',L',',L'r',L'c',L',',L'r',L'e',L'g',L'g',L'i',L'o',L'-',L'e',L'm',L'i',L'l',L'i',L'a',L',',L'r',L'e',L'g',L'g',L'i',L'o',L'e',L'm',L'i',L'l',
+	L'i',L'a',L',',L'r',L'e',L',',L'r',L'i',L'e',L't',L'i',L',',L'r',L'i',L',',L'r',L'i',L'm',L'i',L'n',L'i',L',',L'r',L'n',L',',L'r',L'o',L'm',L'a',L',',L'r',L'o',L'm',L'e',L',',L'r',L'm',L',',L'r',L'o',L'v',L'i',L'g',L'o',L',',L'r',L'o',L',',L's',L'a',L'l',L'e',L'r',L'n',L'o',L',',L's',L'a',L',',L's',L'a',L's',L's',L'a',L'r',L'i',L',',L's',L's',L',',L's',L'a',L'v',L'o',L'n',L'a',L',',L's',L'v',L',',L's',L'i',L'e',L'n',L'a',L',',L's',L'i',L',',L's',L'i',L'r',L'a',L'c',L'u',L's',L'a',L',',L's',L'r',
+	L',',L's',L'o',L'n',L'd',L'r',L'i',L'o',L',',L's',L'o',L',',L't',L'a',L'r',L'a',L'n',L't',L'o',L',',L't',L'a',L',',L't',L'e',L'm',L'p',L'i',L'o',L'-',L'o',L'l',L'b',L'i',L'a',L',',L't',L'e',L'm',L'p',L'i',L'o',L'o',L'l',L'b',L'i',L'a',L',',L'o',L'l',L'b',L'i',L'a',L'-',L't',L'e',L'm',L'p',L'i',L'o',L',',L'o',L'l',L'b',L'i',L'a',L't',L'e',L'm',L'p',L'i',L'o',L',',L'o',L't',L',',L't',L'e',L'r',L'a',L'm',L'o',L',',L't',L'e',L',',L't',L'e',L'r',L'n',L'i',L',',L't',L'r',L',',L't',L'o',L'r',L'i',L'n',
+	L'o',L',',L't',L'u',L'r',L'i',L'n',L',',L't',L'o',L',',L't',L'r',L'a',L'p',L'a',L'n',L'i',L',',L't',L'p',L',',L't',L'r',L'e',L'n',L't',L'o',L',',L't',L'r',L'e',L'n',L't',L'i',L'n',L'o',L',',L't',L'n',L',',L't',L'r',L'e',L'v',L'i',L's',L'o',L',',L't',L'v',L',',L't',L'r',L'i',L'e',L's',L't',L'e',L',',L't',L's',L',',L'u',L'd',L'i',L'n',L'e',L',',L'u',L'd',L',',L'v',L'a',L'r',L'e',L's',L'e',L',',L'v',L'a',L',',L'v',L'e',L'n',L'e',L'z',L'i',L'a',L',',L'v',L'e',L'n',L'i',L'c',L'e',L',',L'v',L'e',L',',
+	L'v',L'e',L'r',L'b',L'a',L'n',L'i',L'a',L',',L'v',L'b',L',',L'v',L'e',L'r',L'c',L'e',L'l',L'l',L'i',L',',L'v',L'c',L',',L'v',L'e',L'r',L'o',L'n',L'a',L',',L'v',L'r',L',',L'v',L'i',L'b',L'o',L'-',L'v',L'a',L'l',L'e',L'n',L't',L'i',L'a',L',',L'v',L'i',L'b',L'o',L'v',L'a',L'l',L'e',L'n',L't',L'i',L'a',L',',L'v',L'v',L',',L'v',L'i',L'c',L'e',L'n',L'z',L'a',L',',L'v',L'i',L',',L'v',L'i',L't',L'e',L'r',L'b',L'o',L',',L'v',L't',L')',L',',L'j',L'e',L'(',L'5',L':',L'c',L'o',L',',L'o',L'r',L'g',L',',L'n',
+	L'e',L't',L',',L's',L'c',L'h',L',',L'g',L'o',L'v',L')',L',',L'j',L'm',L'(',L'1',L':',L'*',L')',L',',L'j',L'o',L'(',L'8',L':',L'c',L'o',L'm',L',',L'o',L'r',L'g',L',',L'n',L'e',L't',L',',L'e',L'd',L'u',L',',L's',L'c',L'h',L',',L'g',L'o',L'v',L',',L'm',L'i',L'l',L',',L'n',L'a',L'm',L'e',L')',L',',L'j',L'o',L'b',L's',L',',L'j',L'p',L'(',L'6',L'3',L':',L'a',L'c',L',',L'a',L'd',L',',L'c',L'o',L',',L'e',L'd',L',',L'g',L'o',L',',L'g',L'r',L',',L'l',L'g',L',',L'n',L'e',L',',L'o',L'r',L',',L'a',L'i',L'c',
+	L'h',L'i',L'(',L'5',L'3',L':',L'a',L'i',L's',L'a',L'i',L',',L'a',L'm',L'a',L',',L'a',L'n',L'j',L'o',L',',L'a',L's',L'u',L'k',L'e',L',',L'c',L'h',L'i',L'r',L'y',L'u',L',',L'c',L'h',L'i',L't',L'a',L',',L'f',L'u',L's',L'o',L',',L'g',L'a',L'm',L'a',L'g',L'o',L'r',L'i',L',',L'h',L'a',L'n',L'd',L'a',L',',L'h',L'a',L'z',L'u',L',',L'h',L'e',L'k',L'i',L'n',L'a',L'n',L',',L'h',L'i',L'g',L'a',L's',L'h',L'i',L'u',L'r',L'a',L',',L'i',L'c',L'h',L'i',L'n',L'o',L'm',L'i',L'y',L'a',L',',L'i',L'n',L'a',L'z',L'a',
+	L'w',L'a',L',',L'i',L'n',L'u',L'y',L'a',L'm',L'a',L',',L'i',L's',L's',L'h',L'i',L'k',L'i',L',',L'i',L'w',L'a',L'k',L'u',L'r',L'a',L',',L'k',L'a',L'n',L'i',L'e',L',',L'k',L'a',L'r',L'i',L'y',L'a',L',',L'k',L'a',L's',L'u',L'g',L'a',L'i',L',',L'k',L'i',L'r',L'a',L',',L'k',L'i',L'y',L'o',L's',L'u',L',',L'k',L'o',L'm',L'a',L'k',L'i',L',',L'k',L'o',L'n',L'a',L'n',L',',L'k',L'o',L't',L'a',L',',L'm',L'i',L'h',L'a',L'm',L'a',L',',L'm',L'i',L'y',L'o',L's',L'h',L'i',L',',L'n',L'a',L'g',L'a',L'k',L'u',L't',
+	L'e',L',',L'n',L'i',L's',L'h',L'i',L'o',L',',L'n',L'i',L's',L's',L'h',L'i',L'n',L',',L'o',L'b',L'u',L',',L'o',L'g',L'u',L'c',L'h',L'i',L',',L'o',L'h',L'a',L'r',L'u',L',',L'o',L'k',L'a',L'z',L'a',L'k',L'i',L',',L'o',L'w',L'a',L'r',L'i',L'a',L's',L'a',L'h',L'i',L',',L's',L'e',L't',L'o',L',',L's',L'h',L'i',L'k',L'a',L't',L's',L'u',L',',L's',L'h',L'i',L'n',L's',L'h',L'i',L'r',L'o',L',',L's',L'h',L'i',L't',L'a',L'r',L'a',L',',L't',L'a',L'h',L'a',L'r',L'a',L',',L't',L'a',L'k',L'a',L'h',L'a',L'm',L'a',
+	L',',L't',L'o',L'b',L'i',L's',L'h',L'i',L'm',L'a',L',',L't',L'o',L'e',L'i',L',',L't',L'o',L'g',L'o',L',',L't',L'o',L'k',L'a',L'i',L',',L't',L'o',L'k',L'o',L'n',L'a',L'm',L'e',L',',L't',L'o',L'y',L'o',L'a',L'k',L'e',L',',L't',L'o',L'y',L'o',L'h',L'a',L's',L'h',L'i',L',',L't',L'o',L'y',L'o',L'k',L'a',L'w',L'a',L',',L't',L'o',L'y',L'o',L'n',L'e',L',',L't',L'o',L'y',L'o',L't',L'a',L',',L't',L's',L'u',L's',L'h',L'i',L'm',L'a',L',',L'y',L'a',L't',L'o',L'm',L'i',L')',L',',L'a',L'k',L'i',L't',L'a',L'(',
+	L'2',L'8',L':',L'a',L'k',L'i',L't',L'a',L',',L'd',L'a',L'i',L's',L'e',L'n',L',',L'f',L'u',L'j',L'i',L's',L'a',L't',L'o',L',',L'g',L'o',L'j',L'o',L'm',L'e',L',',L'h',L'a',L'c',L'h',L'i',L'r',L'o',L'g',L'a',L't',L'a',L',',L'h',L'a',L'p',L'p',L'o',L'u',L',',L'h',L'i',L'g',L'a',L's',L'h',L'i',L'n',L'a',L'r',L'u',L's',L'e',L',',L'h',L'o',L'n',L'j',L'o',L',',L'h',L'o',L'n',L'j',L'y',L'o',L',',L'i',L'k',L'a',L'w',L'a',L',',L'k',L'a',L'm',L'i',L'k',L'o',L'a',L'n',L'i',L',',L'k',L'a',L'm',L'i',L'o',L'k',
+	L'a',L',',L'k',L'a',L't',L'a',L'g',L'a',L'm',L'i',L',',L'k',L'a',L'z',L'u',L'n',L'o',L',',L'k',L'i',L't',L'a',L'a',L'k',L'i',L't',L'a',L',',L'k',L'o',L's',L'a',L'k',L'a',L',',L'k',L'y',L'o',L'w',L'a',L',',L'm',L'i',L's',L'a',L't',L'o',L',',L'm',L'i',L't',L'a',L'n',L'e',L',',L'm',L'o',L'r',L'i',L'y',L'o',L's',L'h',L'i',L',',L'n',L'i',L'k',L'a',L'h',L'o',L',',L'n',L'o',L's',L'h',L'i',L'r',L'o',L',',L'o',L'd',L'a',L't',L'e',L',',L'o',L'g',L'a',L',',L'o',L'g',L'a',L't',L'a',L',',L's',L'e',L'm',L'b',
+	L'o',L'k',L'u',L',',L'y',L'o',L'k',L'o',L't',L'e',L',',L'y',L'u',L'r',L'i',L'h',L'o',L'n',L'j',L'o',L')',L',',L'a',L'o',L'm',L'o',L'r',L'i',L'(',L'2',L'2',L':',L'a',L'o',L'm',L'o',L'r',L'i',L',',L'g',L'o',L'n',L'o',L'h',L'e',L',',L'h',L'a',L'c',L'h',L'i',L'n',L'o',L'h',L'e',L',',L'h',L'a',L's',L'h',L'i',L'k',L'a',L'm',L'i',L',',L'h',L'i',L'r',L'a',L'n',L'a',L'i',L',',L'h',L'i',L'r',L'o',L's',L'a',L'k',L'i',L',',L'i',L't',L'a',L'y',L'a',L'n',L'a',L'g',L'i',L',',L'k',L'u',L'r',L'o',L'i',L's',L'h',
+	L'i',L',',L'm',L'i',L's',L'a',L'w',L'a',L',',L'm',L'u',L't',L's',L'u',L',',L'n',L'a',L'k',L'a',L'd',L'o',L'm',L'a',L'r',L'i',L',',L'n',L'o',L'h',L'e',L'j',L'i',L',',L'o',L'i',L'r',L'a',L's',L'e',L',',L'o',L'w',L'a',L'n',L'i',L',',L'r',L'o',L'k',L'u',L'n',L'o',L'h',L'e',L',',L's',L'a',L'n',L'n',L'o',L'h',L'e',L',',L's',L'h',L'i',L'c',L'h',L'i',L'n',L'o',L'h',L'e',L',',L's',L'h',L'i',L'n',L'g',L'o',L',',L't',L'a',L'k',L'k',L'o',L',',L't',L'o',L'w',L'a',L'd',L'a',L',',L't',L's',L'u',L'g',L'a',L'r',
+	L'u',L',',L't',L's',L'u',L'r',L'u',L't',L'a',L')',L',',L'c',L'h',L'i',L'b',L'a',L'(',L'5',L'8',L':',L'a',L'b',L'i',L'k',L'o',L',',L'a',L's',L'a',L'h',L'i',L',',L'c',L'h',L'o',L'n',L'a',L'n',L',',L'c',L'h',L'o',L's',L'e',L'i',L',',L'c',L'h',L'o',L's',L'h',L'i',L',',L'c',L'h',L'u',L'o',L',',L'f',L'u',L'n',L'a',L'b',L'a',L's',L'h',L'i',L',',L'f',L'u',L't',L't',L's',L'u',L',',L'h',L'a',L'n',L'a',L'm',L'i',L'g',L'a',L'w',L'a',L',',L'i',L'c',L'h',L'i',L'h',L'a',L'r',L'a',L',',L'i',L'c',L'h',L'i',L'k',
+	L'a',L'w',L'a',L',',L'i',L'c',L'h',L'i',L'n',L'o',L'm',L'i',L'y',L'a',L',',L'i',L'n',L'z',L'a',L'i',L',',L'i',L's',L'u',L'm',L'i',L',',L'k',L'a',L'm',L'a',L'g',L'a',L'y',L'a',L',',L'k',L'a',L'm',L'o',L'g',L'a',L'w',L'a',L',',L'k',L'a',L's',L'h',L'i',L'w',L'a',L',',L'k',L'a',L't',L'o',L'r',L'i',L',',L'k',L'a',L't',L's',L'u',L'u',L'r',L'a',L',',L'k',L'i',L'm',L'i',L't',L's',L'u',L',',L'k',L'i',L's',L'a',L'r',L'a',L'z',L'u',L',',L'k',L'o',L'z',L'a',L'k',L'i',L',',L'k',L'u',L'j',L'u',L'k',L'u',L'r',
+	L'i',L',',L'k',L'y',L'o',L'n',L'a',L'n',L',',L'm',L'a',L't',L's',L'u',L'd',L'o',L',',L'm',L'i',L'd',L'o',L'r',L'i',L',',L'm',L'i',L'h',L'a',L'm',L'a',L',',L'm',L'i',L'n',L'a',L'm',L'i',L'b',L'o',L's',L'o',L',',L'm',L'o',L'b',L'a',L'r',L'a',L',',L'm',L'u',L't',L's',L'u',L'z',L'a',L'w',L'a',L',',L'n',L'a',L'g',L'a',L'r',L'a',L',',L'n',L'a',L'g',L'a',L'r',L'e',L'y',L'a',L'm',L'a',L',',L'n',L'a',L'r',L'a',L's',L'h',L'i',L'n',L'o',L',',L'n',L'a',L'r',L'i',L't',L'a',L',',L'n',L'o',L'd',L'a',L',',L'o',
+	L'a',L'm',L'i',L's',L'h',L'i',L'r',L'a',L's',L'a',L't',L'o',L',',L'o',L'm',L'i',L'g',L'a',L'w',L'a',L',',L'o',L'n',L'j',L'u',L'k',L'u',L',',L'o',L't',L'a',L'k',L'i',L',',L's',L'a',L'k',L'a',L'e',L',',L's',L'a',L'k',L'u',L'r',L'a',L',',L's',L'h',L'i',L'm',L'o',L'f',L'u',L's',L'a',L',',L's',L'h',L'i',L'r',L'a',L'k',L'o',L',',L's',L'h',L'i',L'r',L'o',L'i',L',',L's',L'h',L'i',L's',L'u',L'i',L',',L's',L'o',L'd',L'e',L'g',L'a',L'u',L'r',L'a',L',',L's',L'o',L's',L'a',L',',L't',L'a',L'k',L'o',L',',L't',
+	L'a',L't',L'e',L'y',L'a',L'm',L'a',L',',L't',L'o',L'g',L'a',L'n',L'e',L',',L't',L'o',L'h',L'n',L'o',L's',L'h',L'o',L',',L't',L'o',L'm',L'i',L's',L'a',L't',L'o',L',',L'u',L'r',L'a',L'y',L'a',L's',L'u',L',',L'y',L'a',L'c',L'h',L'i',L'm',L'a',L't',L'a',L',',L'y',L'a',L'c',L'h',L'i',L'y',L'o',L',',L'y',L'o',L'k',L'a',L'i',L'c',L'h',L'i',L'b',L'a',L',',L'y',L'o',L'k',L'o',L's',L'h',L'i',L'b',L'a',L'h',L'i',L'k',L'a',L'r',L'i',L',',L'y',L'o',L't',L's',L'u',L'k',L'a',L'i',L'd',L'o',L')',L',',L'e',L'h',
+	L'i',L'm',L'e',L'(',L'2',L'2',L':',L'a',L'i',L'n',L'a',L'n',L',',L'h',L'o',L'n',L'a',L'i',L',',L'i',L'k',L'a',L't',L'a',L',',L'i',L'm',L'a',L'b',L'a',L'r',L'i',L',',L'i',L'y',L'o',L',',L'k',L'a',L'm',L'i',L'j',L'i',L'm',L'a',L',',L'k',L'i',L'h',L'o',L'k',L'u',L',',L'k',L'u',L'm',L'a',L'k',L'o',L'g',L'e',L'n',L',',L'm',L'a',L's',L'a',L'k',L'i',L',',L'm',L'a',L't',L's',L'u',L'n',L'o',L',',L'm',L'a',L't',L's',L'u',L'y',L'a',L'm',L'a',L',',L'n',L'a',L'm',L'i',L'k',L'a',L't',L'a',L',',L'n',L'i',L'i',
+	L'h',L'a',L'm',L'a',L',',L'o',L'z',L'u',L',',L's',L'a',L'i',L'j',L'o',L',',L's',L'e',L'i',L'y',L'o',L',',L's',L'h',L'i',L'k',L'o',L'k',L'u',L'c',L'h',L'u',L'o',L',',L't',L'o',L'b',L'e',L',',L't',L'o',L'o',L'n',L',',L'u',L'c',L'h',L'i',L'k',L'o',L',',L'u',L'w',L'a',L'j',L'i',L'm',L'a',L',',L'y',L'a',L'w',L'a',L't',L'a',L'h',L'a',L'm',L'a',L')',L',',L'f',L'u',L'k',L'u',L'i',L'(',L'1',L'5',L':',L'e',L'c',L'h',L'i',L'z',L'e',L'n',L',',L'e',L'i',L'h',L'e',L'i',L'j',L'i',L',',L'f',L'u',L'k',L'u',L'i',
+	L',',L'i',L'k',L'e',L'd',L'a',L',',L'k',L'a',L't',L's',L'u',L'y',L'a',L'm',L'a',L',',L'm',L'i',L'h',L'a',L'm',L'a',L',',L'm',L'i',L'n',L'a',L'm',L'i',L'e',L'c',L'h',L'i',L'z',L'e',L'n',L',',L'o',L'b',L'a',L'm',L'a',L',',L'o',L'h',L'i',L',',L'o',L'n',L'o',L',',L's',L'a',L'b',L'a',L'e',L',',L's',L'a',L'k',L'a',L'i',L',',L't',L'a',L'k',L'a',L'h',L'a',L'm',L'a',L',',L't',L's',L'u',L'r',L'u',L'g',L'a',L',',L'w',L'a',L'k',L'a',L's',L'a',L')',L',',L'f',L'u',L'k',L'u',L'o',L'k',L'a',L'(',L'6',L'3',L':',
+	L'a',L's',L'h',L'i',L'y',L'a',L',',L'b',L'u',L'z',L'e',L'n',L',',L'c',L'h',L'i',L'k',L'u',L'g',L'o',L',',L'c',L'h',L'i',L'k',L'u',L'h',L'o',L',',L'c',L'h',L'i',L'k',L'u',L'j',L'o',L',',L'c',L'h',L'i',L'k',L'u',L's',L'h',L'i',L'n',L'o',L',',L'c',L'h',L'i',L'k',L'u',L'z',L'e',L'n',L',',L'c',L'h',L'u',L'o',L',',L'd',L'a',L'z',L'a',L'i',L'f',L'u',L',',L'f',L'u',L'k',L'u',L'c',L'h',L'i',L',',L'h',L'a',L'k',L'a',L't',L'a',L',',L'h',L'i',L'g',L'a',L's',L'h',L'i',L',',L'h',L'i',L'r',L'o',L'k',L'a',L'w',
+	L'a',L',',L'h',L'i',L's',L'a',L'y',L'a',L'm',L'a',L',',L'i',L'i',L'z',L'u',L'k',L'a',L',',L'i',L'n',L'a',L't',L's',L'u',L'k',L'i',L',',L'k',L'a',L'h',L'o',L',',L'k',L'a',L's',L'u',L'g',L'a',L',',L'k',L'a',L's',L'u',L'y',L'a',L',',L'k',L'a',L'w',L'a',L'r',L'a',L',',L'k',L'e',L'i',L's',L'e',L'n',L',',L'k',L'o',L'g',L'a',L',',L'k',L'u',L'r',L'a',L't',L'e',L',',L'k',L'u',L'r',L'o',L'g',L'i',L',',L'k',L'u',L'r',L'u',L'm',L'e',L',',L'm',L'i',L'n',L'a',L'm',L'i',L',',L'm',L'i',L'y',L'a',L'k',L'o',L',',
+	L'm',L'i',L'y',L'a',L'm',L'a',L',',L'm',L'i',L'y',L'a',L'w',L'a',L'k',L'a',L',',L'm',L'i',L'z',L'u',L'm',L'a',L'k',L'i',L',',L'm',L'u',L'n',L'a',L'k',L'a',L't',L'a',L',',L'n',L'a',L'k',L'a',L'g',L'a',L'w',L'a',L',',L'n',L'a',L'k',L'a',L'm',L'a',L',',L'n',L'i',L's',L'h',L'i',L',',L'n',L'o',L'g',L'a',L't',L'a',L',',L'o',L'g',L'o',L'r',L'i',L',',L'o',L'k',L'a',L'g',L'a',L'k',L'i',L',',L'o',L'k',L'a',L'w',L'a',L',',L'o',L'k',L'i',L',',L'o',L'm',L'u',L't',L'a',L',',L'o',L'n',L'g',L'a',L',',L'o',L'n',
+	L'o',L'j',L'o',L',',L'o',L't',L'o',L',',L's',L'a',L'i',L'g',L'a',L'w',L'a',L',',L's',L'a',L's',L'a',L'g',L'u',L'r',L'i',L',',L's',L'h',L'i',L'n',L'g',L'u',L',',L's',L'h',L'i',L'n',L'y',L'o',L's',L'h',L'i',L't',L'o',L'm',L'i',L',',L's',L'h',L'o',L'n',L'a',L'i',L',',L's',L'o',L'e',L'd',L'a',L',',L's',L'u',L'e',L',',L't',L'a',L'c',L'h',L'i',L'a',L'r',L'a',L'i',L',',L't',L'a',L'g',L'a',L'w',L'a',L',',L't',L'a',L'k',L'a',L't',L'a',L',',L't',L'o',L'h',L'o',L',',L't',L'o',L'y',L'o',L't',L's',L'u',L',',
+	L't',L's',L'u',L'i',L'k',L'i',L',',L'u',L'k',L'i',L'h',L'a',L',',L'u',L'm',L'i',L',',L'u',L's',L'u',L'i',L',',L'y',L'a',L'm',L'a',L'd',L'a',L',',L'y',L'a',L'm',L'e',L',',L'y',L'a',L'n',L'a',L'g',L'a',L'w',L'a',L',',L'y',L'u',L'k',L'u',L'h',L'a',L's',L'h',L'i',L')',L',',L'f',L'u',L'k',L'u',L's',L'h',L'i',L'm',L'a',L'(',L'5',L'1',L':',L'a',L'i',L'z',L'u',L'b',L'a',L'n',L'g',L'e',L',',L'a',L'i',L'z',L'u',L'm',L'i',L's',L'a',L't',L'o',L',',L'a',L'i',L'z',L'u',L'w',L'a',L'k',L'a',L'm',L'a',L't',L's',
+	L'u',L',',L'a',L's',L'a',L'k',L'a',L'w',L'a',L',',L'b',L'a',L'n',L'd',L'a',L'i',L',',L'd',L'a',L't',L'e',L',',L'f',L'u',L'k',L'u',L's',L'h',L'i',L'm',L'a',L',',L'f',L'u',L'r',L'u',L'd',L'o',L'n',L'o',L',',L'f',L'u',L't',L'a',L'b',L'a',L',',L'h',L'a',L'n',L'a',L'w',L'a',L',',L'h',L'i',L'g',L'a',L's',L'h',L'i',L',',L'h',L'i',L'r',L'a',L't',L'a',L',',L'h',L'i',L'r',L'o',L'n',L'o',L',',L'i',L'i',L't',L'a',L't',L'e',L',',L'i',L'n',L'a',L'w',L'a',L's',L'h',L'i',L'r',L'o',L',',L'i',L's',L'h',L'i',L'k',
+	L'a',L'w',L'a',L',',L'i',L'w',L'a',L'k',L'i',L',',L'i',L'z',L'u',L'm',L'i',L'z',L'a',L'k',L'i',L',',L'k',L'a',L'g',L'a',L'm',L'i',L'i',L's',L'h',L'i',L',',L'k',L'a',L'n',L'e',L'y',L'a',L'm',L'a',L',',L'k',L'a',L'w',L'a',L'm',L'a',L't',L'a',L',',L'k',L'i',L't',L'a',L'k',L'a',L't',L'a',L',',L'k',L'i',L't',L'a',L's',L'h',L'i',L'o',L'b',L'a',L'r',L'a',L',',L'k',L'o',L'o',L'r',L'i',L',',L'k',L'o',L'r',L'i',L'y',L'a',L'm',L'a',L',',L'k',L'u',L'n',L'i',L'm',L'i',L',',L'm',L'i',L'h',L'a',L'r',L'u',L',',
+	L'm',L'i',L's',L'h',L'i',L'm',L'a',L',',L'n',L'a',L'm',L'i',L'e',L',',L'n',L'a',L'n',L'g',L'o',L',',L'n',L'i',L's',L'h',L'i',L'a',L'i',L'z',L'u',L',',L'n',L'i',L's',L'h',L'i',L'g',L'o',L',',L'o',L'k',L'u',L'm',L'a',L',',L'o',L'm',L'o',L't',L'e',L'g',L'o',L',',L'o',L'n',L'o',L',',L'o',L't',L'a',L'm',L'a',L',',L's',L'a',L'm',L'e',L'g',L'a',L'w',L'a',L',',L's',L'h',L'i',L'm',L'o',L'g',L'o',L',',L's',L'h',L'i',L'r',L'a',L'k',L'a',L'w',L'a',L',',L's',L'h',L'o',L'w',L'a',L',',L's',L'o',L'm',L'a',L',',
+	L's',L'u',L'k',L'a',L'g',L'a',L'w',L'a',L',',L't',L'a',L'i',L's',L'h',L'i',L'n',L',',L't',L'a',L'm',L'a',L'k',L'a',L'w',L'a',L',',L't',L'a',L'n',L'a',L'g',L'u',L'r',L'a',L',',L't',L'e',L'n',L'e',L'i',L',',L'y',L'a',L'b',L'u',L'k',L'i',L',',L'y',L'a',L'm',L'a',L't',L'o',L',',L'y',L'a',L'm',L'a',L't',L's',L'u',L'r',L'i',L',',L'y',L'a',L'n',L'a',L'i',L'z',L'u',L',',L'y',L'u',L'g',L'a',L'w',L'a',L')',L',',L'g',L'i',L'f',L'u',L'(',L'3',L'8',L':',L'a',L'n',L'p',L'a',L'c',L'h',L'i',L',',L'e',L'n',L'a',
+	L',',L'g',L'i',L'f',L'u',L',',L'g',L'i',L'n',L'a',L'n',L',',L'g',L'o',L'd',L'o',L',',L'g',L'u',L'j',L'o',L',',L'h',L'a',L's',L'h',L'i',L'm',L'a',L',',L'h',L'i',L'c',L'h',L'i',L's',L'o',L',',L'h',L'i',L'd',L'a',L',',L'h',L'i',L'g',L'a',L's',L'h',L'i',L's',L'h',L'i',L'r',L'a',L'k',L'a',L'w',L'a',L',',L'i',L'b',L'i',L'g',L'a',L'w',L'a',L',',L'i',L'k',L'e',L'd',L'a',L',',L'k',L'a',L'k',L'a',L'm',L'i',L'g',L'a',L'h',L'a',L'r',L'a',L',',L'k',L'a',L'n',L'i',L',',L'k',L'a',L's',L'a',L'h',L'a',L'r',L'a',
+	L',',L'k',L'a',L's',L'a',L'm',L'a',L't',L's',L'u',L',',L'k',L'a',L'w',L'a',L'u',L'e',L',',L'k',L'i',L't',L'a',L'g',L'a',L't',L'a',L',',L'm',L'i',L'n',L'o',L',',L'm',L'i',L'n',L'o',L'k',L'a',L'm',L'o',L',',L'm',L'i',L't',L'a',L'k',L'e',L',',L'm',L'i',L'z',L'u',L'n',L'a',L'm',L'i',L',',L'm',L'o',L't',L'o',L's',L'u',L',',L'n',L'a',L'k',L'a',L't',L's',L'u',L'g',L'a',L'w',L'a',L',',L'o',L'g',L'a',L'k',L'i',L',',L's',L'a',L'k',L'a',L'h',L'o',L'g',L'i',L',',L's',L'e',L'k',L'i',L',',L's',L'e',L'k',L'i',
+	L'g',L'a',L'h',L'a',L'r',L'a',L',',L's',L'h',L'i',L'r',L'a',L'k',L'a',L'w',L'a',L',',L't',L'a',L'j',L'i',L'm',L'i',L',',L't',L'a',L'k',L'a',L'y',L'a',L'm',L'a',L',',L't',L'a',L'r',L'u',L'i',L',',L't',L'o',L'k',L'i',L',',L't',L'o',L'm',L'i',L'k',L'a',L',',L'w',L'a',L'n',L'o',L'u',L'c',L'h',L'i',L',',L'y',L'a',L'm',L'a',L'g',L'a',L't',L'a',L',',L'y',L'a',L'o',L't',L's',L'u',L',',L'y',L'o',L'r',L'o',L')',L',',L'g',L'u',L'n',L'm',L'a',L'(',L'3',L'6',L':',L'a',L'n',L'n',L'a',L'k',L'a',L',',L'c',L'h',
+	L'i',L'y',L'o',L'd',L'a',L',',L'f',L'u',L'j',L'i',L'o',L'k',L'a',L',',L'h',L'i',L'g',L'a',L's',L'h',L'i',L'a',L'g',L'a',L't',L's',L'u',L'm',L'a',L',',L'i',L's',L'e',L's',L'a',L'k',L'i',L',',L'i',L't',L'a',L'k',L'u',L'r',L'a',L',',L'k',L'a',L'n',L'n',L'a',L',',L'k',L'a',L'n',L'r',L'a',L',',L'k',L'a',L't',L'a',L's',L'h',L'i',L'n',L'a',L',',L'k',L'a',L'w',L'a',L'b',L'a',L',',L'k',L'i',L'r',L'y',L'u',L',',L'k',L'u',L's',L'a',L't',L's',L'u',L',',L'm',L'a',L'e',L'b',L'a',L's',L'h',L'i',L',',L'm',L'e',
+	L'i',L'w',L'a',L',',L'm',L'i',L'd',L'o',L'r',L'i',L',',L'm',L'i',L'n',L'a',L'k',L'a',L'm',L'i',L',',L'n',L'a',L'g',L'a',L'n',L'o',L'h',L'a',L'r',L'a',L',',L'n',L'a',L'k',L'a',L'n',L'o',L'j',L'o',L',',L'n',L'a',L'n',L'm',L'o',L'k',L'u',L',',L'n',L'u',L'm',L'a',L't',L'a',L',',L'o',L'i',L'z',L'u',L'm',L'i',L',',L'o',L'r',L'a',L',',L'o',L't',L'a',L',',L's',L'h',L'i',L'b',L'u',L'k',L'a',L'w',L'a',L',',L's',L'h',L'i',L'm',L'o',L'n',L'i',L't',L'a',L',',L's',L'h',L'i',L'n',L't',L'o',L',',L's',L'h',L'o',
+	L'w',L'a',L',',L't',L'a',L'k',L'a',L's',L'a',L'k',L'i',L',',L't',L'a',L'k',L'a',L'y',L'a',L'm',L'a',L',',L't',L'a',L'm',L'a',L'm',L'u',L'r',L'a',L',',L't',L'a',L't',L'e',L'b',L'a',L'y',L'a',L's',L'h',L'i',L',',L't',L'o',L'm',L'i',L'o',L'k',L'a',L',',L't',L's',L'u',L'k',L'i',L'y',L'o',L'n',L'o',L',',L't',L's',L'u',L'm',L'a',L'g',L'o',L'i',L',',L'u',L'e',L'n',L'o',L',',L'y',L'o',L's',L'h',L'i',L'o',L'k',L'a',L')',L',',L'h',L'i',L'r',L'o',L's',L'h',L'i',L'm',L'a',L'(',L'2',L'5',L':',L'a',L's',L'a',
+	L'm',L'i',L'n',L'a',L'm',L'i',L',',L'd',L'a',L'i',L'w',L'a',L',',L'e',L't',L'a',L'j',L'i',L'm',L'a',L',',L'f',L'u',L'c',L'h',L'u',L',',L'f',L'u',L'k',L'u',L'y',L'a',L'm',L'a',L',',L'h',L'a',L't',L's',L'u',L'k',L'a',L'i',L'c',L'h',L'i',L',',L'h',L'i',L'g',L'a',L's',L'h',L'i',L'h',L'i',L'r',L'o',L's',L'h',L'i',L'm',L'a',L',',L'h',L'o',L'n',L'g',L'o',L',',L'j',L'i',L'n',L's',L'e',L'k',L'i',L'k',L'o',L'g',L'e',L'n',L',',L'k',L'a',L'i',L't',L'a',L',',L'k',L'u',L'i',L',',L'k',L'u',L'm',L'a',L'n',L'o',
+	L',',L'k',L'u',L'r',L'e',L',',L'm',L'i',L'h',L'a',L'r',L'a',L',',L'm',L'i',L'y',L'o',L's',L'h',L'i',L',',L'n',L'a',L'k',L'a',L',',L'o',L'n',L'o',L'm',L'i',L'c',L'h',L'i',L',',L'o',L's',L'a',L'k',L'i',L'k',L'a',L'm',L'i',L'j',L'i',L'm',L'a',L',',L'o',L't',L'a',L'k',L'e',L',',L's',L'a',L'k',L'a',L',',L's',L'e',L'r',L'a',L',',L's',L'e',L'r',L'a',L'n',L'i',L's',L'h',L'i',L',',L's',L'h',L'i',L'n',L'i',L'c',L'h',L'i',L',',L's',L'h',L'o',L'b',L'a',L'r',L'a',L',',L't',L'a',L'k',L'e',L'h',L'a',L'r',L'a',
+	L')',L',',L'h',L'o',L'k',L'k',L'a',L'i',L'd',L'o',L'(',L'1',L'4',L'2',L':',L'a',L'b',L'a',L's',L'h',L'i',L'r',L'i',L',',L'a',L'b',L'i',L'r',L'a',L',',L'a',L'i',L'b',L'e',L't',L's',L'u',L',',L'a',L'k',L'a',L'b',L'i',L'r',L'a',L',',L'a',L'k',L'k',L'e',L's',L'h',L'i',L',',L'a',L's',L'a',L'h',L'i',L'k',L'a',L'w',L'a',L',',L'a',L's',L'h',L'i',L'b',L'e',L't',L's',L'u',L',',L'a',L's',L'h',L'o',L'r',L'o',L',',L'a',L's',L's',L'a',L'b',L'u',L',',L'a',L't',L's',L'u',L'm',L'a',L',',L'b',L'i',L'b',L'a',L'i',
+	L',',L'b',L'i',L'e',L'i',L',',L'b',L'i',L'f',L'u',L'k',L'a',L',',L'b',L'i',L'h',L'o',L'r',L'o',L',',L'b',L'i',L'r',L'a',L't',L'o',L'r',L'i',L',',L'c',L'h',L'i',L'p',L'p',L'u',L'b',L'e',L't',L's',L'u',L',',L'c',L'h',L'i',L't',L'o',L's',L'e',L',',L'd',L'a',L't',L'e',L',',L'e',L'b',L'e',L't',L's',L'u',L',',L'e',L'm',L'b',L'e',L't',L's',L'u',L',',L'e',L'n',L'i',L'w',L'a',L',',L'e',L'r',L'i',L'm',L'o',L',',L'e',L's',L'a',L'n',L',',L'e',L's',L'a',L's',L'h',L'i',L',',L'f',L'u',L'k',L'a',L'g',L'a',L'w',
+	L'a',L',',L'f',L'u',L'k',L'u',L's',L'h',L'i',L'm',L'a',L',',L'f',L'u',L'r',L'a',L'n',L'o',L',',L'f',L'u',L'r',L'u',L'b',L'i',L'r',L'a',L',',L'h',L'a',L'b',L'o',L'r',L'o',L',',L'h',L'a',L'k',L'o',L'd',L'a',L't',L'e',L',',L'h',L'a',L'm',L'a',L't',L'o',L'n',L'b',L'e',L't',L's',L'u',L',',L'h',L'i',L'd',L'a',L'k',L'a',L',',L'h',L'i',L'g',L'a',L's',L'h',L'i',L'k',L'a',L'g',L'u',L'r',L'a',L',',L'h',L'i',L'g',L'a',L's',L'h',L'i',L'k',L'a',L'w',L'a',L',',L'h',L'i',L'r',L'o',L'o',L',',L'h',L'o',L'k',L'u',
+	L'r',L'y',L'u',L',',L'h',L'o',L'k',L'u',L't',L'o',L',',L'h',L'o',L'n',L'b',L'e',L't',L's',L'u',L',',L'h',L'o',L'r',L'o',L'k',L'a',L'n',L'a',L'i',L',',L'h',L'o',L'r',L'o',L'n',L'o',L'b',L'e',L',',L'i',L'k',L'e',L'd',L'a',L',',L'i',L'm',L'a',L'k',L'a',L'n',L'e',L',',L'i',L's',L'h',L'i',L'k',L'a',L'r',L'i',L',',L'i',L'w',L'a',L'm',L'i',L'z',L'a',L'w',L'a',L',',L'i',L'w',L'a',L'n',L'a',L'i',L',',L'k',L'a',L'm',L'i',L'f',L'u',L'r',L'a',L'n',L'o',L',',L'k',L'a',L'm',L'i',L'k',L'a',L'w',L'a',L',',L'k',
+	L'a',L'm',L'i',L's',L'h',L'i',L'h',L'o',L'r',L'o',L',',L'k',L'a',L'm',L'i',L's',L'u',L'n',L'a',L'g',L'a',L'w',L'a',L',',L'k',L'a',L'm',L'o',L'e',L'n',L'a',L'i',L',',L'k',L'a',L'y',L'a',L'b',L'e',L',',L'k',L'e',L'm',L'b',L'u',L'c',L'h',L'i',L',',L'k',L'i',L'k',L'o',L'n',L'a',L'i',L',',L'k',L'i',L'm',L'o',L'b',L'e',L't',L's',L'u',L',',L'k',L'i',L't',L'a',L'h',L'i',L'r',L'o',L's',L'h',L'i',L'm',L'a',L',',L'k',L'i',L't',L'a',L'm',L'i',L',',L'k',L'i',L'y',L'o',L's',L'a',L't',L'o',L',',L'k',L'o',L's',
+	L'h',L'i',L'm',L'i',L'z',L'u',L',',L'k',L'u',L'n',L'n',L'e',L'p',L'p',L'u',L',',L'k',L'u',L'r',L'i',L'y',L'a',L'm',L'a',L',',L'k',L'u',L'r',L'o',L'm',L'a',L't',L's',L'u',L'n',L'a',L'i',L',',L'k',L'u',L's',L'h',L'i',L'r',L'o',L',',L'k',L'u',L't',L'c',L'h',L'a',L'n',L',',L'k',L'y',L'o',L'w',L'a',L',',L'm',L'a',L's',L'h',L'i',L'k',L'e',L',',L'm',L'a',L't',L's',L'u',L'm',L'a',L'e',L',',L'm',L'i',L'k',L'a',L's',L'a',L',',L'm',L'i',L'n',L'a',L'm',L'i',L'f',L'u',L'r',L'a',L'n',L'o',L',',L'm',L'o',L'm',
+	L'b',L'e',L't',L's',L'u',L',',L'm',L'o',L's',L'e',L'u',L's',L'h',L'i',L',',L'm',L'u',L'k',L'a',L'w',L'a',L',',L'm',L'u',L'r',L'o',L'r',L'a',L'n',L',',L'n',L'a',L'i',L'e',L',',L'n',L'a',L'k',L'a',L'g',L'a',L'w',L'a',L',',L'n',L'a',L'k',L'a',L's',L'a',L't',L's',L'u',L'n',L'a',L'i',L',',L'n',L'a',L'k',L'a',L't',L'o',L'm',L'b',L'e',L't',L's',L'u',L',',L'n',L'a',L'n',L'a',L'e',L',',L'n',L'a',L'n',L'p',L'o',L'r',L'o',L',',L'n',L'a',L'y',L'o',L'r',L'o',L',',L'n',L'e',L'm',L'u',L'r',L'o',L',',L'n',L'i',
+	L'i',L'k',L'a',L'p',L'p',L'u',L',',L'n',L'i',L'k',L'i',L',',L'n',L'i',L's',L'h',L'i',L'o',L'k',L'o',L'p',L'p',L'e',L',',L'n',L'o',L'b',L'o',L'r',L'i',L'b',L'e',L't',L's',L'u',L',',L'n',L'u',L'm',L'a',L't',L'a',L',',L'o',L'b',L'i',L'h',L'i',L'r',L'o',L',',L'o',L'b',L'i',L'r',L'a',L',',L'o',L'k',L'e',L't',L'o',L',',L'o',L'k',L'o',L'p',L'p',L'e',L',',L'o',L't',L'a',L'r',L'u',L',',L'o',L't',L'o',L'b',L'e',L',',L'o',L't',L'o',L'f',L'u',L'k',L'e',L',',L'o',L't',L'o',L'i',L'n',L'e',L'p',L'p',L'u',L',',
+	L'o',L'u',L'm',L'u',L',',L'o',L'z',L'o',L'r',L'a',L',',L'p',L'i',L'p',L'p',L'u',L',',L'r',L'a',L'n',L'k',L'o',L's',L'h',L'i',L',',L'r',L'e',L'b',L'u',L'n',L',',L'r',L'i',L'k',L'u',L'b',L'e',L't',L's',L'u',L',',L'r',L'i',L's',L'h',L'i',L'r',L'i',L',',L'r',L'i',L's',L'h',L'i',L'r',L'i',L'f',L'u',L'j',L'i',L',',L's',L'a',L'r',L'o',L'm',L'a',L',',L's',L'a',L'r',L'u',L'f',L'u',L't',L's',L'u',L',',L's',L'h',L'a',L'k',L'o',L't',L'a',L'n',L',',L's',L'h',L'a',L'r',L'i',L',',L's',L'h',L'i',L'b',L'e',L'c',
+	L'h',L'a',L',',L's',L'h',L'i',L'b',L'e',L't',L's',L'u',L',',L's',L'h',L'i',L'k',L'a',L'b',L'e',L',',L's',L'h',L'i',L'k',L'a',L'o',L'i',L',',L's',L'h',L'i',L'm',L'a',L'm',L'a',L'k',L'i',L',',L's',L'h',L'i',L'm',L'i',L'z',L'u',L',',L's',L'h',L'i',L'm',L'o',L'k',L'a',L'w',L'a',L',',L's',L'h',L'i',L'n',L's',L'h',L'i',L'n',L'o',L't',L's',L'u',L',',L's',L'h',L'i',L'n',L't',L'o',L'k',L'u',L',',L's',L'h',L'i',L'r',L'a',L'n',L'u',L'k',L'a',L',',L's',L'h',L'i',L'r',L'a',L'o',L'i',L',',L's',L'h',L'i',L'r',
+	L'i',L'u',L'c',L'h',L'i',L',',L's',L'o',L'b',L'e',L't',L's',L'u',L',',L's',L'u',L'n',L'a',L'g',L'a',L'w',L'a',L',',L't',L'a',L'i',L'k',L'i',L',',L't',L'a',L'k',L'a',L's',L'u',L',',L't',L'a',L'k',L'i',L'k',L'a',L'w',L'a',L',',L't',L'a',L'k',L'i',L'n',L'o',L'u',L'e',L',',L't',L'e',L's',L'h',L'i',L'k',L'a',L'g',L'a',L',',L't',L'o',L'b',L'e',L't',L's',L'u',L',',L't',L'o',L'h',L'm',L'a',L',',L't',L'o',L'm',L'a',L'k',L'o',L'm',L'a',L'i',L',',L't',L'o',L'm',L'a',L'r',L'i',L',',L't',L'o',L'y',L'a',L',',
+	L't',L'o',L'y',L'a',L'k',L'o',L',',L't',L'o',L'y',L'o',L't',L'o',L'm',L'i',L',',L't',L'o',L'y',L'o',L'u',L'r',L'a',L',',L't',L's',L'u',L'b',L'e',L't',L's',L'u',L',',L't',L's',L'u',L'k',L'i',L'g',L'a',L't',L'a',L',',L'u',L'r',L'a',L'k',L'a',L'w',L'a',L',',L'u',L'r',L'a',L'u',L's',L'u',L',',L'u',L'r',L'y',L'u',L',',L'u',L't',L'a',L's',L'h',L'i',L'n',L'a',L'i',L',',L'w',L'a',L'k',L'k',L'a',L'n',L'a',L'i',L',',L'w',L'a',L's',L's',L'a',L'm',L'u',L',',L'y',L'a',L'k',L'u',L'm',L'o',L',',L'y',L'o',L'i',
+	L'c',L'h',L'i',L')',L',',L'h',L'y',L'o',L'g',L'o',L'(',L'4',L'6',L':',L'a',L'i',L'o',L'i',L',',L'a',L'k',L'a',L's',L'h',L'i',L',',L'a',L'k',L'o',L',',L'a',L'm',L'a',L'g',L'a',L's',L'a',L'k',L'i',L',',L'a',L'o',L'g',L'a',L'k',L'i',L',',L'a',L's',L'a',L'g',L'o',L',',L'a',L's',L'h',L'i',L'y',L'a',L',',L'a',L'w',L'a',L'j',L'i',L',',L'f',L'u',L'k',L'u',L's',L'a',L'k',L'i',L',',L'g',L'o',L's',L'h',L'i',L'k',L'i',L',',L'h',L'a',L'r',L'i',L'm',L'a',L',',L'h',L'i',L'm',L'e',L'j',L'i',L',',L'i',L'c',L'h',
+	L'i',L'k',L'a',L'w',L'a',L',',L'i',L'n',L'a',L'g',L'a',L'w',L'a',L',',L'i',L't',L'a',L'm',L'i',L',',L'k',L'a',L'k',L'o',L'g',L'a',L'w',L'a',L',',L'k',L'a',L'm',L'i',L'g',L'o',L'r',L'i',L',',L'k',L'a',L'm',L'i',L'k',L'a',L'w',L'a',L',',L'k',L'a',L's',L'a',L'i',L',',L'k',L'a',L's',L'u',L'g',L'a',L',',L'k',L'a',L'w',L'a',L'n',L'i',L's',L'h',L'i',L',',L'm',L'i',L'k',L'i',L',',L'm',L'i',L'n',L'a',L'm',L'i',L'a',L'w',L'a',L'j',L'i',L',',L'n',L'i',L's',L'h',L'i',L'n',L'o',L'm',L'i',L'y',L'a',L',',L'n',
+	L'i',L's',L'h',L'i',L'w',L'a',L'k',L'i',L',',L'o',L'n',L'o',L',',L's',L'a',L'n',L'd',L'a',L',',L's',L'a',L'n',L'n',L'a',L'n',L',',L's',L'a',L's',L'a',L'y',L'a',L'm',L'a',L',',L's',L'a',L'y',L'o',L',',L's',L'h',L'i',L'n',L'g',L'u',L',',L's',L'h',L'i',L'n',L'o',L'n',L's',L'e',L'n',L',',L's',L'h',L'i',L's',L'o',L',',L's',L'u',L'm',L'o',L't',L'o',L',',L't',L'a',L'i',L's',L'h',L'i',L',',L't',L'a',L'k',L'a',L',',L't',L'a',L'k',L'a',L'r',L'a',L'z',L'u',L'k',L'a',L',',L't',L'a',L'k',L'a',L's',L'a',L'g',
+	L'o',L',',L't',L'a',L'k',L'i',L'n',L'o',L',',L't',L'a',L'm',L'b',L'a',L',',L't',L'a',L't',L's',L'u',L'n',L'o',L',',L't',L'o',L'y',L'o',L'o',L'k',L'a',L',',L'y',L'a',L'b',L'u',L',',L'y',L'a',L's',L'h',L'i',L'r',L'o',L',',L'y',L'o',L'k',L'a',L',',L'y',L'o',L'k',L'a',L'w',L'a',L')',L',',L'i',L'b',L'a',L'r',L'a',L'k',L'i',L'(',L'5',L'1',L':',L'a',L'm',L'i',L',',L'a',L's',L'a',L'h',L'i',L',',L'b',L'a',L'n',L'd',L'o',L',',L'c',L'h',L'i',L'k',L'u',L's',L'e',L'i',L',',L'd',L'a',L'i',L'g',L'o',L',',L'f',
+	L'u',L'j',L'i',L's',L'h',L'i',L'r',L'o',L',',L'h',L'i',L't',L'a',L'c',L'h',L'i',L',',L'h',L'i',L't',L'a',L'c',L'h',L'i',L'n',L'a',L'k',L'a',L',',L'h',L'i',L't',L'a',L'c',L'h',L'i',L'o',L'm',L'i',L'y',L'a',L',',L'h',L'i',L't',L'a',L'c',L'h',L'i',L'o',L't',L'a',L',',L'i',L'b',L'a',L'r',L'a',L'k',L'i',L',',L'i',L'n',L'a',L',',L'i',L'n',L'a',L's',L'h',L'i',L'k',L'i',L',',L'i',L't',L'a',L'k',L'o',L',',L'i',L'w',L'a',L'm',L'a',L',',L'j',L'o',L's',L'o',L',',L'k',L'a',L'm',L'i',L's',L'u',L',',L'k',L'a',
+	L's',L'a',L'm',L'a',L',',L'k',L'a',L's',L'h',L'i',L'm',L'a',L',',L'k',L'a',L's',L'u',L'm',L'i',L'g',L'a',L'u',L'r',L'a',L',',L'k',L'o',L'g',L'a',L',',L'm',L'i',L'h',L'o',L',',L'm',L'i',L't',L'o',L',',L'm',L'o',L'r',L'i',L'y',L'a',L',',L'n',L'a',L'k',L'a',L',',L'n',L'a',L'm',L'e',L'g',L'a',L't',L'a',L',',L'o',L'a',L'r',L'a',L'i',L',',L'o',L'g',L'a',L'w',L'a',L',',L'o',L'm',L'i',L't',L'a',L'm',L'a',L',',L'r',L'y',L'u',L'g',L'a',L's',L'a',L'k',L'i',L',',L's',L'a',L'k',L'a',L'i',L',',L's',L'a',L'k',
+	L'u',L'r',L'a',L'g',L'a',L'w',L'a',L',',L's',L'h',L'i',L'm',L'o',L'd',L'a',L't',L'e',L',',L's',L'h',L'i',L'm',L'o',L't',L's',L'u',L'm',L'a',L',',L's',L'h',L'i',L'r',L'o',L's',L'a',L't',L'o',L',',L's',L'o',L'w',L'a',L',',L's',L'u',L'i',L'f',L'u',L',',L't',L'a',L'k',L'a',L'h',L'a',L'g',L'i',L',',L't',L'a',L'm',L'a',L't',L's',L'u',L'k',L'u',L'r',L'i',L',',L't',L'o',L'k',L'a',L'i',L',',L't',L'o',L'm',L'o',L'b',L'e',L',',L't',L'o',L'n',L'e',L',',L't',L'o',L'r',L'i',L'd',L'e',L',',L't',L's',L'u',L'c',
+	L'h',L'i',L'u',L'r',L'a',L',',L't',L's',L'u',L'k',L'u',L'b',L'a',L',',L'u',L'c',L'h',L'i',L'h',L'a',L'r',L'a',L',',L'u',L's',L'h',L'i',L'k',L'u',L',',L'y',L'a',L'c',L'h',L'i',L'y',L'o',L',',L'y',L'a',L'm',L'a',L'g',L'a',L't',L'a',L',',L'y',L'a',L'w',L'a',L'r',L'a',L',',L'y',L'u',L'k',L'i',L')',L',',L'i',L's',L'h',L'i',L'k',L'a',L'w',L'a',L'(',L'1',L'9',L':',L'a',L'n',L'a',L'm',L'i',L'z',L'u',L',',L'h',L'a',L'k',L'u',L'i',L',',L'h',L'a',L'k',L'u',L's',L'a',L'n',L',',L'k',L'a',L'g',L'a',L',',L'k',
+	L'a',L'h',L'o',L'k',L'u',L',',L'k',L'a',L'n',L'a',L'z',L'a',L'w',L'a',L',',L'k',L'a',L'w',L'a',L'k',L'i',L't',L'a',L',',L'k',L'o',L'm',L'a',L't',L's',L'u',L',',L'n',L'a',L'k',L'a',L'n',L'o',L't',L'o',L',',L'n',L'a',L'n',L'a',L'o',L',',L'n',L'o',L'm',L'i',L',',L'n',L'o',L'n',L'o',L'i',L'c',L'h',L'i',L',',L'n',L'o',L't',L'o',L',',L's',L'h',L'i',L'k',L'a',L',',L's',L'u',L'z',L'u',L',',L't',L's',L'u',L'b',L'a',L't',L'a',L',',L't',L's',L'u',L'r',L'u',L'g',L'i',L',',L'u',L'c',L'h',L'i',L'n',L'a',L'd',
+	L'a',L',',L'w',L'a',L'j',L'i',L'm',L'a',L')',L',',L'i',L'w',L'a',L't',L'e',L'(',L'3',L'5',L':',L'f',L'u',L'd',L'a',L'i',L',',L'f',L'u',L'j',L'i',L's',L'a',L'w',L'a',L',',L'h',L'a',L'n',L'a',L'm',L'a',L'k',L'i',L',',L'h',L'i',L'r',L'a',L'i',L'z',L'u',L'm',L'i',L',',L'h',L'i',L'r',L'o',L'n',L'o',L',',L'i',L'c',L'h',L'i',L'n',L'o',L'h',L'e',L',',L'i',L'c',L'h',L'i',L'n',L'o',L's',L'e',L'k',L'i',L',',L'i',L'w',L'a',L'i',L'z',L'u',L'm',L'i',L',',L'i',L'w',L'a',L't',L'e',L',',L'j',L'o',L'b',L'o',L'j',
+	L'i',L',',L'k',L'a',L'm',L'a',L'i',L's',L'h',L'i',L',',L'k',L'a',L'n',L'e',L'g',L'a',L's',L'a',L'k',L'i',L',',L'k',L'a',L'r',L'u',L'm',L'a',L'i',L',',L'k',L'a',L'w',L'a',L'i',L',',L'k',L'i',L't',L'a',L'k',L'a',L'm',L'i',L',',L'k',L'u',L'j',L'i',L',',L'k',L'u',L'n',L'o',L'h',L'e',L',',L'k',L'u',L'z',L'u',L'm',L'a',L'k',L'i',L',',L'm',L'i',L'y',L'a',L'k',L'o',L',',L'm',L'i',L'z',L'u',L's',L'a',L'w',L'a',L',',L'm',L'o',L'r',L'i',L'o',L'k',L'a',L',',L'n',L'i',L'n',L'o',L'h',L'e',L',',L'n',L'o',L'd',
+	L'a',L',',L'o',L'f',L'u',L'n',L'a',L't',L'o',L',',L'o',L's',L'h',L'u',L',',L'o',L't',L's',L'u',L'c',L'h',L'i',L',',L'r',L'i',L'k',L'u',L'z',L'e',L'n',L't',L'a',L'k',L'a',L't',L'a',L',',L's',L'h',L'i',L'w',L'a',L',',L's',L'h',L'i',L'z',L'u',L'k',L'u',L'i',L's',L'h',L'i',L',',L's',L'u',L'm',L'i',L't',L'a',L',',L't',L'a',L'k',L'i',L'z',L'a',L'w',L'a',L',',L't',L'a',L'n',L'o',L'h',L'a',L't',L'a',L',',L't',L'o',L'n',L'o',L',',L'y',L'a',L'h',L'a',L'b',L'a',L',',L'y',L'a',L'm',L'a',L'd',L'a',L')',L',',
+	L'k',L'a',L'g',L'a',L'w',L'a',L'(',L'1',L'5',L':',L'a',L'y',L'a',L'g',L'a',L'w',L'a',L',',L'h',L'i',L'g',L'a',L's',L'h',L'i',L'k',L'a',L'g',L'a',L'w',L'a',L',',L'k',L'a',L'n',L'o',L'n',L'j',L'i',L',',L'k',L'o',L't',L'o',L'h',L'i',L'r',L'a',L',',L'm',L'a',L'n',L'n',L'o',L',',L'm',L'a',L'r',L'u',L'g',L'a',L'm',L'e',L',',L'm',L'i',L't',L'o',L'y',L'o',L',',L'n',L'a',L'o',L's',L'h',L'i',L'm',L'a',L',',L's',L'a',L'n',L'u',L'k',L'i',L',',L't',L'a',L'd',L'o',L't',L's',L'u',L',',L't',L'a',L'k',L'a',L'm',
+	L'a',L't',L's',L'u',L',',L't',L'o',L'n',L'o',L's',L'h',L'o',L',',L'u',L'c',L'h',L'i',L'n',L'o',L'm',L'i',L',',L'u',L't',L'a',L'z',L'u',L',',L'z',L'e',L'n',L't',L's',L'u',L'j',L'i',L')',L',',L'k',L'a',L'g',L'o',L's',L'h',L'i',L'm',L'a',L'(',L'2',L'0',L':',L'a',L'k',L'u',L'n',L'e',L',',L'a',L'm',L'a',L'm',L'i',L',',L'h',L'i',L'o',L'k',L'i',L',',L'i',L's',L'a',L',',L'i',L's',L'e',L'n',L',',L'i',L'z',L'u',L'm',L'i',L',',L'k',L'a',L'g',L'o',L's',L'h',L'i',L'm',L'a',L',',L'k',L'a',L'n',L'o',L'y',L'a',
+	L',',L'k',L'a',L'w',L'a',L'n',L'a',L'b',L'e',L',',L'k',L'i',L'n',L'k',L'o',L',',L'k',L'o',L'u',L'y',L'a',L'm',L'a',L',',L'm',L'a',L'k',L'u',L'r',L'a',L'z',L'a',L'k',L'i',L',',L'm',L'a',L't',L's',L'u',L'm',L'o',L't',L'o',L',',L'm',L'i',L'n',L'a',L'm',L'i',L't',L'a',L'n',L'e',L',',L'n',L'a',L'k',L'a',L't',L'a',L'n',L'e',L',',L'n',L'i',L's',L'h',L'i',L'n',L'o',L'o',L'm',L'o',L't',L'e',L',',L's',L'a',L't',L's',L'u',L'm',L'a',L's',L'e',L'n',L'd',L'a',L'i',L',',L's',L'o',L'o',L',',L't',L'a',L'r',L'u',
+	L'm',L'i',L'z',L'u',L',',L'y',L'u',L's',L'u',L'i',L')',L',',L'k',L'a',L'n',L'a',L'g',L'a',L'w',L'a',L'(',L'3',L'0',L':',L'a',L'i',L'k',L'a',L'w',L'a',L',',L'a',L't',L's',L'u',L'g',L'i',L',',L'a',L'y',L'a',L's',L'e',L',',L'c',L'h',L'i',L'g',L'a',L's',L'a',L'k',L'i',L',',L'e',L'b',L'i',L'n',L'a',L',',L'f',L'u',L'j',L'i',L's',L'a',L'w',L'a',L',',L'h',L'a',L'd',L'a',L'n',L'o',L',',L'h',L'a',L'k',L'o',L'n',L'e',L',',L'h',L'i',L'r',L'a',L't',L's',L'u',L'k',L'a',L',',L'i',L's',L'e',L'h',L'a',L'r',L'a',
+	L',',L'k',L'a',L'i',L's',L'e',L'i',L',',L'k',L'a',L'm',L'a',L'k',L'u',L'r',L'a',L',',L'k',L'i',L'y',L'o',L'k',L'a',L'w',L'a',L',',L'm',L'a',L't',L's',L'u',L'd',L'a',L',',L'm',L'i',L'n',L'a',L'm',L'i',L'a',L's',L'h',L'i',L'g',L'a',L'r',L'a',L',',L'm',L'i',L'u',L'r',L'a',L',',L'n',L'a',L'k',L'a',L'i',L',',L'n',L'i',L'n',L'o',L'm',L'i',L'y',L'a',L',',L'o',L'd',L'a',L'w',L'a',L'r',L'a',L',',L'o',L'i',L',',L'o',L'i',L's',L'o',L',',L's',L'a',L'g',L'a',L'm',L'i',L'h',L'a',L'r',L'a',L',',L's',L'a',L'm',
+	L'u',L'k',L'a',L'w',L'a',L',',L't',L's',L'u',L'k',L'u',L'i',L',',L'y',L'a',L'm',L'a',L'k',L'i',L't',L'a',L',',L'y',L'a',L'm',L'a',L't',L'o',L',',L'y',L'o',L'k',L'o',L's',L'u',L'k',L'a',L',',L'y',L'u',L'g',L'a',L'w',L'a',L'r',L'a',L',',L'z',L'a',L'm',L'a',L',',L'z',L'u',L's',L'h',L'i',L')',L',',L'k',L'o',L'c',L'h',L'i',L'(',L'3',L'1',L':',L'a',L'k',L'i',L',',L'g',L'e',L'i',L's',L'e',L'i',L',',L'h',L'i',L'd',L'a',L'k',L'a',L',',L'h',L'i',L'g',L'a',L's',L'h',L'i',L't',L's',L'u',L'n',L'o',L',',L'i',
+	L'n',L'o',L',',L'k',L'a',L'g',L'a',L'm',L'i',L',',L'k',L'a',L'm',L'i',L',',L'k',L'i',L't',L'a',L'g',L'a',L'w',L'a',L',',L'k',L'o',L'c',L'h',L'i',L',',L'm',L'i',L'h',L'a',L'r',L'a',L',',L'm',L'o',L't',L'o',L'y',L'a',L'm',L'a',L',',L'm',L'u',L'r',L'o',L't',L'o',L',',L'n',L'a',L'h',L'a',L'r',L'i',L',',L'n',L'a',L'k',L'a',L'm',L'u',L'r',L'a',L',',L'n',L'a',L'n',L'k',L'o',L'k',L'u',L',',L'n',L'i',L's',L'h',L'i',L't',L'o',L's',L'a',L',',L'n',L'i',L'y',L'o',L'd',L'o',L'g',L'a',L'w',L'a',L',',L'o',L'c',
+	L'h',L'i',L',',L'o',L'k',L'a',L'w',L'a',L',',L'o',L't',L'o',L'y',L'o',L',',L'o',L't',L's',L'u',L'k',L'i',L',',L's',L'a',L'k',L'a',L'w',L'a',L',',L's',L'u',L'k',L'u',L'm',L'o',L',',L's',L'u',L's',L'a',L'k',L'i',L',',L't',L'o',L's',L'a',L',',L't',L'o',L's',L'a',L's',L'h',L'i',L'm',L'i',L'z',L'u',L',',L't',L'o',L'y',L'o',L',',L't',L's',L'u',L'n',L'o',L',',L'u',L'm',L'a',L'j',L'i',L',',L'y',L'a',L's',L'u',L'd',L'a',L',',L'y',L'u',L's',L'u',L'h',L'a',L'r',L'a',L')',L',',L'k',L'u',L'm',L'a',L'm',L'o',
+	L't',L'o',L'(',L'2',L'6',L':',L'a',L'm',L'a',L'k',L'u',L's',L'a',L',',L'a',L'r',L'a',L'o',L',',L'a',L's',L'o',L',',L'c',L'h',L'o',L'y',L'o',L',',L'g',L'y',L'o',L'k',L'u',L't',L'o',L',',L'h',L'i',L't',L'o',L'y',L'o',L's',L'h',L'i',L',',L'k',L'a',L'm',L'i',L'a',L'm',L'a',L'k',L'u',L's',L'a',L',',L'k',L'a',L's',L'h',L'i',L'm',L'a',L',',L'k',L'i',L'k',L'u',L'c',L'h',L'i',L',',L'k',L'o',L's',L'a',L',',L'k',L'u',L'm',L'a',L'm',L'o',L't',L'o',L',',L'm',L'a',L's',L'h',L'i',L'k',L'i',L',',L'm',L'i',L'f',
+	L'u',L'n',L'e',L',',L'm',L'i',L'n',L'a',L'm',L'a',L't',L'a',L',',L'm',L'i',L'n',L'a',L'm',L'i',L'o',L'g',L'u',L'n',L'i',L',',L'n',L'a',L'g',L'a',L's',L'u',L',',L'n',L'i',L's',L'h',L'i',L'h',L'a',L'r',L'a',L',',L'o',L'g',L'u',L'n',L'i',L',',L'o',L'z',L'u',L',',L's',L'u',L'm',L'o',L't',L'o',L',',L't',L'a',L'k',L'a',L'm',L'o',L'r',L'i',L',',L'u',L'k',L'i',L',',L'u',L't',L'o',L',',L'y',L'a',L'm',L'a',L'g',L'a',L',',L'y',L'a',L'm',L'a',L't',L'o',L',',L'y',L'a',L't',L's',L'u',L's',L'h',L'i',L'r',L'o',
+	L')',L',',L'k',L'y',L'o',L't',L'o',L'(',L'3',L'1',L':',L'a',L'y',L'a',L'b',L'e',L',',L'f',L'u',L'k',L'u',L'c',L'h',L'i',L'y',L'a',L'm',L'a',L',',L'h',L'i',L'g',L'a',L's',L'h',L'i',L'y',L'a',L'm',L'a',L',',L'i',L'd',L'e',L',',L'i',L'n',L'e',L',',L'j',L'o',L'y',L'o',L',',L'k',L'a',L'm',L'e',L'o',L'k',L'a',L',',L'k',L'a',L'm',L'o',L',',L'k',L'i',L't',L'a',L',',L'k',L'i',L'z',L'u',L',',L'k',L'u',L'm',L'i',L'y',L'a',L'm',L'a',L',',L'k',L'y',L'o',L't',L'a',L'm',L'b',L'a',L',',L'k',L'y',L'o',L't',L'a',
+	L'n',L'a',L'b',L'e',L',',L'k',L'y',L'o',L't',L'a',L'n',L'g',L'o',L',',L'm',L'a',L'i',L'z',L'u',L'r',L'u',L',',L'm',L'i',L'n',L'a',L'm',L'i',L',',L'm',L'i',L'n',L'a',L'm',L'i',L'y',L'a',L'm',L'a',L's',L'h',L'i',L'r',L'o',L',',L'm',L'i',L'y',L'a',L'z',L'u',L',',L'm',L'u',L'k',L'o',L',',L'n',L'a',L'g',L'a',L'o',L'k',L'a',L'k',L'y',L'o',L',',L'n',L'a',L'k',L'a',L'g',L'y',L'o',L',',L'n',L'a',L'n',L't',L'a',L'n',L',',L'o',L'y',L'a',L'm',L'a',L'z',L'a',L'k',L'i',L',',L's',L'a',L'k',L'y',L'o',L',',L's',
+	L'e',L'i',L'k',L'a',L',',L't',L'a',L'n',L'a',L'b',L'e',L',',L'u',L'j',L'i',L',',L'u',L'j',L'i',L't',L'a',L'w',L'a',L'r',L'a',L',',L'w',L'a',L'z',L'u',L'k',L'a',L',',L'y',L'a',L'm',L'a',L's',L'h',L'i',L'n',L'a',L',',L'y',L'a',L'w',L'a',L't',L'a',L')',L',',L'm',L'i',L'e',L'(',L'3',L'0',L':',L'a',L's',L'a',L'h',L'i',L',',L'i',L'n',L'a',L'b',L'e',L',',L'i',L's',L'e',L',',L'k',L'a',L'm',L'e',L'y',L'a',L'm',L'a',L',',L'k',L'a',L'w',L'a',L'g',L'o',L'e',L',',L'k',L'i',L'h',L'o',L',',L'k',L'i',L's',L'o',
+	L's',L'a',L'k',L'i',L',',L'k',L'i',L'w',L'a',L',',L'k',L'o',L'm',L'o',L'n',L'o',L',',L'k',L'u',L'm',L'a',L'n',L'o',L',',L'k',L'u',L'w',L'a',L'n',L'a',L',',L'm',L'a',L't',L's',L'u',L's',L'a',L'k',L'a',L',',L'm',L'e',L'i',L'w',L'a',L',',L'm',L'i',L'h',L'a',L'm',L'a',L',',L'm',L'i',L'n',L'a',L'm',L'i',L'i',L's',L'e',L',',L'm',L'i',L's',L'u',L'g',L'i',L',',L'm',L'i',L'y',L'a',L'm',L'a',L',',L'n',L'a',L'b',L'a',L'r',L'i',L',',L's',L'h',L'i',L'm',L'a',L',',L's',L'u',L'z',L'u',L'k',L'a',L',',L't',L'a',
+	L'd',L'o',L',',L't',L'a',L'i',L'k',L'i',L',',L't',L'a',L'k',L'i',L',',L't',L'a',L'm',L'a',L'k',L'i',L',',L't',L'o',L'b',L'a',L',',L't',L's',L'u',L',',L'u',L'd',L'o',L'n',L'o',L',',L'u',L'r',L'e',L's',L'h',L'i',L'n',L'o',L',',L'w',L'a',L't',L'a',L'r',L'a',L'i',L',',L'y',L'o',L'k',L'k',L'a',L'i',L'c',L'h',L'i',L')',L',',L'm',L'i',L'y',L'a',L'g',L'i',L'(',L'3',L'3',L':',L'f',L'u',L'r',L'u',L'k',L'a',L'w',L'a',L',',L'h',L'i',L'g',L'a',L's',L'h',L'i',L'm',L'a',L't',L's',L'u',L's',L'h',L'i',L'm',L'a',
+	L',',L'i',L's',L'h',L'i',L'n',L'o',L'm',L'a',L'k',L'i',L',',L'i',L'w',L'a',L'n',L'u',L'm',L'a',L',',L'k',L'a',L'k',L'u',L'd',L'a',L',',L'k',L'a',L'm',L'i',L',',L'k',L'a',L'w',L'a',L's',L'a',L'k',L'i',L',',L'k',L'e',L's',L'e',L'n',L'n',L'u',L'm',L'a',L',',L'm',L'a',L'r',L'u',L'm',L'o',L'r',L'i',L',',L'm',L'a',L't',L's',L'u',L's',L'h',L'i',L'm',L'a',L',',L'm',L'i',L'n',L'a',L'm',L'i',L's',L'a',L'n',L'r',L'i',L'k',L'u',L',',L'm',L'i',L's',L'a',L't',L'o',L',',L'm',L'u',L'r',L'a',L't',L'a',L',',L'n',
+	L'a',L't',L'o',L'r',L'i',L',',L'o',L'g',L'a',L'w',L'a',L'r',L'a',L',',L'o',L'h',L'i',L'r',L'a',L',',L'o',L'n',L'a',L'g',L'a',L'w',L'a',L',',L'o',L's',L'a',L'k',L'i',L',',L'r',L'i',L'f',L'u',L',',L's',L'e',L'm',L'i',L'n',L'e',L',',L's',L'h',L'i',L'b',L'a',L't',L'a',L',',L's',L'h',L'i',L'c',L'h',L'i',L'k',L'a',L's',L'h',L'u',L'k',L'u',L',',L's',L'h',L'i',L'k',L'a',L'm',L'a',L',',L's',L'h',L'i',L'o',L'g',L'a',L'm',L'a',L',',L's',L'h',L'i',L'r',L'o',L'i',L's',L'h',L'i',L',',L't',L'a',L'g',L'a',L'j',
+	L'o',L',',L't',L'a',L'i',L'w',L'a',L',',L't',L'o',L'm',L'e',L',',L't',L'o',L'm',L'i',L'y',L'a',L',',L'w',L'a',L'k',L'u',L'y',L'a',L',',L'w',L'a',L't',L'a',L'r',L'i',L',',L'y',L'a',L'm',L'a',L'm',L'o',L't',L'o',L',',L'z',L'a',L'o',L')',L',',L'm',L'i',L'y',L'a',L'z',L'a',L'k',L'i',L'(',L'2',L'7',L':',L'a',L'y',L'a',L',',L'e',L'b',L'i',L'n',L'o',L',',L'g',L'o',L'k',L'a',L's',L'e',L',',L'h',L'y',L'u',L'g',L'a',L',',L'k',L'a',L'd',L'o',L'g',L'a',L'w',L'a',L',',L'k',L'a',L'w',L'a',L'm',L'i',L'n',L'a',
+	L'm',L'i',L',',L'k',L'i',L'j',L'o',L',',L'k',L'i',L't',L'a',L'g',L'a',L'w',L'a',L',',L'k',L'i',L't',L'a',L'k',L'a',L't',L'a',L',',L'k',L'i',L't',L'a',L'u',L'r',L'a',L',',L'k',L'o',L'b',L'a',L'y',L'a',L's',L'h',L'i',L',',L'k',L'u',L'n',L'i',L't',L'o',L'm',L'i',L',',L'k',L'u',L's',L'h',L'i',L'm',L'a',L',',L'm',L'i',L'm',L'a',L't',L'a',L',',L'm',L'i',L'y',L'a',L'k',L'o',L'n',L'o',L'j',L'o',L',',L'm',L'i',L'y',L'a',L'z',L'a',L'k',L'i',L',',L'm',L'o',L'r',L'o',L't',L's',L'u',L'k',L'a',L',',L'n',L'i',
+	L'c',L'h',L'i',L'n',L'a',L'n',L',',L'n',L'i',L's',L'h',L'i',L'm',L'e',L'r',L'a',L',',L'n',L'o',L'b',L'e',L'o',L'k',L'a',L',',L's',L'a',L'i',L't',L'o',L',',L's',L'h',L'i',L'i',L'b',L'a',L',',L's',L'h',L'i',L'n',L't',L'o',L'm',L'i',L',',L't',L'a',L'k',L'a',L'h',L'a',L'r',L'u',L',',L't',L'a',L'k',L'a',L'n',L'a',L'b',L'e',L',',L't',L'a',L'k',L'a',L'z',L'a',L'k',L'i',L',',L't',L's',L'u',L'n',L'o',L')',L',',L'n',L'a',L'g',L'a',L'n',L'o',L'(',L'7',L'5',L':',L'a',L'c',L'h',L'i',L',',L'a',L'g',L'e',L'm',
+	L'a',L't',L's',L'u',L',',L'a',L'n',L'a',L'n',L',',L'a',L'o',L'k',L'i',L',',L'a',L's',L'a',L'h',L'i',L',',L'a',L'z',L'u',L'm',L'i',L'n',L'o',L',',L'c',L'h',L'i',L'k',L'u',L'h',L'o',L'k',L'u',L',',L'c',L'h',L'i',L'k',L'u',L'm',L'a',L',',L'c',L'h',L'i',L'n',L'o',L',',L'f',L'u',L'j',L'i',L'm',L'i',L',',L'h',L'a',L'k',L'u',L'b',L'a',L',',L'h',L'a',L'r',L'a',L',',L'h',L'i',L'r',L'a',L'y',L'a',L',',L'i',L'i',L'd',L'a',L',',L'i',L'i',L'j',L'i',L'm',L'a',L',',L'i',L'i',L'y',L'a',L'm',L'a',L',',L'i',L'i',
+	L'z',L'u',L'n',L'a',L',',L'i',L'k',L'e',L'd',L'a',L',',L'i',L'k',L'u',L's',L'a',L'k',L'a',L',',L'i',L'n',L'a',L',',L'k',L'a',L'r',L'u',L'i',L'z',L'a',L'w',L'a',L',',L'k',L'a',L'w',L'a',L'k',L'a',L'm',L'i',L',',L'k',L'i',L's',L'o',L',',L'k',L'i',L's',L'o',L'f',L'u',L'k',L'u',L's',L'h',L'i',L'm',L'a',L',',L'k',L'i',L't',L'a',L'a',L'i',L'k',L'i',L',',L'k',L'o',L'm',L'a',L'g',L'a',L'n',L'e',L',',L'k',L'o',L'm',L'o',L'r',L'o',L',',L'm',L'a',L't',L's',L'u',L'k',L'a',L'w',L'a',L',',L'm',L'a',L't',L's',
+	L'u',L'm',L'o',L't',L'o',L',',L'm',L'i',L'a',L's',L'a',L',',L'm',L'i',L'n',L'a',L'm',L'i',L'a',L'i',L'k',L'i',L',',L'm',L'i',L'n',L'a',L'm',L'i',L'm',L'a',L'k',L'i',L',',L'm',L'i',L'n',L'a',L'm',L'i',L'm',L'i',L'n',L'o',L'w',L'a',L',',L'm',L'i',L'n',L'o',L'w',L'a',L',',L'm',L'i',L'y',L'a',L'd',L'a',L',',L'm',L'i',L'y',L'o',L't',L'a',L',',L'm',L'o',L'c',L'h',L'i',L'z',L'u',L'k',L'i',L',',L'n',L'a',L'g',L'a',L'n',L'o',L',',L'n',L'a',L'g',L'a',L'w',L'a',L',',L'n',L'a',L'g',L'i',L's',L'o',L',',L'n',
+	L'a',L'k',L'a',L'g',L'a',L'w',L'a',L',',L'n',L'a',L'k',L'a',L'n',L'o',L',',L'n',L'o',L'z',L'a',L'w',L'a',L'o',L'n',L's',L'e',L'n',L',',L'o',L'b',L'u',L's',L'e',L',',L'o',L'g',L'a',L'w',L'a',L',',L'o',L'k',L'a',L'y',L'a',L',',L'o',L'm',L'a',L'c',L'h',L'i',L',',L'o',L'm',L'i',L',',L'o',L'o',L'k',L'u',L'w',L'a',L',',L'o',L'o',L's',L'h',L'i',L'k',L'a',L',',L'o',L't',L'a',L'k',L'i',L',',L'o',L't',L'a',L'r',L'i',L',',L's',L'a',L'k',L'a',L'e',L',',L's',L'a',L'k',L'a',L'k',L'i',L',',L's',L'a',L'k',L'u',
+	L',',L's',L'a',L'k',L'u',L'h',L'o',L',',L's',L'h',L'i',L'm',L'o',L's',L'u',L'w',L'a',L',',L's',L'h',L'i',L'n',L'a',L'n',L'o',L'm',L'a',L'c',L'h',L'i',L',',L's',L'h',L'i',L'o',L'j',L'i',L'r',L'i',L',',L's',L'u',L'w',L'a',L',',L's',L'u',L'z',L'a',L'k',L'a',L',',L't',L'a',L'k',L'a',L'g',L'i',L',',L't',L'a',L'k',L'a',L'm',L'o',L'r',L'i',L',',L't',L'a',L'k',L'a',L'y',L'a',L'm',L'a',L',',L't',L'a',L't',L'e',L's',L'h',L'i',L'n',L'a',L',',L't',L'a',L't',L's',L'u',L'n',L'o',L',',L't',L'o',L'g',L'a',L'k',
+	L'u',L's',L'h',L'i',L',',L't',L'o',L'g',L'u',L'r',L'a',L',',L't',L'o',L'm',L'i',L',',L'u',L'e',L'd',L'a',L',',L'w',L'a',L'd',L'a',L',',L'y',L'a',L'm',L'a',L'g',L'a',L't',L'a',L',',L'y',L'a',L'm',L'a',L'n',L'o',L'u',L'c',L'h',L'i',L',',L'y',L'a',L's',L'a',L'k',L'a',L',',L'y',L'a',L's',L'u',L'o',L'k',L'a',L')',L',',L'n',L'a',L'g',L'a',L's',L'a',L'k',L'i',L'(',L'2',L'2',L':',L'c',L'h',L'i',L'j',L'i',L'w',L'a',L',',L'f',L'u',L't',L's',L'u',L',',L'g',L'o',L't',L'o',L',',L'h',L'a',L's',L'a',L'm',L'i',
+	L',',L'h',L'i',L'r',L'a',L'd',L'o',L',',L'i',L'k',L'i',L',',L'i',L's',L'a',L'h',L'a',L'y',L'a',L',',L'k',L'a',L'w',L'a',L't',L'a',L'n',L'a',L',',L'k',L'u',L'c',L'h',L'i',L'n',L'o',L't',L's',L'u',L',',L'm',L'a',L't',L's',L'u',L'u',L'r',L'a',L',',L'n',L'a',L'g',L'a',L's',L'a',L'k',L'i',L',',L'o',L'b',L'a',L'm',L'a',L',',L'o',L'm',L'u',L'r',L'a',L',',L'o',L's',L'e',L't',L'o',L',',L's',L'a',L'i',L'k',L'a',L'i',L',',L's',L'a',L's',L'e',L'b',L'o',L',',L's',L'e',L'i',L'h',L'i',L',',L's',L'h',L'i',L'm',
+	L'a',L'b',L'a',L'r',L'a',L',',L's',L'h',L'i',L'n',L'k',L'a',L'm',L'i',L'g',L'o',L't',L'o',L',',L't',L'o',L'g',L'i',L't',L's',L'u',L',',L't',L's',L'u',L's',L'h',L'i',L'm',L'a',L',',L'u',L'n',L'z',L'e',L'n',L')',L',',L'n',L'a',L'r',L'a',L'(',L'3',L'8',L':',L'a',L'n',L'd',L'o',L',',L'g',L'o',L's',L'e',L',',L'h',L'e',L'g',L'u',L'r',L'i',L',',L'h',L'i',L'g',L'a',L's',L'h',L'i',L'y',L'o',L's',L'h',L'i',L'n',L'o',L',',L'i',L'k',L'a',L'r',L'u',L'g',L'a',L',',L'i',L'k',L'o',L'm',L'a',L',',L'k',L'a',L'm',
+	L'i',L'k',L'i',L't',L'a',L'y',L'a',L'm',L'a',L',',L'k',L'a',L'n',L'm',L'a',L'k',L'i',L',',L'k',L'a',L's',L'h',L'i',L'b',L'a',L',',L'k',L'a',L's',L'h',L'i',L'h',L'a',L'r',L'a',L',',L'k',L'a',L't',L's',L'u',L'r',L'a',L'g',L'i',L',',L'k',L'a',L'w',L'a',L'i',L',',L'k',L'a',L'w',L'a',L'k',L'a',L'm',L'i',L',',L'k',L'a',L'w',L'a',L'n',L'i',L's',L'h',L'i',L',',L'k',L'o',L'r',L'y',L'o',L',',L'k',L'u',L'r',L'o',L't',L'a',L'k',L'i',L',',L'm',L'i',L't',L's',L'u',L'e',L',',L'm',L'i',L'y',L'a',L'k',L'e',L',',
+	L'n',L'a',L'r',L'a',L',',L'n',L'o',L's',L'e',L'g',L'a',L'w',L'a',L',',L'o',L'j',L'i',L',',L'o',L'u',L'd',L'a',L',',L'o',L'y',L'o',L'd',L'o',L',',L's',L'a',L'k',L'u',L'r',L'a',L'i',L',',L's',L'a',L'n',L'g',L'o',L',',L's',L'h',L'i',L'm',L'o',L'i',L'c',L'h',L'i',L',',L's',L'h',L'i',L'm',L'o',L'k',L'i',L't',L'a',L'y',L'a',L'm',L'a',L',',L's',L'h',L'i',L'n',L'j',L'o',L',',L's',L'o',L'n',L'i',L',',L't',L'a',L'k',L'a',L't',L'o',L'r',L'i',L',',L't',L'a',L'w',L'a',L'r',L'a',L'm',L'o',L't',L'o',L',',L't',
+	L'e',L'n',L'k',L'a',L'w',L'a',L',',L't',L'e',L'n',L'r',L'i',L',',L'u',L'd',L'a',L',',L'y',L'a',L'm',L'a',L't',L'o',L'k',L'o',L'r',L'i',L'y',L'a',L'm',L'a',L',',L'y',L'a',L'm',L'a',L't',L'o',L't',L'a',L'k',L'a',L'd',L'a',L',',L'y',L'a',L'm',L'a',L'z',L'o',L'e',L',',L'y',L'o',L's',L'h',L'i',L'n',L'o',L')',L',',L'n',L'i',L'i',L'g',L'a',L't',L'a',L'(',L'3',L'4',L':',L'a',L'g',L'a',L',',L'a',L'g',L'a',L'n',L'o',L',',L'g',L'o',L's',L'e',L'n',L',',L'i',L't',L'o',L'i',L'g',L'a',L'w',L'a',L',',L'i',L'z',
+	L'u',L'm',L'o',L'z',L'a',L'k',L'i',L',',L'j',L'o',L'e',L't',L's',L'u',L',',L'k',L'a',L'm',L'o',L',',L'k',L'a',L'r',L'i',L'w',L'a',L',',L'k',L'a',L's',L'h',L'i',L'w',L'a',L'z',L'a',L'k',L'i',L',',L'm',L'i',L'n',L'a',L'm',L'i',L'u',L'o',L'n',L'u',L'm',L'a',L',',L'm',L'i',L't',L's',L'u',L'k',L'e',L',',L'm',L'u',L'i',L'k',L'a',L',',L'm',L'u',L'r',L'a',L'k',L'a',L'm',L'i',L',',L'm',L'y',L'o',L'k',L'o',L',',L'n',L'a',L'g',L'a',L'o',L'k',L'a',L',',L'n',L'i',L'i',L'g',L'a',L't',L'a',L',',L'o',L'j',L'i',
+	L'y',L'a',L',',L'o',L'm',L'i',L',',L's',L'a',L'd',L'o',L',',L's',L'a',L'n',L'j',L'o',L',',L's',L'e',L'i',L'r',L'o',L',',L's',L'e',L'i',L'r',L'o',L'u',L',',L's',L'e',L'k',L'i',L'k',L'a',L'w',L'a',L',',L's',L'h',L'i',L'b',L'a',L't',L'a',L',',L't',L'a',L'g',L'a',L'm',L'i',L',',L't',L'a',L'i',L'n',L'a',L'i',L',',L't',L'o',L'c',L'h',L'i',L'o',L',',L't',L'o',L'k',L'a',L'm',L'a',L'c',L'h',L'i',L',',L't',L's',L'u',L'b',L'a',L'm',L'e',L',',L't',L's',L'u',L'n',L'a',L'n',L',',L'u',L'o',L'n',L'u',L'm',L'a',
+	L',',L'y',L'a',L'h',L'i',L'k',L'o',L',',L'y',L'o',L'i',L't',L'a',L',',L'y',L'u',L'z',L'a',L'w',L'a',L')',L',',L'o',L'i',L't',L'a',L'(',L'1',L'9',L':',L'b',L'e',L'p',L'p',L'u',L',',L'b',L'u',L'n',L'g',L'o',L'o',L'n',L'o',L',',L'b',L'u',L'n',L'g',L'o',L't',L'a',L'k',L'a',L'd',L'a',L',',L'h',L'a',L's',L'a',L'm',L'a',L',',L'h',L'i',L'j',L'i',L',',L'h',L'i',L'm',L'e',L's',L'h',L'i',L'm',L'a',L',',L'h',L'i',L't',L'a',L',',L'k',L'a',L'm',L'i',L't',L's',L'u',L'e',L',',L'k',L'o',L'k',L'o',L'n',L'o',L'e',
+	L',',L'k',L'u',L'j',L'u',L',',L'k',L'u',L'n',L'i',L's',L'a',L'k',L'i',L',',L'k',L'u',L's',L'u',L',',L'o',L'i',L't',L'a',L',',L's',L'a',L'i',L'k',L'i',L',',L't',L'a',L'k',L'e',L't',L'a',L',',L't',L's',L'u',L'k',L'u',L'm',L'i',L',',L'u',L's',L'a',L',',L'u',L's',L'u',L'k',L'i',L',',L'y',L'u',L'f',L'u',L')',L',',L'o',L'k',L'a',L'y',L'a',L'm',L'a',L'(',L'2',L'6',L':',L'a',L'k',L'a',L'i',L'w',L'a',L',',L'a',L's',L'a',L'k',L'u',L'c',L'h',L'i',L',',L'b',L'i',L'z',L'e',L'n',L',',L'h',L'a',L'y',L'a',L's',
+	L'h',L'i',L'm',L'a',L',',L'i',L'b',L'a',L'r',L'a',L',',L'k',L'a',L'g',L'a',L'm',L'i',L'n',L'o',L',',L'k',L'a',L's',L'a',L'o',L'k',L'a',L',',L'k',L'i',L'b',L'i',L'c',L'h',L'u',L'o',L',',L'k',L'u',L'm',L'e',L'n',L'a',L'n',L',',L'k',L'u',L'r',L'a',L's',L'h',L'i',L'k',L'i',L',',L'm',L'a',L'n',L'i',L'w',L'a',L',',L'm',L'i',L's',L'a',L'k',L'i',L',',L'n',L'a',L'g',L'i',L',',L'n',L'i',L'i',L'm',L'i',L',',L'n',L'i',L's',L'h',L'i',L'a',L'w',L'a',L'k',L'u',L'r',L'a',L',',L'o',L'k',L'a',L'y',L'a',L'm',L'a',
+	L',',L's',L'a',L't',L'o',L's',L'h',L'o',L',',L's',L'e',L't',L'o',L'u',L'c',L'h',L'i',L',',L's',L'h',L'i',L'n',L'j',L'o',L',',L's',L'h',L'o',L'o',L',',L's',L'o',L'j',L'a',L',',L't',L'a',L'k',L'a',L'h',L'a',L's',L'h',L'i',L',',L't',L'a',L'm',L'a',L'n',L'o',L',',L't',L's',L'u',L'y',L'a',L'm',L'a',L',',L'w',L'a',L'k',L'e',L',',L'y',L'a',L'k',L'a',L'g',L'e',L')',L',',L'o',L'k',L'i',L'n',L'a',L'w',L'a',L'(',L'4',L'2',L':',L'a',L'g',L'u',L'n',L'i',L',',L'g',L'i',L'n',L'o',L'w',L'a',L'n',L',',L'g',L'i',
+	L'n',L'o',L'z',L'a',L',',L'g',L'u',L's',L'h',L'i',L'k',L'a',L'm',L'i',L',',L'h',L'a',L'e',L'b',L'a',L'r',L'u',L',',L'h',L'i',L'g',L'a',L's',L'h',L'i',L',',L'h',L'i',L'r',L'a',L'r',L'a',L',',L'i',L'h',L'e',L'y',L'a',L',',L'i',L's',L'h',L'i',L'g',L'a',L'k',L'i',L',',L'i',L's',L'h',L'i',L'k',L'a',L'w',L'a',L',',L'i',L't',L'o',L'm',L'a',L'n',L',',L'i',L'z',L'e',L'n',L'a',L',',L'k',L'a',L'd',L'e',L'n',L'a',L',',L'k',L'i',L'n',L',',L'k',L'i',L't',L'a',L'd',L'a',L'i',L't',L'o',L',',L'k',L'i',L't',L'a',
+	L'n',L'a',L'k',L'a',L'g',L'u',L's',L'u',L'k',L'u',L',',L'k',L'u',L'm',L'e',L'j',L'i',L'm',L'a',L',',L'k',L'u',L'n',L'i',L'g',L'a',L'm',L'i',L',',L'm',L'i',L'n',L'a',L'm',L'i',L'd',L'a',L'i',L't',L'o',L',',L'm',L'o',L't',L'o',L'b',L'u',L',',L'n',L'a',L'g',L'o',L',',L'n',L'a',L'h',L'a',L',',L'n',L'a',L'k',L'a',L'g',L'u',L's',L'u',L'k',L'u',L',',L'n',L'a',L'k',L'i',L'j',L'i',L'n',L',',L'n',L'a',L'n',L'j',L'o',L',',L'n',L'i',L's',L'h',L'i',L'h',L'a',L'r',L'a',L',',L'o',L'g',L'i',L'm',L'i',L',',L'o',
+	L'k',L'i',L'n',L'a',L'w',L'a',L',',L'o',L'n',L'n',L'a',L',',L's',L'h',L'i',L'm',L'o',L'j',L'i',L',',L't',L'a',L'k',L'e',L't',L'o',L'm',L'i',L',',L't',L'a',L'r',L'a',L'm',L'a',L',',L't',L'o',L'k',L'a',L's',L'h',L'i',L'k',L'i',L',',L't',L'o',L'm',L'i',L'g',L'u',L's',L'u',L'k',L'u',L',',L't',L'o',L'n',L'a',L'k',L'i',L',',L'u',L'r',L'a',L's',L'o',L'e',L',',L'u',L'r',L'u',L'm',L'a',L',',L'y',L'a',L'e',L's',L'e',L',',L'y',L'o',L'm',L'i',L't',L'a',L'n',L',',L'y',L'o',L'n',L'a',L'b',L'a',L'r',L'u',L',',
+	L'y',L'o',L'n',L'a',L'g',L'u',L'n',L'i',L',',L'z',L'a',L'm',L'a',L'm',L'i',L')',L',',L'o',L's',L'a',L'k',L'a',L'(',L'5',L'0',L':',L'a',L'b',L'e',L'n',L'o',L',',L'c',L'h',L'i',L'h',L'a',L'y',L'a',L'a',L'k',L'a',L's',L'a',L'k',L'a',L',',L'c',L'h',L'u',L'o',L',',L'd',L'a',L'i',L't',L'o',L',',L'f',L'u',L'j',L'i',L'i',L'd',L'e',L'r',L'a',L',',L'h',L'a',L'b',L'i',L'k',L'i',L'n',L'o',L',',L'h',L'a',L'n',L'n',L'a',L'n',L',',L'h',L'i',L'g',L'a',L's',L'h',L'i',L'o',L's',L'a',L'k',L'a',L',',L'h',L'i',L'g',
+	L'a',L's',L'h',L'i',L's',L'u',L'm',L'i',L'y',L'o',L's',L'h',L'i',L',',L'h',L'i',L'g',L'a',L's',L'h',L'i',L'y',L'o',L'd',L'o',L'g',L'a',L'w',L'a',L',',L'h',L'i',L'r',L'a',L'k',L'a',L't',L'a',L',',L'i',L'b',L'a',L'r',L'a',L'k',L'i',L',',L'i',L'k',L'e',L'd',L'a',L',',L'i',L'z',L'u',L'm',L'i',L',',L'i',L'z',L'u',L'm',L'i',L'o',L't',L's',L'u',L',',L'i',L'z',L'u',L'm',L'i',L's',L'a',L'n',L'o',L',',L'k',L'a',L'd',L'o',L'm',L'a',L',',L'k',L'a',L'i',L'z',L'u',L'k',L'a',L',',L'k',L'a',L'n',L'a',L'n',L',',
+	L'k',L'a',L's',L'h',L'i',L'w',L'a',L'r',L'a',L',',L'k',L'a',L't',L'a',L'n',L'o',L',',L'k',L'a',L'w',L'a',L'c',L'h',L'i',L'n',L'a',L'g',L'a',L'n',L'o',L',',L'k',L'i',L's',L'h',L'i',L'w',L'a',L'd',L'a',L',',L'k',L'i',L't',L'a',L',',L'k',L'u',L'm',L'a',L't',L'o',L'r',L'i',L',',L'm',L'a',L't',L's',L'u',L'b',L'a',L'r',L'a',L',',L'm',L'i',L'n',L'a',L't',L'o',L',',L'm',L'i',L'n',L'o',L'h',L',',L'm',L'i',L's',L'a',L'k',L'i',L',',L'm',L'o',L'r',L'i',L'g',L'u',L'c',L'h',L'i',L',',L'n',L'e',L'y',L'a',L'g',
+	L'a',L'w',L'a',L',',L'n',L'i',L's',L'h',L'i',L',',L'n',L'o',L's',L'e',L',',L'o',L's',L'a',L'k',L'a',L's',L'a',L'y',L'a',L'm',L'a',L',',L's',L'a',L'k',L'a',L'i',L',',L's',L'a',L'y',L'a',L'm',L'a',L',',L's',L'e',L'n',L'n',L'a',L'n',L',',L's',L'e',L't',L't',L's',L'u',L',',L's',L'h',L'i',L'j',L'o',L'n',L'a',L'w',L'a',L't',L'e',L',',L's',L'h',L'i',L'm',L'a',L'm',L'o',L't',L'o',L',',L's',L'u',L'i',L't',L'a',L',',L't',L'a',L'd',L'a',L'o',L'k',L'a',L',',L't',L'a',L'i',L's',L'h',L'i',L',',L't',L'a',L'j',
+	L'i',L'r',L'i',L',',L't',L'a',L'k',L'a',L'i',L's',L'h',L'i',L',',L't',L'a',L'k',L'a',L't',L's',L'u',L'k',L'i',L',',L't',L'o',L'n',L'd',L'a',L'b',L'a',L'y',L'a',L's',L'h',L'i',L',',L't',L'o',L'y',L'o',L'n',L'a',L'k',L'a',L',',L't',L'o',L'y',L'o',L'n',L'o',L',',L'y',L'a',L'o',L')',L',',L's',L'a',L'g',L'a',L'(',L'2',L'6',L':',L'a',L'r',L'i',L'a',L'k',L'e',L',',L'a',L'r',L'i',L't',L'a',L',',L'f',L'u',L'k',L'u',L'd',L'o',L'm',L'i',L',',L'g',L'e',L'n',L'k',L'a',L'i',L',',L'h',L'a',L'm',L'a',L't',L'a',
+	L'm',L'a',L',',L'h',L'i',L'z',L'e',L'n',L',',L'i',L'm',L'a',L'r',L'i',L',',L'k',L'a',L'm',L'i',L'm',L'i',L'n',L'e',L',',L'k',L'a',L'n',L'z',L'a',L'k',L'i',L',',L'k',L'a',L'r',L'a',L't',L's',L'u',L',',L'k',L'a',L's',L'h',L'i',L'm',L'a',L',',L'k',L'i',L't',L'a',L'g',L'a',L't',L'a',L',',L'k',L'i',L't',L'a',L'h',L'a',L't',L'a',L',',L'k',L'i',L'y',L'a',L'm',L'a',L',',L'k',L'o',L'u',L'h',L'o',L'k',L'u',L',',L'k',L'y',L'u',L'r',L'a',L'g',L'i',L',',L'n',L'i',L's',L'h',L'i',L'a',L'r',L'i',L't',L'a',L',',
+	L'o',L'g',L'i',L',',L'o',L'm',L'a',L'c',L'h',L'i',L',',L'o',L'u',L'c',L'h',L'i',L',',L's',L'a',L'g',L'a',L',',L's',L'h',L'i',L'r',L'o',L'i',L's',L'h',L'i',L',',L't',L'a',L'k',L'u',L',',L't',L'a',L'r',L'a',L',',L't',L'o',L's',L'u',L',',L'y',L'o',L's',L'h',L'i',L'n',L'o',L'g',L'a',L'r',L'i',L')',L',',L's',L'a',L'i',L't',L'a',L'm',L'a',L'(',L'6',L'9',L':',L'a',L'r',L'a',L'k',L'a',L'w',L'a',L',',L'a',L's',L'a',L'k',L'a',L',',L'c',L'h',L'i',L'c',L'h',L'i',L'b',L'u',L',',L'f',L'u',L'j',L'i',L'm',L'i',
+	L',',L'f',L'u',L'j',L'i',L'm',L'i',L'n',L'o',L',',L'f',L'u',L'k',L'a',L'y',L'a',L',',L'h',L'a',L'n',L'n',L'o',L',',L'h',L'a',L'n',L'y',L'u',L',',L'h',L'a',L's',L'u',L'd',L'a',L',',L'h',L'a',L't',L'o',L'g',L'a',L'y',L'a',L',',L'h',L'a',L't',L'o',L'y',L'a',L'm',L'a',L',',L'h',L'i',L'd',L'a',L'k',L'a',L',',L'h',L'i',L'g',L'a',L's',L'h',L'i',L'c',L'h',L'i',L'c',L'h',L'i',L'b',L'u',L',',L'h',L'i',L'g',L'a',L's',L'h',L'i',L'm',L'a',L't',L's',L'u',L'y',L'a',L'm',L'a',L',',L'h',L'o',L'n',L'j',L'o',L',',
+	L'i',L'n',L'a',L',',L'i',L'r',L'u',L'm',L'a',L',',L'i',L'w',L'a',L't',L's',L'u',L'k',L'i',L',',L'k',L'a',L'm',L'i',L'i',L'z',L'u',L'm',L'i',L',',L'k',L'a',L'm',L'i',L'k',L'a',L'w',L'a',L',',L'k',L'a',L'm',L'i',L's',L'a',L't',L'o',L',',L'k',L'a',L's',L'u',L'k',L'a',L'b',L'e',L',',L'k',L'a',L'w',L'a',L'g',L'o',L'e',L',',L'k',L'a',L'w',L'a',L'g',L'u',L'c',L'h',L'i',L',',L'k',L'a',L'w',L'a',L'j',L'i',L'm',L'a',L',',L'k',L'a',L'z',L'o',L',',L'k',L'i',L't',L'a',L'm',L'o',L't',L'o',L',',L'k',L'o',L's',
+	L'h',L'i',L'g',L'a',L'y',L'a',L',',L'k',L'o',L'u',L'n',L'o',L's',L'u',L',',L'k',L'u',L'k',L'i',L',',L'k',L'u',L'm',L'a',L'g',L'a',L'y',L'a',L',',L'm',L'a',L't',L's',L'u',L'b',L'u',L's',L'h',L'i',L',',L'm',L'i',L'n',L'a',L'n',L'o',L',',L'm',L'i',L's',L'a',L't',L'o',L',',L'm',L'i',L'y',L'a',L's',L'h',L'i',L'r',L'o',L',',L'm',L'i',L'y',L'o',L's',L'h',L'i',L',',L'm',L'o',L'r',L'o',L'y',L'a',L'm',L'a',L',',L'n',L'a',L'g',L'a',L't',L'o',L'r',L'o',L',',L'n',L'a',L'm',L'e',L'g',L'a',L'w',L'a',L',',L'n',
+	L'i',L'i',L'z',L'a',L',',L'o',L'g',L'a',L'n',L'o',L',',L'o',L'g',L'a',L'w',L'a',L',',L'o',L'g',L'o',L's',L'e',L',',L'o',L'k',L'e',L'g',L'a',L'w',L'a',L',',L'o',L'm',L'i',L'y',L'a',L',',L'o',L't',L'a',L'k',L'i',L',',L'r',L'a',L'n',L'z',L'a',L'n',L',',L'r',L'y',L'o',L'k',L'a',L'm',L'i',L',',L's',L'a',L'i',L't',L'a',L'm',L'a',L',',L's',L'a',L'k',L'a',L'd',L'o',L',',L's',L'a',L't',L't',L'e',L',',L's',L'a',L'y',L'a',L'm',L'a',L',',L's',L'h',L'i',L'k',L'i',L',',L's',L'h',L'i',L'r',L'a',L'o',L'k',L'a',
+	L',',L's',L'o',L'k',L'a',L',',L's',L'u',L'g',L'i',L't',L'o',L',',L't',L'o',L'd',L'a',L',',L't',L'o',L'k',L'i',L'g',L'a',L'w',L'a',L',',L't',L'o',L'k',L'o',L'r',L'o',L'z',L'a',L'w',L'a',L',',L't',L's',L'u',L'r',L'u',L'g',L'a',L's',L'h',L'i',L'm',L'a',L',',L'u',L'r',L'a',L'w',L'a',L',',L'w',L'a',L'r',L'a',L'b',L'i',L',',L'y',L'a',L's',L'h',L'i',L'o',L',',L'y',L'o',L'k',L'o',L'z',L'e',L',',L'y',L'o',L'n',L'o',L',',L'y',L'o',L'r',L'i',L'i',L',',L'y',L'o',L's',L'h',L'i',L'd',L'a',L',',L'y',L'o',L's',
+	L'h',L'i',L'k',L'a',L'w',L'a',L',',L'y',L'o',L's',L'h',L'i',L'm',L'i',L')',L',',L's',L'h',L'i',L'g',L'a',L'(',L'2',L'3',L':',L'a',L'i',L's',L'h',L'o',L',',L'g',L'a',L'm',L'o',L',',L'h',L'i',L'g',L'a',L's',L'h',L'i',L'o',L'm',L'i',L',',L'h',L'i',L'k',L'o',L'n',L'e',L',',L'k',L'o',L'k',L'a',L',',L'k',L'o',L'n',L'a',L'n',L',',L'k',L'o',L's',L'e',L'i',L',',L'k',L'o',L't',L'o',L',',L'k',L'u',L's',L'a',L't',L's',L'u',L',',L'm',L'a',L'i',L'b',L'a',L'r',L'a',L',',L'm',L'o',L'r',L'i',L'y',L'a',L'm',L'a',
+	L',',L'n',L'a',L'g',L'a',L'h',L'a',L'm',L'a',L',',L'n',L'i',L's',L'h',L'i',L'a',L'z',L'a',L'i',L',',L'n',L'o',L't',L'o',L'g',L'a',L'w',L'a',L',',L'o',L'm',L'i',L'h',L'a',L'c',L'h',L'i',L'm',L'a',L'n',L',',L'o',L't',L's',L'u',L',',L'r',L'i',L't',L't',L'o',L',',L'r',L'y',L'u',L'o',L'h',L',',L't',L'a',L'k',L'a',L's',L'h',L'i',L'm',L'a',L',',L't',L'a',L'k',L'a',L't',L's',L'u',L'k',L'i',L',',L't',L'o',L'r',L'a',L'h',L'i',L'm',L'e',L',',L't',L'o',L'y',L'o',L's',L'a',L't',L'o',L',',L'y',L'a',L's',L'u',
+	L')',L',',L's',L'h',L'i',L'm',L'a',L'n',L'e',L'(',L'2',L'3',L':',L'a',L'k',L'a',L'g',L'i',L',',L'a',L'm',L'a',L',',L'g',L'o',L't',L's',L'u',L',',L'h',L'a',L'm',L'a',L'd',L'a',L',',L'h',L'i',L'g',L'a',L's',L'h',L'i',L'i',L'z',L'u',L'm',L'o',L',',L'h',L'i',L'k',L'a',L'w',L'a',L',',L'h',L'i',L'k',L'i',L'm',L'i',L',',L'i',L'z',L'u',L'm',L'o',L',',L'k',L'a',L'k',L'i',L'n',L'o',L'k',L'i',L',',L'm',L'a',L's',L'u',L'd',L'a',L',',L'm',L'a',L't',L's',L'u',L'e',L',',L'm',L'i',L's',L'a',L't',L'o',L',',L'n',
+	L'i',L's',L'h',L'i',L'n',L'o',L's',L'h',L'i',L'm',L'a',L',',L'o',L'h',L'd',L'a',L',',L'o',L'k',L'i',L'n',L'o',L's',L'h',L'i',L'm',L'a',L',',L'o',L'k',L'u',L'i',L'z',L'u',L'm',L'o',L',',L's',L'h',L'i',L'm',L'a',L'n',L'e',L',',L't',L'a',L'm',L'a',L'y',L'u',L',',L't',L's',L'u',L'w',L'a',L'n',L'o',L',',L'u',L'n',L'n',L'a',L'n',L',',L'y',L'a',L'k',L'u',L'm',L'o',L',',L'y',L'a',L's',L'u',L'g',L'i',L',',L'y',L'a',L't',L's',L'u',L'k',L'a',L')',L',',L's',L'h',L'i',L'z',L'u',L'o',L'k',L'a',L'(',L'3',L'6',
+	L':',L'a',L'r',L'a',L'i',L',',L'a',L't',L'a',L'm',L'i',L',',L'f',L'u',L'j',L'i',L',',L'f',L'u',L'j',L'i',L'e',L'd',L'a',L',',L'f',L'u',L'j',L'i',L'k',L'a',L'w',L'a',L',',L'f',L'u',L'j',L'i',L'n',L'o',L'm',L'i',L'y',L'a',L',',L'f',L'u',L'k',L'u',L'r',L'o',L'i',L',',L'g',L'o',L't',L'e',L'm',L'b',L'a',L',',L'h',L'a',L'i',L'b',L'a',L'r',L'a',L',',L'h',L'a',L'm',L'a',L'm',L'a',L't',L's',L'u',L',',L'h',L'i',L'g',L'a',L's',L'h',L'i',L'i',L'z',L'u',L',',L'i',L't',L'o',L',',L'i',L'w',L'a',L't',L'a',L',',
+	L'i',L'z',L'u',L',',L'i',L'z',L'u',L'n',L'o',L'k',L'u',L'n',L'i',L',',L'k',L'a',L'k',L'e',L'g',L'a',L'w',L'a',L',',L'k',L'a',L'n',L'n',L'a',L'm',L'i',L',',L'k',L'a',L'w',L'a',L'n',L'e',L'h',L'o',L'n',L',',L'k',L'a',L'w',L'a',L'z',L'u',L',',L'k',L'i',L'k',L'u',L'g',L'a',L'w',L'a',L',',L'k',L'o',L's',L'a',L'i',L',',L'm',L'a',L'k',L'i',L'n',L'o',L'h',L'a',L'r',L'a',L',',L'm',L'a',L't',L's',L'u',L'z',L'a',L'k',L'i',L',',L'm',L'i',L'n',L'a',L'm',L'i',L'i',L'z',L'u',L',',L'm',L'i',L's',L'h',L'i',L'm',
+	L'a',L',',L'm',L'o',L'r',L'i',L'm',L'a',L'c',L'h',L'i',L',',L'n',L'i',L's',L'h',L'i',L'i',L'z',L'u',L',',L'n',L'u',L'm',L'a',L'z',L'u',L',',L'o',L'm',L'a',L'e',L'z',L'a',L'k',L'i',L',',L's',L'h',L'i',L'm',L'a',L'd',L'a',L',',L's',L'h',L'i',L'm',L'i',L'z',L'u',L',',L's',L'h',L'i',L'm',L'o',L'd',L'a',L',',L's',L'h',L'i',L'z',L'u',L'o',L'k',L'a',L',',L's',L'u',L's',L'o',L'n',L'o',L',',L'y',L'a',L'i',L'z',L'u',L',',L'y',L'o',L's',L'h',L'i',L'd',L'a',L')',L',',L't',L'o',L'c',L'h',L'i',L'g',L'i',L'(',
+	L'3',L'1',L':',L'a',L's',L'h',L'i',L'k',L'a',L'g',L'a',L',',L'b',L'a',L't',L'o',L',',L'h',L'a',L'g',L'a',L',',L'i',L'c',L'h',L'i',L'k',L'a',L'i',L',',L'i',L'w',L'a',L'f',L'u',L'n',L'e',L',',L'k',L'a',L'm',L'i',L'n',L'o',L'k',L'a',L'w',L'a',L',',L'k',L'a',L'n',L'u',L'm',L'a',L',',L'k',L'a',L'r',L'a',L's',L'u',L'y',L'a',L'm',L'a',L',',L'k',L'u',L'r',L'o',L'i',L's',L'o',L',',L'm',L'a',L's',L'h',L'i',L'k',L'o',L',',L'm',L'i',L'b',L'u',L',',L'm',L'o',L'k',L'a',L',',L'm',L'o',L't',L'e',L'g',L'i',L',',
+	L'n',L'a',L's',L'u',L',',L'n',L'a',L's',L'u',L's',L'h',L'i',L'o',L'b',L'a',L'r',L'a',L',',L'n',L'i',L'k',L'k',L'o',L',',L'n',L'i',L's',L'h',L'i',L'k',L'a',L't',L'a',L',',L'n',L'o',L'g',L'i',L',',L'o',L'h',L'i',L'r',L'a',L',',L'o',L'h',L't',L'a',L'w',L'a',L'r',L'a',L',',L'o',L'y',L'a',L'm',L'a',L',',L's',L'a',L'k',L'u',L'r',L'a',L',',L's',L'a',L'n',L'o',L',',L's',L'h',L'i',L'm',L'o',L't',L's',L'u',L'k',L'e',L',',L's',L'h',L'i',L'o',L'y',L'a',L',',L't',L'a',L'k',L'a',L'n',L'e',L'z',L'a',L'w',L'a',
+	L',',L't',L'o',L'c',L'h',L'i',L'g',L'i',L',',L't',L's',L'u',L'g',L'a',L',',L'u',L'j',L'i',L'i',L'e',L',',L'u',L't',L's',L'u',L'n',L'o',L'm',L'i',L'y',L'a',L',',L'y',L'a',L'i',L't',L'a',L')',L',',L't',L'o',L'k',L'u',L's',L'h',L'i',L'm',L'a',L'(',L'1',L'7',L':',L'a',L'i',L'z',L'u',L'm',L'i',L',',L'a',L'n',L'a',L'n',L',',L'i',L'c',L'h',L'i',L'b',L'a',L',',L'i',L't',L'a',L'n',L'o',L',',L'k',L'a',L'i',L'n',L'a',L'n',L',',L'k',L'o',L'm',L'a',L't',L's',L'u',L's',L'h',L'i',L'm',L'a',L',',L'm',L'a',L't',
+	L's',L'u',L's',L'h',L'i',L'g',L'e',L',',L'm',L'i',L'm',L'a',L',',L'm',L'i',L'n',L'a',L'm',L'i',L',',L'm',L'i',L'y',L'o',L's',L'h',L'i',L',',L'm',L'u',L'g',L'i',L',',L'n',L'a',L'k',L'a',L'g',L'a',L'w',L'a',L',',L'n',L'a',L'r',L'u',L't',L'o',L',',L's',L'a',L'n',L'a',L'g',L'o',L'c',L'h',L'i',L',',L's',L'h',L'i',L's',L'h',L'i',L'k',L'u',L'i',L',',L't',L'o',L'k',L'u',L's',L'h',L'i',L'm',L'a',L',',L'w',L'a',L'j',L'i',L'k',L'i',L')',L',',L't',L'o',L'k',L'y',L'o',L'(',L'5',L'7',L':',L'a',L'd',L'a',L'c',
+	L'h',L'i',L',',L'a',L'k',L'i',L'r',L'u',L'n',L'o',L',',L'a',L'k',L'i',L's',L'h',L'i',L'm',L'a',L',',L'a',L'o',L'g',L'a',L's',L'h',L'i',L'm',L'a',L',',L'a',L'r',L'a',L'k',L'a',L'w',L'a',L',',L'b',L'u',L'n',L'k',L'y',L'o',L',',L'c',L'h',L'i',L'y',L'o',L'd',L'a',L',',L'c',L'h',L'o',L'f',L'u',L',',L'c',L'h',L'u',L'o',L',',L'e',L'd',L'o',L'g',L'a',L'w',L'a',L',',L'f',L'u',L'c',L'h',L'u',L',',L'f',L'u',L's',L's',L'a',L',',L'h',L'a',L'c',L'h',L'i',L'j',L'o',L',',L'h',L'a',L'c',L'h',L'i',L'o',L'j',L'i',
+	L',',L'h',L'a',L'm',L'u',L'r',L'a',L',',L'h',L'i',L'g',L'a',L's',L'h',L'i',L'k',L'u',L'r',L'u',L'm',L'e',L',',L'h',L'i',L'g',L'a',L's',L'h',L'i',L'm',L'u',L'r',L'a',L'y',L'a',L'm',L'a',L',',L'h',L'i',L'g',L'a',L's',L'h',L'i',L'y',L'a',L'm',L'a',L't',L'o',L',',L'h',L'i',L'n',L'o',L',',L'h',L'i',L'n',L'o',L'd',L'e',L',',L'h',L'i',L'n',L'o',L'h',L'a',L'r',L'a',L',',L'i',L'n',L'a',L'g',L'i',L',',L'i',L't',L'a',L'b',L'a',L's',L'h',L'i',L',',L'k',L'a',L't',L's',L'u',L's',L'h',L'i',L'k',L'a',L',',L'k',
+	L'i',L't',L'a',L',',L'k',L'i',L'y',L'o',L's',L'e',L',',L'k',L'o',L'd',L'a',L'i',L'r',L'a',L',',L'k',L'o',L'g',L'a',L'n',L'e',L'i',L',',L'k',L'o',L'k',L'u',L'b',L'u',L'n',L'j',L'i',L',',L'k',L'o',L'm',L'a',L'e',L',',L'k',L'o',L't',L'o',L',',L'k',L'o',L'u',L'z',L'u',L's',L'h',L'i',L'm',L'a',L',',L'k',L'u',L'n',L'i',L't',L'a',L'c',L'h',L'i',L',',L'm',L'a',L'c',L'h',L'i',L'd',L'a',L',',L'm',L'e',L'g',L'u',L'r',L'o',L',',L'm',L'i',L'n',L'a',L't',L'o',L',',L'm',L'i',L't',L'a',L'k',L'a',L',',L'm',L'i',
+	L'z',L'u',L'h',L'o',L',',L'm',L'u',L's',L'a',L's',L'h',L'i',L'm',L'u',L'r',L'a',L'y',L'a',L'm',L'a',L',',L'm',L'u',L's',L'a',L's',L'h',L'i',L'n',L'o',L',',L'n',L'a',L'k',L'a',L'n',L'o',L',',L'n',L'e',L'r',L'i',L'm',L'a',L',',L'o',L'g',L'a',L's',L'a',L'w',L'a',L'r',L'a',L',',L'o',L'k',L'u',L't',L'a',L'm',L'a',L',',L'o',L'm',L'e',L',',L'o',L's',L'h',L'i',L'm',L'a',L',',L'o',L't',L'a',L',',L's',L'e',L't',L'a',L'g',L'a',L'y',L'a',L',',L's',L'h',L'i',L'b',L'u',L'y',L'a',L',',L's',L'h',L'i',L'n',L'a',
+	L'g',L'a',L'w',L'a',L',',L's',L'h',L'i',L'n',L'j',L'u',L'k',L'u',L',',L's',L'u',L'g',L'i',L'n',L'a',L'm',L'i',L',',L's',L'u',L'm',L'i',L'd',L'a',L',',L't',L'a',L'c',L'h',L'i',L'k',L'a',L'w',L'a',L',',L't',L'a',L'i',L't',L'o',L',',L't',L'a',L'm',L'a',L',',L't',L'o',L's',L'h',L'i',L'm',L'a',L')',L',',L't',L'o',L't',L't',L'o',L'r',L'i',L'(',L'1',L'3',L':',L'c',L'h',L'i',L'z',L'u',L',',L'h',L'i',L'n',L'o',L',',L'k',L'a',L'w',L'a',L'h',L'a',L'r',L'a',L',',L'k',L'o',L'g',L'e',L',',L'k',L'o',L't',L'o',
+	L'u',L'r',L'a',L',',L'm',L'i',L's',L'a',L's',L'a',L',',L'n',L'a',L'n',L'b',L'u',L',',L'n',L'i',L'c',L'h',L'i',L'n',L'a',L'n',L',',L's',L'a',L'k',L'a',L'i',L'm',L'i',L'n',L'a',L't',L'o',L',',L't',L'o',L't',L't',L'o',L'r',L'i',L',',L'w',L'a',L'k',L'a',L's',L'a',L',',L'y',L'a',L'z',L'u',L',',L'y',L'o',L'n',L'a',L'g',L'o',L')',L',',L't',L'o',L'y',L'a',L'm',L'a',L'(',L'2',L'4',L':',L'a',L's',L'a',L'h',L'i',L',',L'f',L'u',L'c',L'h',L'u',L',',L'f',L'u',L'k',L'u',L'm',L'i',L't',L's',L'u',L',',L'f',L'u',
+	L'n',L'a',L'h',L'a',L's',L'h',L'i',L',',L'h',L'i',L'm',L'i',L',',L'i',L'm',L'i',L'z',L'u',L',',L'i',L'n',L'a',L'm',L'i',L',',L'j',L'o',L'h',L'a',L'n',L'a',L',',L'k',L'a',L'm',L'i',L'i',L'c',L'h',L'i',L',',L'k',L'u',L'r',L'o',L'b',L'e',L',',L'n',L'a',L'k',L'a',L'n',L'i',L'i',L'k',L'a',L'w',L'a',L',',L'n',L'a',L'm',L'e',L'r',L'i',L'k',L'a',L'w',L'a',L',',L'n',L'a',L'n',L't',L'o',L',',L'n',L'y',L'u',L'z',L'e',L'n',L',',L'o',L'y',L'a',L'b',L'e',L',',L't',L'a',L'i',L'r',L'a',L',',L't',L'a',L'k',L'a',
+	L'o',L'k',L'a',L',',L't',L'a',L't',L'e',L'y',L'a',L'm',L'a',L',',L't',L'o',L'g',L'a',L',',L't',L'o',L'n',L'a',L'm',L'i',L',',L't',L'o',L'y',L'a',L'm',L'a',L',',L'u',L'n',L'a',L'z',L'u',L'k',L'i',L',',L'u',L'o',L'z',L'u',L',',L'y',L'a',L'm',L'a',L'd',L'a',L')',L',',L'w',L'a',L'k',L'a',L'y',L'a',L'm',L'a',L'(',L'2',L'9',L':',L'a',L'r',L'i',L'd',L'a',L',',L'a',L'r',L'i',L'd',L'a',L'g',L'a',L'w',L'a',L',',L'g',L'o',L'b',L'o',L',',L'h',L'a',L's',L'h',L'i',L'm',L'o',L't',L'o',L',',L'h',L'i',L'd',L'a',
+	L'k',L'a',L',',L'h',L'i',L'r',L'o',L'g',L'a',L'w',L'a',L',',L'i',L'n',L'a',L'm',L'i',L',',L'i',L'w',L'a',L'd',L'e',L',',L'k',L'a',L'i',L'n',L'a',L'n',L',',L'k',L'a',L'm',L'i',L't',L'o',L'n',L'd',L'a',L',',L'k',L'a',L't',L's',L'u',L'r',L'a',L'g',L'i',L',',L'k',L'i',L'm',L'i',L'n',L'o',L',',L'k',L'i',L'n',L'o',L'k',L'a',L'w',L'a',L',',L'k',L'i',L't',L'a',L'y',L'a',L'm',L'a',L',',L'k',L'o',L'y',L'a',L',',L'k',L'o',L'z',L'a',L',',L'k',L'o',L'z',L'a',L'g',L'a',L'w',L'a',L',',L'k',L'u',L'd',L'o',L'y',
+	L'a',L'm',L'a',L',',L'k',L'u',L's',L'h',L'i',L'm',L'o',L't',L'o',L',',L'm',L'i',L'h',L'a',L'm',L'a',L',',L'm',L'i',L's',L'a',L't',L'o',L',',L'n',L'a',L'c',L'h',L'i',L'k',L'a',L't',L's',L'u',L'u',L'r',L'a',L',',L's',L'h',L'i',L'n',L'g',L'u',L',',L's',L'h',L'i',L'r',L'a',L'h',L'a',L'm',L'a',L',',L't',L'a',L'i',L'j',L'i',L',',L't',L'a',L'n',L'a',L'b',L'e',L',',L'w',L'a',L'k',L'a',L'y',L'a',L'm',L'a',L',',L'y',L'u',L'a',L's',L'a',L',',L'y',L'u',L'r',L'a',L')',L',',L'y',L'a',L'm',L'a',L'g',L'a',L't',
+	L'a',L'(',L'3',L'4',L':',L'a',L's',L'a',L'h',L'i',L',',L'f',L'u',L'n',L'a',L'g',L'a',L't',L'a',L',',L'h',L'i',L'g',L'a',L's',L'h',L'i',L'n',L'e',L',',L'i',L'i',L'd',L'e',L',',L'k',L'a',L'h',L'o',L'k',L'u',L',',L'k',L'a',L'm',L'i',L'n',L'o',L'y',L'a',L'm',L'a',L',',L'k',L'a',L'n',L'e',L'y',L'a',L'm',L'a',L',',L'k',L'a',L'w',L'a',L'n',L'i',L's',L'h',L'i',L',',L'm',L'a',L'm',L'u',L'r',L'o',L'g',L'a',L'w',L'a',L',',L'm',L'i',L'k',L'a',L'w',L'a',L',',L'm',L'u',L'r',L'a',L'y',L'a',L'm',L'a',L',',L'n',
+	L'a',L'g',L'a',L'i',L',',L'n',L'a',L'k',L'a',L'y',L'a',L'm',L'a',L',',L'n',L'a',L'n',L'y',L'o',L',',L'n',L'i',L's',L'h',L'i',L'k',L'a',L'w',L'a',L',',L'o',L'b',L'a',L'n',L'a',L'z',L'a',L'w',L'a',L',',L'o',L'e',L',',L'o',L'g',L'u',L'n',L'i',L',',L'o',L'h',L'k',L'u',L'r',L'a',L',',L'o',L'i',L's',L'h',L'i',L'd',L'a',L',',L's',L'a',L'g',L'a',L'e',L',',L's',L'a',L'k',L'a',L't',L'a',L',',L's',L'a',L'k',L'e',L'g',L'a',L'w',L'a',L',',L's',L'h',L'i',L'n',L'j',L'o',L',',L's',L'h',L'i',L'r',L'a',L't',L'a',
+	L'k',L'a',L',',L's',L'h',L'o',L'n',L'a',L'i',L',',L't',L'a',L'k',L'a',L'h',L'a',L't',L'a',L',',L't',L'e',L'n',L'd',L'o',L',',L't',L'o',L'z',L'a',L'w',L'a',L',',L't',L's',L'u',L'r',L'u',L'o',L'k',L'a',L',',L'y',L'a',L'm',L'a',L'g',L'a',L't',L'a',L',',L'y',L'a',L'm',L'a',L'n',L'o',L'b',L'e',L',',L'y',L'o',L'n',L'e',L'z',L'a',L'w',L'a',L',',L'y',L'u',L'z',L'a',L')',L',',L'y',L'a',L'm',L'a',L'g',L'u',L'c',L'h',L'i',L'(',L'1',L'6',L':',L'a',L'b',L'u',L',',L'h',L'a',L'g',L'i',L',',L'h',L'i',L'k',L'a',
+	L'r',L'i',L',',L'h',L'o',L'f',L'u',L',',L'i',L'w',L'a',L'k',L'u',L'n',L'i',L',',L'k',L'u',L'd',L'a',L'm',L'a',L't',L's',L'u',L',',L'm',L'i',L't',L'o',L'u',L',',L'n',L'a',L'g',L'a',L't',L'o',L',',L'o',L's',L'h',L'i',L'm',L'a',L',',L's',L'h',L'i',L'm',L'o',L'n',L'o',L's',L'e',L'k',L'i',L',',L's',L'h',L'u',L'n',L'a',L'n',L',',L't',L'a',L'b',L'u',L's',L'e',L',',L't',L'o',L'k',L'u',L'y',L'a',L'm',L'a',L',',L't',L'o',L'y',L'o',L't',L'a',L',',L'u',L'b',L'e',L',',L'y',L'u',L'u',L')',L',',L'y',L'a',L'm',
+	L'a',L'n',L'a',L's',L'h',L'i',L'(',L'2',L'8',L':',L'c',L'h',L'u',L'o',L',',L'd',L'o',L's',L'h',L'i',L',',L'f',L'u',L'e',L'f',L'u',L'k',L'i',L',',L'f',L'u',L'j',L'i',L'k',L'a',L'w',L'a',L',',L'f',L'u',L'j',L'i',L'k',L'a',L'w',L'a',L'g',L'u',L'c',L'h',L'i',L'k',L'o',L',',L'f',L'u',L'j',L'i',L'y',L'o',L's',L'h',L'i',L'd',L'a',L',',L'h',L'a',L'y',L'a',L'k',L'a',L'w',L'a',L',',L'h',L'o',L'k',L'u',L't',L'o',L',',L'i',L'c',L'h',L'i',L'k',L'a',L'w',L'a',L'm',L'i',L's',L'a',L't',L'o',L',',L'k',L'a',L'i',
+	L',',L'k',L'o',L'f',L'u',L',',L'k',L'o',L's',L'h',L'u',L',',L'k',L'o',L's',L'u',L'g',L'e',L',',L'm',L'i',L'n',L'a',L'm',L'i',L'-',L'a',L'l',L'p',L's',L',',L'm',L'i',L'n',L'o',L'b',L'u',L',',L'n',L'a',L'k',L'a',L'm',L'i',L'c',L'h',L'i',L',',L'n',L'a',L'n',L'b',L'u',L',',L'n',L'a',L'r',L'u',L's',L'a',L'w',L'a',L',',L'n',L'i',L'r',L'a',L's',L'a',L'k',L'i',L',',L'n',L'i',L's',L'h',L'i',L'k',L'a',L't',L's',L'u',L'r',L'a',L',',L'o',L's',L'h',L'i',L'n',L'o',L',',L'o',L't',L's',L'u',L'k',L'i',L',',L's',
+	L'h',L'o',L'w',L'a',L',',L't',L'a',L'b',L'a',L'y',L'a',L'm',L'a',L',',L't',L's',L'u',L'r',L'u',L',',L'u',L'e',L'n',L'o',L'h',L'a',L'r',L'a',L',',L'y',L'a',L'm',L'a',L'n',L'a',L'k',L'a',L'k',L'o',L',',L'y',L'a',L'm',L'a',L'n',L'a',L's',L'h',L'i',L')',L',',L'k',L'a',L'w',L'a',L's',L'a',L'k',L'i',L'(',L'2',L':',L'*',L',',L'c',L'i',L't',L'y',L'(',L'1',L':',L'!',L')',L')',L',',L'k',L'i',L't',L'a',L'k',L'y',L'u',L's',L'h',L'u',L'(',L'2',L':',L'*',L',',L'c',L'i',L't',L'y',L'(',L'1',L':',L'!',L')',L')',
+	L',',L'k',L'o',L'b',L'e',L'(',L'2',L':',L'*',L',',L'c',L'i',L't',L'y',L'(',L'1',L':',L'!',L')',L')',L',',L'n',L'a',L'g',L'o',L'y',L'a',L'(',L'2',L':',L'*',L',',L'c',L'i',L't',L'y',L'(',L'1',L':',L'!',L')',L')',L',',L's',L'a',L'p',L'p',L'o',L'r',L'o',L'(',L'2',L':',L'*',L',',L'c',L'i',L't',L'y',L'(',L'1',L':',L'!',L')',L')',L',',L's',L'e',L'n',L'd',L'a',L'i',L'(',L'2',L':',L'*',L',',L'c',L'i',L't',L'y',L'(',L'1',L':',L'!',L')',L')',L',',L'y',L'o',L'k',L'o',L'h',L'a',L'm',L'a',L'(',L'2',L':',L'*',
+	L',',L'c',L'i',L't',L'y',L'(',L'1',L':',L'!',L')',L')',L')',L',',L'k',L'e',L'(',L'1',L':',L'*',L')',L',',L'k',L'g',L'(',L'6',L':',L'o',L'r',L'g',L',',L'n',L'e',L't',L',',L'c',L'o',L'm',L',',L'e',L'd',L'u',L',',L'g',L'o',L'v',L',',L'm',L'i',L'l',L')',L',',L'k',L'h',L'(',L'1',L':',L'*',L')',L',',L'k',L'i',L'(',L'7',L':',L'e',L'd',L'u',L',',L'b',L'i',L'z',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L',',L'g',L'o',L'v',L',',L'i',L'n',L'f',L'o',L',',L'c',L'o',L'm',L')',L',',L'k',L'm',L'(',L'1',L'7',L':',
+	L'o',L'r',L'g',L',',L'n',L'o',L'm',L',',L'g',L'o',L'v',L',',L'p',L'r',L'd',L',',L't',L'm',L',',L'e',L'd',L'u',L',',L'm',L'i',L'l',L',',L'a',L's',L's',L',',L'c',L'o',L'm',L',',L'c',L'o',L'o',L'p',L',',L'a',L's',L's',L'o',L',',L'p',L'r',L'e',L's',L's',L'e',L',',L'm',L'e',L'd',L'e',L'c',L'i',L'n',L',',L'n',L'o',L't',L'a',L'i',L'r',L'e',L's',L',',L'p',L'h',L'a',L'r',L'm',L'a',L'c',L'i',L'e',L'n',L's',L',',L'v',L'e',L't',L'e',L'r',L'i',L'n',L'a',L'i',L'r',L'e',L',',L'g',L'o',L'u',L'v',L')',L',',L'k',
+	L'n',L'(',L'4',L':',L'n',L'e',L't',L',',L'o',L'r',L'g',L',',L'e',L'd',L'u',L',',L'g',L'o',L'v',L')',L',',L'k',L'p',L'(',L'6',L':',L'c',L'o',L'm',L',',L'e',L'd',L'u',L',',L'g',L'o',L'v',L',',L'o',L'r',L'g',L',',L'r',L'e',L'p',L',',L't',L'r',L'a',L')',L',',L'k',L'r',L'(',L'2',L'9',L':',L'a',L'c',L',',L'c',L'o',L',',L'e',L's',L',',L'g',L'o',L',',L'h',L's',L',',L'k',L'g',L',',L'm',L'i',L'l',L',',L'm',L's',L',',L'n',L'e',L',',L'o',L'r',L',',L'p',L'e',L',',L'r',L'e',L',',L's',L'c',L',',L'b',L'u',L's',
+	L'a',L'n',L',',L'c',L'h',L'u',L'n',L'g',L'b',L'u',L'k',L',',L'c',L'h',L'u',L'n',L'g',L'n',L'a',L'm',L',',L'd',L'a',L'e',L'g',L'u',L',',L'd',L'a',L'e',L'j',L'e',L'o',L'n',L',',L'g',L'a',L'n',L'g',L'w',L'o',L'n',L',',L'g',L'w',L'a',L'n',L'g',L'j',L'u',L',',L'g',L'y',L'e',L'o',L'n',L'g',L'b',L'u',L'k',L',',L'g',L'y',L'e',L'o',L'n',L'g',L'g',L'i',L',',L'g',L'y',L'e',L'o',L'n',L'g',L'n',L'a',L'm',L',',L'i',L'n',L'c',L'h',L'e',L'o',L'n',L',',L'j',L'e',L'j',L'u',L',',L'j',L'e',L'o',L'n',L'b',L'u',L'k',
+	L',',L'j',L'e',L'o',L'n',L'n',L'a',L'm',L',',L's',L'e',L'o',L'u',L'l',L',',L'u',L'l',L's',L'a',L'n',L')',L',',L'k',L'w',L'(',L'1',L':',L'*',L')',L',',L'k',L'y',L'(',L'5',L':',L'e',L'd',L'u',L',',L'g',L'o',L'v',L',',L'c',L'o',L'm',L',',L'o',L'r',L'g',L',',L'n',L'e',L't',L')',L',',L'k',L'z',L'(',L'6',L':',L'o',L'r',L'g',L',',L'e',L'd',L'u',L',',L'n',L'e',L't',L',',L'g',L'o',L'v',L',',L'm',L'i',L'l',L',',L'c',L'o',L'm',L')',L',',L'l',L'a',L'(',L'9',L':',L'i',L'n',L't',L',',L'n',L'e',L't',L',',L'i',
+	L'n',L'f',L'o',L',',L'e',L'd',L'u',L',',L'g',L'o',L'v',L',',L'p',L'e',L'r',L',',L'c',L'o',L'm',L',',L'o',L'r',L'g',L',',L'c',L')',L',',L'l',L'b',L'(',L'5',L':',L'c',L'o',L'm',L',',L'e',L'd',L'u',L',',L'g',L'o',L'v',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L')',L',',L'l',L'c',L'(',L'6',L':',L'c',L'o',L'm',L',',L'n',L'e',L't',L',',L'c',L'o',L',',L'o',L'r',L'g',L',',L'e',L'd',L'u',L',',L'g',L'o',L'v',L')',L',',L'l',L'i',L',',L'l',L'k',L'(',L'1',L'4',L':',L'g',L'o',L'v',L',',L's',L'c',L'h',L',',L'n',
+	L'e',L't',L',',L'i',L'n',L't',L',',L'c',L'o',L'm',L',',L'o',L'r',L'g',L',',L'e',L'd',L'u',L',',L'n',L'g',L'o',L',',L's',L'o',L'c',L',',L'w',L'e',L'b',L',',L'l',L't',L'd',L',',L'a',L's',L's',L'n',L',',L'g',L'r',L'p',L',',L'h',L'o',L't',L'e',L'l',L')',L',',L'l',L'r',L'(',L'5',L':',L'c',L'o',L'm',L',',L'e',L'd',L'u',L',',L'g',L'o',L'v',L',',L'o',L'r',L'g',L',',L'n',L'e',L't',L')',L',',L'l',L's',L'(',L'2',L':',L'c',L'o',L',',L'o',L'r',L'g',L')',L',',L'l',L't',L'(',L'1',L':',L'g',L'o',L'v',L')',L',',
+	L'l',L'u',L',',L'l',L'v',L'(',L'9',L':',L'c',L'o',L'm',L',',L'e',L'd',L'u',L',',L'g',L'o',L'v',L',',L'o',L'r',L'g',L',',L'm',L'i',L'l',L',',L'i',L'd',L',',L'n',L'e',L't',L',',L'a',L's',L'n',L',',L'c',L'o',L'n',L'f',L')',L',',L'l',L'y',L'(',L'9',L':',L'c',L'o',L'm',L',',L'n',L'e',L't',L',',L'g',L'o',L'v',L',',L'p',L'l',L'c',L',',L'e',L'd',L'u',L',',L's',L'c',L'h',L',',L'm',L'e',L'd',L',',L'o',L'r',L'g',L',',L'i',L'd',L')',L',',L'm',L'a',L'(',L'6',L':',L'c',L'o',L',',L'n',L'e',L't',L',',L'g',L'o',
+	L'v',L',',L'o',L'r',L'g',L',',L'a',L'c',L',',L'p',L'r',L'e',L's',L's',L')',L',',L'm',L'c',L'(',L'2',L':',L't',L'm',L',',L'a',L's',L's',L'o',L')',L',',L'm',L'd',L',',L'm',L'e',L'(',L'8',L':',L'c',L'o',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L',',L'e',L'd',L'u',L',',L'a',L'c',L',',L'g',L'o',L'v',L',',L'i',L't',L's',L',',L'p',L'r',L'i',L'v',L')',L',',L'm',L'g',L'(',L'8',L':',L'o',L'r',L'g',L',',L'n',L'o',L'm',L',',L'g',L'o',L'v',L',',L'p',L'r',L'd',L',',L't',L'm',L',',L'e',L'd',L'u',L',',L'm',L'i',
+	L'l',L',',L'c',L'o',L'm',L')',L',',L'm',L'h',L',',L'm',L'i',L'l',L',',L'm',L'k',L'(',L'7',L':',L'c',L'o',L'm',L',',L'o',L'r',L'g',L',',L'n',L'e',L't',L',',L'e',L'd',L'u',L',',L'g',L'o',L'v',L',',L'i',L'n',L'f',L',',L'n',L'a',L'm',L'e',L')',L',',L'm',L'l',L'(',L'7',L':',L'c',L'o',L'm',L',',L'e',L'd',L'u',L',',L'g',L'o',L'u',L'v',L',',L'g',L'o',L'v',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L',',L'p',L'r',L'e',L's',L's',L'e',L')',L',',L'm',L'm',L'(',L'1',L':',L'*',L')',L',',L'm',L'n',L'(',L'3',L':',
+	L'g',L'o',L'v',L',',L'e',L'd',L'u',L',',L'o',L'r',L'g',L')',L',',L'm',L'o',L'(',L'5',L':',L'c',L'o',L'm',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L',',L'e',L'd',L'u',L',',L'g',L'o',L'v',L')',L',',L'm',L'o',L'b',L'i',L',',L'm',L'p',L',',L'm',L'q',L',',L'm',L'r',L'(',L'1',L':',L'g',L'o',L'v',L')',L',',L'm',L's',L',',L'm',L't',L'(',L'1',L':',L'*',L')',L',',L'm',L'u',L'(',L'7',L':',L'c',L'o',L'm',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L',',L'g',L'o',L'v',L',',L'a',L'c',L',',L'c',L'o',L',',L'o',L'r',
+	L')',L',',L'm',L'u',L's',L'e',L'u',L'm',L'(',L'5',L'4',L'8',L':',L'a',L'c',L'a',L'd',L'e',L'm',L'y',L',',L'a',L'g',L'r',L'i',L'c',L'u',L'l',L't',L'u',L'r',L'e',L',',L'a',L'i',L'r',L',',L'a',L'i',L'r',L'g',L'u',L'a',L'r',L'd',L',',L'a',L'l',L'a',L'b',L'a',L'm',L'a',L',',L'a',L'l',L'a',L's',L'k',L'a',L',',L'a',L'm',L'b',L'e',L'r',L',',L'a',L'm',L'b',L'u',L'l',L'a',L'n',L'c',L'e',L',',L'a',L'm',L'e',L'r',L'i',L'c',L'a',L'n',L',',L'a',L'm',L'e',L'r',L'i',L'c',L'a',L'n',L'a',L',',L'a',L'm',L'e',L'r',
+	L'i',L'c',L'a',L'n',L'a',L'n',L't',L'i',L'q',L'u',L'e',L's',L',',L'a',L'm',L'e',L'r',L'i',L'c',L'a',L'n',L'a',L'r',L't',L',',L'a',L'm',L's',L't',L'e',L'r',L'd',L'a',L'm',L',',L'a',L'n',L'd',L',',L'a',L'n',L'n',L'e',L'f',L'r',L'a',L'n',L'k',L',',L'a',L'n',L't',L'h',L'r',L'o',L',',L'a',L'n',L't',L'h',L'r',L'o',L'p',L'o',L'l',L'o',L'g',L'y',L',',L'a',L'n',L't',L'i',L'q',L'u',L'e',L's',L',',L'a',L'q',L'u',L'a',L'r',L'i',L'u',L'm',L',',L'a',L'r',L'b',L'o',L'r',L'e',L't',L'u',L'm',L',',L'a',L'r',L'c',
+	L'h',L'a',L'e',L'o',L'l',L'o',L'g',L'i',L'c',L'a',L'l',L',',L'a',L'r',L'c',L'h',L'a',L'e',L'o',L'l',L'o',L'g',L'y',L',',L'a',L'r',L'c',L'h',L'i',L't',L'e',L'c',L't',L'u',L'r',L'e',L',',L'a',L'r',L't',L',',L'a',L'r',L't',L'a',L'n',L'd',L'd',L'e',L's',L'i',L'g',L'n',L',',L'a',L'r',L't',L'c',L'e',L'n',L't',L'e',L'r',L',',L'a',L'r',L't',L'd',L'e',L'c',L'o',L',',L'a',L'r',L't',L'e',L'd',L'u',L'c',L'a',L't',L'i',L'o',L'n',L',',L'a',L'r',L't',L'g',L'a',L'l',L'l',L'e',L'r',L'y',L',',L'a',L'r',L't',L's',
+	L',',L'a',L'r',L't',L's',L'a',L'n',L'd',L'c',L'r',L'a',L'f',L't',L's',L',',L'a',L's',L'm',L'a',L't',L'a',L'r',L't',L',',L'a',L's',L's',L'a',L's',L's',L'i',L'n',L'a',L't',L'i',L'o',L'n',L',',L'a',L's',L's',L'i',L's',L'i',L',',L'a',L's',L's',L'o',L'c',L'i',L'a',L't',L'i',L'o',L'n',L',',L'a',L's',L't',L'r',L'o',L'n',L'o',L'm',L'y',L',',L'a',L't',L'l',L'a',L'n',L't',L'a',L',',L'a',L'u',L's',L't',L'i',L'n',L',',L'a',L'u',L's',L't',L'r',L'a',L'l',L'i',L'a',L',',L'a',L'u',L't',L'o',L'm',L'o',L't',L'i',
+	L'v',L'e',L',',L'a',L'v',L'i',L'a',L't',L'i',L'o',L'n',L',',L'a',L'x',L'i',L's',L',',L'b',L'a',L'd',L'a',L'j',L'o',L'z',L',',L'b',L'a',L'g',L'h',L'd',L'a',L'd',L',',L'b',L'a',L'h',L'n',L',',L'b',L'a',L'l',L'e',L',',L'b',L'a',L'l',L't',L'i',L'm',L'o',L'r',L'e',L',',L'b',L'a',L'r',L'c',L'e',L'l',L'o',L'n',L'a',L',',L'b',L'a',L's',L'e',L'b',L'a',L'l',L'l',L',',L'b',L'a',L's',L'e',L'l',L',',L'b',L'a',L't',L'h',L's',L',',L'b',L'a',L'u',L'e',L'r',L'n',L',',L'b',L'e',L'a',L'u',L'x',L'a',L'r',L't',L's',
+	L',',L'b',L'e',L'e',L'l',L'd',L'e',L'n',L'g',L'e',L'l',L'u',L'i',L'd',L',',L'b',L'e',L'l',L'l',L'e',L'v',L'u',L'e',L',',L'b',L'e',L'r',L'g',L'b',L'a',L'u',L',',L'b',L'e',L'r',L'k',L'e',L'l',L'e',L'y',L',',L'b',L'e',L'r',L'l',L'i',L'n',L',',L'b',L'e',L'r',L'n',L',',L'b',L'i',L'b',L'l',L'e',L',',L'b',L'i',L'l',L'b',L'a',L'o',L',',L'b',L'i',L'l',L'l',L',',L'b',L'i',L'r',L'd',L'a',L'r',L't',L',',L'b',L'i',L'r',L't',L'h',L'p',L'l',L'a',L'c',L'e',L',',L'b',L'o',L'n',L'n',L',',L'b',L'o',L's',L't',L'o',
+	L'n',L',',L'b',L'o',L't',L'a',L'n',L'i',L'c',L'a',L'l',L',',L'b',L'o',L't',L'a',L'n',L'i',L'c',L'a',L'l',L'g',L'a',L'r',L'd',L'e',L'n',L',',L'b',L'o',L't',L'a',L'n',L'i',L'c',L'g',L'a',L'r',L'd',L'e',L'n',L',',L'b',L'o',L't',L'a',L'n',L'y',L',',L'b',L'r',L'a',L'n',L'd',L'y',L'w',L'i',L'n',L'e',L'v',L'a',L'l',L'l',L'e',L'y',L',',L'b',L'r',L'a',L's',L'i',L'l',L',',L'b',L'r',L'i',L's',L't',L'o',L'l',L',',L'b',L'r',L'i',L't',L'i',L's',L'h',L',',L'b',L'r',L'i',L't',L'i',L's',L'h',L'c',L'o',L'l',L'u',
+	L'm',L'b',L'i',L'a',L',',L'b',L'r',L'o',L'a',L'd',L'c',L'a',L's',L't',L',',L'b',L'r',L'u',L'n',L'e',L'l',L',',L'b',L'r',L'u',L's',L's',L'e',L'l',L',',L'b',L'r',L'u',L's',L's',L'e',L'l',L's',L',',L'b',L'r',L'u',L'x',L'e',L'l',L'l',L'e',L's',L',',L'b',L'u',L'i',L'l',L'd',L'i',L'n',L'g',L',',L'b',L'u',L'r',L'g',L'h',L'o',L'f',L',',L'b',L'u',L's',L',',L'b',L'u',L's',L'h',L'e',L'y',L',',L'c',L'a',L'd',L'a',L'q',L'u',L'e',L's',L',',L'c',L'a',L'l',L'i',L'f',L'o',L'r',L'n',L'i',L'a',L',',L'c',L'a',L'm',
+	L'b',L'r',L'i',L'd',L'g',L'e',L',',L'c',L'a',L'n',L',',L'c',L'a',L'n',L'a',L'd',L'a',L',',L'c',L'a',L'p',L'e',L'b',L'r',L'e',L't',L'o',L'n',L',',L'c',L'a',L'r',L'r',L'i',L'e',L'r',L',',L'c',L'a',L'r',L't',L'o',L'o',L'n',L'a',L'r',L't',L',',L'c',L'a',L's',L'a',L'd',L'e',L'l',L'a',L'm',L'o',L'n',L'e',L'd',L'a',L',',L'c',L'a',L's',L't',L'l',L'e',L',',L'c',L'a',L's',L't',L'r',L'e',L's',L',',L'c',L'e',L'l',L't',L'i',L'c',L',',L'c',L'e',L'n',L't',L'e',L'r',L',',L'c',L'h',L'a',L't',L't',L'a',L'n',L'o',
+	L'o',L'g',L'a',L',',L'c',L'h',L'e',L'l',L't',L'e',L'n',L'h',L'a',L'm',L',',L'c',L'h',L'e',L's',L'a',L'p',L'e',L'a',L'k',L'e',L'b',L'a',L'y',L',',L'c',L'h',L'i',L'c',L'a',L'g',L'o',L',',L'c',L'h',L'i',L'l',L'd',L'r',L'e',L'n',L',',L'c',L'h',L'i',L'l',L'd',L'r',L'e',L'n',L's',L',',L'c',L'h',L'i',L'l',L'd',L'r',L'e',L'n',L's',L'g',L'a',L'r',L'd',L'e',L'n',L',',L'c',L'h',L'i',L'r',L'o',L'p',L'r',L'a',L'c',L't',L'i',L'c',L',',L'c',L'h',L'o',L'c',L'o',L'l',L'a',L't',L'e',L',',L'c',L'h',L'r',L'i',L's',
+	L't',L'i',L'a',L'n',L's',L'b',L'u',L'r',L'g',L',',L'c',L'i',L'n',L'c',L'i',L'n',L'n',L'a',L't',L'i',L',',L'c',L'i',L'n',L'e',L'm',L'a',L',',L'c',L'i',L'r',L'c',L'u',L's',L',',L'c',L'i',L'v',L'i',L'l',L'i',L's',L'a',L't',L'i',L'o',L'n',L',',L'c',L'i',L'v',L'i',L'l',L'i',L'z',L'a',L't',L'i',L'o',L'n',L',',L'c',L'i',L'v',L'i',L'l',L'w',L'a',L'r',L',',L'c',L'l',L'i',L'n',L't',L'o',L'n',L',',L'c',L'l',L'o',L'c',L'k',L',',L'c',L'o',L'a',L'l',L',',L'c',L'o',L'a',L's',L't',L'a',L'l',L'd',L'e',L'f',L'e',
+	L'n',L'c',L'e',L',',L'c',L'o',L'd',L'y',L',',L'c',L'o',L'l',L'd',L'w',L'a',L'r',L',',L'c',L'o',L'l',L'l',L'e',L'c',L't',L'i',L'o',L'n',L',',L'c',L'o',L'l',L'o',L'n',L'i',L'a',L'l',L'w',L'i',L'l',L'l',L'i',L'a',L'm',L's',L'b',L'u',L'r',L'g',L',',L'c',L'o',L'l',L'o',L'r',L'a',L'd',L'o',L'p',L'l',L'a',L't',L'e',L'a',L'u',L',',L'c',L'o',L'l',L'u',L'm',L'b',L'i',L'a',L',',L'c',L'o',L'l',L'u',L'm',L'b',L'u',L's',L',',L'c',L'o',L'm',L'm',L'u',L'n',L'i',L'c',L'a',L't',L'i',L'o',L'n',L',',L'c',L'o',L'm',
+	L'm',L'u',L'n',L'i',L'c',L'a',L't',L'i',L'o',L'n',L's',L',',L'c',L'o',L'm',L'm',L'u',L'n',L'i',L't',L'y',L',',L'c',L'o',L'm',L'p',L'u',L't',L'e',L'r',L',',L'c',L'o',L'm',L'p',L'u',L't',L'e',L'r',L'h',L'i',L's',L't',L'o',L'r',L'y',L',',L'c',L'o',L'm',L'u',L'n',L'i',L'c',L'a',L'ç',L'õ',L'e',L's',L',',L'c',L'o',L'n',L't',L'e',L'm',L'p',L'o',L'r',L'a',L'r',L'y',L',',L'c',L'o',L'n',L't',L'e',L'm',L'p',L'o',L'r',L'a',L'r',L'y',L'a',L'r',L't',L',',L'c',L'o',L'n',L'v',L'e',L'n',L't',L',',L'c',L'o',L'p',
+	L'e',L'n',L'h',L'a',L'g',L'e',L'n',L',',L'c',L'o',L'r',L'p',L'o',L'r',L'a',L't',L'i',L'o',L'n',L',',L'c',L'o',L'r',L'r',L'e',L'i',L'o',L's',L'-',L'e',L'-',L't',L'e',L'l',L'e',L'c',L'o',L'm',L'u',L'n',L'i',L'c',L'a',L'ç',L'õ',L'e',L's',L',',L'c',L'o',L'r',L'v',L'e',L't',L't',L'e',L',',L'c',L'o',L's',L't',L'u',L'm',L'e',L',',L'c',L'o',L'u',L'n',L't',L'r',L'y',L'e',L's',L't',L'a',L't',L'e',L',',L'c',L'o',L'u',L'n',L't',L'y',L',',L'c',L'r',L'a',L'f',L't',L's',L',',L'c',L'r',L'a',L'n',L'b',L'r',L'o',
+	L'o',L'k',L',',L'c',L'r',L'e',L'a',L't',L'i',L'o',L'n',L',',L'c',L'u',L'l',L't',L'u',L'r',L'a',L'l',L',',L'c',L'u',L'l',L't',L'u',L'r',L'a',L'l',L'c',L'e',L'n',L't',L'e',L'r',L',',L'c',L'u',L'l',L't',L'u',L'r',L'e',L',',L'c',L'y',L'b',L'e',L'r',L',',L'c',L'y',L'm',L'r',L'u',L',',L'd',L'a',L'l',L'i',L',',L'd',L'a',L'l',L'l',L'a',L's',L',',L'd',L'a',L't',L'a',L'b',L'a',L's',L'e',L',',L'd',L'd',L'r',L',',L'd',L'e',L'c',L'o',L'r',L'a',L't',L'i',L'v',L'e',L'a',L'r',L't',L's',L',',L'd',L'e',L'l',L'a',
+	L'w',L'a',L'r',L'e',L',',L'd',L'e',L'l',L'm',L'e',L'n',L'h',L'o',L'r',L's',L't',L',',L'd',L'e',L'n',L'm',L'a',L'r',L'k',L',',L'd',L'e',L'p',L'o',L't',L',',L'd',L'e',L's',L'i',L'g',L'n',L',',L'd',L'e',L't',L'r',L'o',L'i',L't',L',',L'd',L'i',L'n',L'o',L's',L'a',L'u',L'r',L',',L'd',L'i',L's',L'c',L'o',L'v',L'e',L'r',L'y',L',',L'd',L'o',L'l',L'l',L's',L',',L'd',L'o',L'n',L'o',L's',L't',L'i',L'a',L',',L'd',L'u',L'r',L'h',L'a',L'm',L',',L'e',L'a',L's',L't',L'a',L'f',L'r',L'i',L'c',L'a',L',',L'e',L'a',
+	L's',L't',L'c',L'o',L'a',L's',L't',L',',L'e',L'd',L'u',L'c',L'a',L't',L'i',L'o',L'n',L',',L'e',L'd',L'u',L'c',L'a',L't',L'i',L'o',L'n',L'a',L'l',L',',L'e',L'g',L'y',L'p',L't',L'i',L'a',L'n',L',',L'e',L'i',L's',L'e',L'n',L'b',L'a',L'h',L'n',L',',L'e',L'l',L'b',L'u',L'r',L'g',L',',L'e',L'l',L'v',L'e',L'n',L'd',L'r',L'e',L'l',L'l',L',',L'e',L'm',L'b',L'r',L'o',L'i',L'd',L'e',L'r',L'y',L',',L'e',L'n',L'c',L'y',L'c',L'l',L'o',L'p',L'e',L'd',L'i',L'c',L',',L'e',L'n',L'g',L'l',L'a',L'n',L'd',L',',L'e',
+	L'n',L't',L'o',L'm',L'o',L'l',L'o',L'g',L'y',L',',L'e',L'n',L'v',L'i',L'r',L'o',L'n',L'm',L'e',L'n',L't',L',',L'e',L'n',L'v',L'i',L'r',L'o',L'n',L'm',L'e',L'n',L't',L'a',L'l',L'c',L'o',L'n',L's',L'e',L'r',L'v',L'a',L't',L'i',L'o',L'n',L',',L'e',L'p',L'i',L'l',L'e',L'p',L's',L'y',L',',L'e',L's',L's',L'e',L'x',L',',L'e',L's',L't',L'a',L't',L'e',L',',L'e',L't',L'h',L'n',L'o',L'l',L'o',L'g',L'y',L',',L'e',L'x',L'e',L't',L'e',L'r',L',',L'e',L'x',L'h',L'i',L'b',L'i',L't',L'i',L'o',L'n',L',',L'f',L'a',
+	L'm',L'i',L'l',L'y',L',',L'f',L'a',L'r',L'm',L',',L'f',L'a',L'r',L'm',L'e',L'q',L'u',L'i',L'p',L'm',L'e',L'n',L't',L',',L'f',L'a',L'r',L'm',L'e',L'r',L's',L',',L'f',L'a',L'r',L'm',L's',L't',L'e',L'a',L'd',L',',L'f',L'i',L'e',L'l',L'd',L',',L'f',L'i',L'g',L'u',L'e',L'r',L'e',L's',L',',L'f',L'i',L'l',L'a',L't',L'e',L'l',L'i',L'a',L',',L'f',L'i',L'l',L'm',L',',L'f',L'i',L'n',L'e',L'a',L'r',L't',L',',L'f',L'i',L'n',L'e',L'a',L'r',L't',L's',L',',L'f',L'i',L'n',L'l',L'a',L'n',L'd',L',',L'f',L'l',L'a',
+	L'n',L'd',L'e',L'r',L's',L',',L'f',L'l',L'o',L'r',L'i',L'd',L'a',L',',L'f',L'o',L'r',L'c',L'e',L',',L'f',L'o',L'r',L't',L'm',L'i',L's',L's',L'o',L'u',L'l',L'a',L',',L'f',L'o',L'r',L't',L'w',L'o',L'r',L't',L'h',L',',L'f',L'o',L'u',L'n',L'd',L'a',L't',L'i',L'o',L'n',L',',L'f',L'r',L'a',L'n',L'c',L'a',L'i',L's',L'e',L',',L'f',L'r',L'a',L'n',L'k',L'f',L'u',L'r',L't',L',',L'f',L'r',L'a',L'n',L'z',L'i',L's',L'k',L'a',L'n',L'e',L'r',L',',L'f',L'r',L'e',L'e',L'm',L'a',L's',L'o',L'n',L'r',L'y',L',',L'f',
+	L'r',L'e',L'i',L'b',L'u',L'r',L'g',L',',L'f',L'r',L'i',L'b',L'o',L'u',L'r',L'g',L',',L'f',L'r',L'o',L'g',L',',L'f',L'u',L'n',L'd',L'a',L'c',L'i',L'o',L',',L'f',L'u',L'r',L'n',L'i',L't',L'u',L'r',L'e',L',',L'g',L'a',L'l',L'l',L'e',L'r',L'y',L',',L'g',L'a',L'r',L'd',L'e',L'n',L',',L'g',L'a',L't',L'e',L'w',L'a',L'y',L',',L'g',L'e',L'e',L'l',L'v',L'i',L'n',L'c',L'k',L',',L'g',L'e',L'm',L'o',L'l',L'o',L'g',L'i',L'c',L'a',L'l',L',',L'g',L'e',L'o',L'l',L'o',L'g',L'y',L',',L'g',L'e',L'o',L'r',L'g',L'i',
+	L'a',L',',L'g',L'i',L'e',L's',L's',L'e',L'n',L',',L'g',L'l',L'a',L's',L',',L'g',L'l',L'a',L's',L's',L',',L'g',L'o',L'r',L'g',L'e',L',',L'g',L'r',L'a',L'n',L'd',L'r',L'a',L'p',L'i',L'd',L's',L',',L'g',L'r',L'a',L'z',L',',L'g',L'u',L'e',L'r',L'n',L's',L'e',L'y',L',',L'h',L'a',L'l',L'l',L'o',L'f',L'f',L'a',L'm',L'e',L',',L'h',L'a',L'm',L'b',L'u',L'r',L'g',L',',L'h',L'a',L'n',L'd',L's',L'o',L'n',L',',L'h',L'a',L'r',L'v',L'e',L's',L't',L'c',L'e',L'l',L'e',L'b',L'r',L'a',L't',L'i',L'o',L'n',L',',L'h',
+	L'a',L'w',L'a',L'i',L'i',L',',L'h',L'e',L'a',L'l',L't',L'h',L',',L'h',L'e',L'i',L'm',L'a',L't',L'u',L'n',L'd',L'u',L'h',L'r',L'e',L'n',L',',L'h',L'e',L'l',L'l',L'a',L's',L',',L'h',L'e',L'l',L's',L'i',L'n',L'k',L'i',L',',L'h',L'e',L'm',L'b',L'y',L'g',L'd',L's',L'f',L'o',L'r',L'b',L'u',L'n',L'd',L',',L'h',L'e',L'r',L'i',L't',L'a',L'g',L'e',L',',L'h',L'i',L's',L't',L'o',L'i',L'r',L'e',L',',L'h',L'i',L's',L't',L'o',L'r',L'i',L'c',L'a',L'l',L',',L'h',L'i',L's',L't',L'o',L'r',L'i',L'c',L'a',L'l',L's',
+	L'o',L'c',L'i',L'e',L't',L'y',L',',L'h',L'i',L's',L't',L'o',L'r',L'i',L'c',L'h',L'o',L'u',L's',L'e',L's',L',',L'h',L'i',L's',L't',L'o',L'r',L'i',L's',L'c',L'h',L',',L'h',L'i',L's',L't',L'o',L'r',L'i',L's',L'c',L'h',L'e',L's',L',',L'h',L'i',L's',L't',L'o',L'r',L'y',L',',L'h',L'i',L's',L't',L'o',L'r',L'y',L'o',L'f',L's',L'c',L'i',L'e',L'n',L'c',L'e',L',',L'h',L'o',L'r',L'o',L'l',L'o',L'g',L'y',L',',L'h',L'o',L'u',L's',L'e',L',',L'h',L'u',L'm',L'a',L'n',L'i',L't',L'i',L'e',L's',L',',L'i',L'l',L'l',
+	L'u',L's',L't',L'r',L'a',L't',L'i',L'o',L'n',L',',L'i',L'm',L'a',L'g',L'e',L'a',L'n',L'd',L's',L'o',L'u',L'n',L'd',L',',L'i',L'n',L'd',L'i',L'a',L'n',L',',L'i',L'n',L'd',L'i',L'a',L'n',L'a',L',',L'i',L'n',L'd',L'i',L'a',L'n',L'a',L'p',L'o',L'l',L'i',L's',L',',L'i',L'n',L'd',L'i',L'a',L'n',L'm',L'a',L'r',L'k',L'e',L't',L',',L'i',L'n',L't',L'e',L'l',L'l',L'i',L'g',L'e',L'n',L'c',L'e',L',',L'i',L'n',L't',L'e',L'r',L'a',L'c',L't',L'i',L'v',L'e',L',',L'i',L'r',L'a',L'q',L',',L'i',L'r',L'o',L'n',L',',
+	L'i',L's',L'l',L'e',L'o',L'f',L'm',L'a',L'n',L',',L'j',L'a',L'm',L'i',L's',L'o',L'n',L',',L'j',L'e',L'f',L'f',L'e',L'r',L's',L'o',L'n',L',',L'j',L'e',L'r',L'u',L's',L'a',L'l',L'e',L'm',L',',L'j',L'e',L'w',L'e',L'l',L'r',L'y',L',',L'j',L'e',L'w',L'i',L's',L'h',L',',L'j',L'e',L'w',L'i',L's',L'h',L'a',L'r',L't',L',',L'j',L'f',L'k',L',',L'j',L'o',L'u',L'r',L'n',L'a',L'l',L'i',L's',L'm',L',',L'j',L'u',L'd',L'a',L'i',L'c',L'a',L',',L'j',L'u',L'd',L'y',L'g',L'a',L'r',L'l',L'a',L'n',L'd',L',',L'j',L'u',
+	L'e',L'd',L'i',L's',L'c',L'h',L'e',L's',L',',L'j',L'u',L'i',L'f',L',',L'k',L'a',L'r',L'a',L't',L'e',L',',L'k',L'a',L'r',L'i',L'k',L'a',L't',L'u',L'r',L',',L'k',L'i',L'd',L's',L',',L'k',L'o',L'e',L'b',L'e',L'n',L'h',L'a',L'v',L'n',L',',L'k',L'o',L'e',L'l',L'n',L',',L'k',L'u',L'n',L's',L't',L',',L'k',L'u',L'n',L's',L't',L's',L'a',L'm',L'm',L'l',L'u',L'n',L'g',L',',L'k',L'u',L'n',L's',L't',L'u',L'n',L'd',L'd',L'e',L's',L'i',L'g',L'n',L',',L'l',L'a',L'b',L'o',L'r',L',',L'l',L'a',L'b',L'o',L'u',L'r',
+	L',',L'l',L'a',L'j',L'o',L'l',L'l',L'a',L',',L'l',L'a',L'n',L'c',L'a',L's',L'h',L'i',L'r',L'e',L',',L'l',L'a',L'n',L'd',L'e',L's',L',',L'l',L'a',L'n',L's',L',',L'l',L'ä',L'n',L's',L',',L'l',L'a',L'r',L's',L's',L'o',L'n',L',',L'l',L'e',L'w',L'i',L's',L'm',L'i',L'l',L'l',L'e',L'r',L',',L'l',L'i',L'n',L'c',L'o',L'l',L'n',L',',L'l',L'i',L'n',L'z',L',',L'l',L'i',L'v',L'i',L'n',L'g',L',',L'l',L'i',L'v',L'i',L'n',L'g',L'h',L'i',L's',L't',L'o',L'r',L'y',L',',L'l',L'o',L'c',L'a',L'l',L'h',L'i',L's',L't',
+	L'o',L'r',L'y',L',',L'l',L'o',L'n',L'd',L'o',L'n',L',',L'l',L'o',L's',L'a',L'n',L'g',L'e',L'l',L'e',L's',L',',L'l',L'o',L'u',L'v',L'r',L'e',L',',L'l',L'o',L'y',L'a',L'l',L'i',L's',L't',L',',L'l',L'u',L'c',L'e',L'r',L'n',L'e',L',',L'l',L'u',L'x',L'e',L'm',L'b',L'o',L'u',L'r',L'g',L',',L'l',L'u',L'z',L'e',L'r',L'n',L',',L'm',L'a',L'd',L',',L'm',L'a',L'd',L'r',L'i',L'd',L',',L'm',L'a',L'l',L'l',L'o',L'r',L'c',L'a',L',',L'm',L'a',L'n',L'c',L'h',L'e',L's',L't',L'e',L'r',L',',L'm',L'a',L'n',L's',L'i',
+	L'o',L'n',L',',L'm',L'a',L'n',L's',L'i',L'o',L'n',L's',L',',L'm',L'a',L'n',L'x',L',',L'm',L'a',L'r',L'b',L'u',L'r',L'g',L',',L'm',L'a',L'r',L'i',L't',L'i',L'm',L'e',L',',L'm',L'a',L'r',L'i',L't',L'i',L'm',L'o',L',',L'm',L'a',L'r',L'y',L'l',L'a',L'n',L'd',L',',L'm',L'a',L'r',L'y',L'l',L'h',L'u',L'r',L's',L't',L',',L'm',L'e',L'd',L'i',L'a',L',',L'm',L'e',L'd',L'i',L'c',L'a',L'l',L',',L'm',L'e',L'd',L'i',L'z',L'i',L'n',L'h',L'i',L's',L't',L'o',L'r',L'i',L's',L'c',L'h',L'e',L's',L',',L'm',L'e',L'e',
+	L'r',L'e',L's',L',',L'm',L'e',L'm',L'o',L'r',L'i',L'a',L'l',L',',L'm',L'e',L's',L'a',L'v',L'e',L'r',L'd',L'e',L',',L'm',L'i',L'c',L'h',L'i',L'g',L'a',L'n',L',',L'm',L'i',L'd',L'a',L't',L'l',L'a',L'n',L't',L'i',L'c',L',',L'm',L'i',L'l',L'i',L't',L'a',L'r',L'y',L',',L'm',L'i',L'l',L'l',L',',L'm',L'i',L'n',L'e',L'r',L's',L',',L'm',L'i',L'n',L'i',L'n',L'g',L',',L'm',L'i',L'n',L'n',L'e',L's',L'o',L't',L'a',L',',L'm',L'i',L's',L's',L'i',L'l',L'e',L',',L'm',L'i',L's',L's',L'o',L'u',L'l',L'a',L',',L'm',
+	L'o',L'd',L'e',L'r',L'n',L',',L'm',L'o',L'm',L'a',L',',L'm',L'o',L'n',L'e',L'y',L',',L'm',L'o',L'n',L'm',L'o',L'u',L't',L'h',L',',L'm',L'o',L'n',L't',L'i',L'c',L'e',L'l',L'l',L'o',L',',L'm',L'o',L'n',L't',L'r',L'e',L'a',L'l',L',',L'm',L'o',L's',L'c',L'o',L'w',L',',L'm',L'o',L't',L'o',L'r',L'c',L'y',L'c',L'l',L'e',L',',L'm',L'u',L'e',L'n',L'c',L'h',L'e',L'n',L',',L'm',L'u',L'e',L'n',L's',L't',L'e',L'r',L',',L'm',L'u',L'l',L'h',L'o',L'u',L's',L'e',L',',L'm',L'u',L'n',L'c',L'i',L'e',L',',L'm',L'u',
+	L's',L'e',L'e',L't',L',',L'm',L'u',L's',L'e',L'u',L'm',L'c',L'e',L'n',L't',L'e',L'r',L',',L'm',L'u',L's',L'e',L'u',L'm',L'v',L'e',L'r',L'e',L'n',L'i',L'g',L'i',L'n',L'g',L',',L'm',L'u',L's',L'i',L'c',L',',L'n',L'a',L't',L'i',L'o',L'n',L'a',L'l',L',',L'n',L'a',L't',L'i',L'o',L'n',L'a',L'l',L'f',L'i',L'r',L'e',L'a',L'r',L'm',L's',L',',L'n',L'a',L't',L'i',L'o',L'n',L'a',L'l',L'h',L'e',L'r',L'i',L't',L'a',L'g',L'e',L',',L'n',L'a',L't',L'i',L'v',L'e',L'a',L'm',L'e',L'r',L'i',L'c',L'a',L'n',L',',L'n',
+	L'a',L't',L'u',L'r',L'a',L'l',L'h',L'i',L's',L't',L'o',L'r',L'y',L',',L'n',L'a',L't',L'u',L'r',L'a',L'l',L'h',L'i',L's',L't',L'o',L'r',L'y',L'm',L'u',L's',L'e',L'u',L'm',L',',L'n',L'a',L't',L'u',L'r',L'a',L'l',L's',L'c',L'i',L'e',L'n',L'c',L'e',L's',L',',L'n',L'a',L't',L'u',L'r',L'e',L',',L'n',L'a',L't',L'u',L'r',L'h',L'i',L's',L't',L'o',L'r',L'i',L's',L'c',L'h',L'e',L's',L',',L'n',L'a',L't',L'u',L'u',L'r',L'w',L'e',L't',L'e',L'n',L's',L'c',L'h',L'a',L'p',L'p',L'e',L'n',L',',L'n',L'a',L'u',L'm',
+	L'b',L'u',L'r',L'g',L',',L'n',L'a',L'v',L'a',L'l',L',',L'n',L'e',L'b',L'r',L'a',L's',L'k',L'a',L',',L'n',L'e',L'u',L'e',L's',L',',L'n',L'e',L'w',L'h',L'a',L'm',L'p',L's',L'h',L'i',L'r',L'e',L',',L'n',L'e',L'w',L'j',L'e',L'r',L's',L'e',L'y',L',',L'n',L'e',L'w',L'm',L'e',L'x',L'i',L'c',L'o',L',',L'n',L'e',L'w',L'p',L'o',L'r',L't',L',',L'n',L'e',L'w',L's',L'p',L'a',L'p',L'e',L'r',L',',L'n',L'e',L'w',L'y',L'o',L'r',L'k',L',',L'n',L'i',L'e',L'p',L'c',L'e',L',',L'n',L'o',L'r',L'f',L'o',L'l',L'k',L',',
+	L'n',L'o',L'r',L't',L'h',L',',L'n',L'r',L'w',L',',L'n',L'u',L'e',L'r',L'n',L'b',L'e',L'r',L'g',L',',L'n',L'u',L'r',L'e',L'm',L'b',L'e',L'r',L'g',L',',L'n',L'y',L'c',L',',L'n',L'y',L'n',L'y',L',',L'o',L'c',L'e',L'a',L'n',L'o',L'g',L'r',L'a',L'p',L'h',L'i',L'c',L',',L'o',L'c',L'e',L'a',L'n',L'o',L'g',L'r',L'a',L'p',L'h',L'i',L'q',L'u',L'e',L',',L'o',L'm',L'a',L'h',L'a',L',',L'o',L'n',L'l',L'i',L'n',L'e',L',',L'o',L'n',L't',L'a',L'r',L'i',L'o',L',',L'o',L'p',L'e',L'n',L'a',L'i',L'r',L',',L'o',L'r',
+	L'e',L'g',L'o',L'n',L',',L'o',L'r',L'e',L'g',L'o',L'n',L't',L'r',L'a',L'i',L'l',L',',L'o',L't',L'a',L'g',L'o',L',',L'o',L'x',L'f',L'o',L'r',L'd',L',',L'p',L'a',L'c',L'i',L'f',L'i',L'c',L',',L'p',L'a',L'd',L'e',L'r',L'b',L'o',L'r',L'n',L',',L'p',L'a',L'l',L'a',L'c',L'e',L',',L'p',L'a',L'l',L'e',L'o',L',',L'p',L'a',L'l',L'm',L's',L'p',L'r',L'i',L'n',L'g',L's',L',',L'p',L'a',L'n',L'a',L'm',L'a',L',',L'p',L'a',L'r',L'i',L's',L',',L'p',L'a',L's',L'a',L'd',L'e',L'n',L'a',L',',L'p',L'h',L'a',L'r',L'm',
+	L'a',L'c',L'y',L',',L'p',L'h',L'i',L'l',L'a',L'd',L'e',L'l',L'p',L'h',L'i',L'a',L',',L'p',L'h',L'i',L'l',L'a',L'd',L'e',L'l',L'p',L'h',L'i',L'a',L'a',L'r',L'e',L'a',L',',L'p',L'h',L'i',L'l',L'a',L't',L'e',L'l',L'y',L',',L'p',L'h',L'o',L'e',L'n',L'i',L'x',L',',L'p',L'h',L'o',L't',L'o',L'g',L'r',L'a',L'p',L'h',L'y',L',',L'p',L'i',L'l',L'o',L't',L's',L',',L'p',L'i',L't',L't',L's',L'b',L'u',L'r',L'g',L'h',L',',L'p',L'l',L'a',L'n',L'e',L't',L'a',L'r',L'i',L'u',L'm',L',',L'p',L'l',L'a',L'n',L't',L'a',
+	L't',L'i',L'o',L'n',L',',L'p',L'l',L'a',L'n',L't',L's',L',',L'p',L'l',L'a',L'z',L'a',L',',L'p',L'o',L'r',L't',L'a',L'l',L',',L'p',L'o',L'r',L't',L'l',L'a',L'n',L'd',L',',L'p',L'o',L'r',L't',L'l',L'l',L'i',L'g',L'a',L't',L',',L'p',L'o',L's',L't',L's',L'-',L'a',L'n',L'd',L'-',L't',L'e',L'l',L'e',L'c',L'o',L'm',L'm',L'u',L'n',L'i',L'c',L'a',L't',L'i',L'o',L'n',L's',L',',L'p',L'r',L'e',L's',L'e',L'r',L'v',L'a',L't',L'i',L'o',L'n',L',',L'p',L'r',L'e',L's',L'i',L'd',L'i',L'o',L',',L'p',L'r',L'e',L's',
+	L's',L',',L'p',L'r',L'o',L'j',L'e',L'c',L't',L',',L'p',L'u',L'b',L'l',L'i',L'c',L',',L'p',L'u',L'b',L'o',L'l',L',',L'q',L'u',L'e',L'b',L'e',L'c',L',',L'r',L'a',L'i',L'l',L'r',L'o',L'a',L'd',L',',L'r',L'a',L'i',L'l',L'w',L'a',L'y',L',',L'r',L'e',L's',L'e',L'a',L'r',L'c',L'h',L',',L'r',L'e',L's',L'i',L's',L't',L'a',L'n',L'c',L'e',L',',L'r',L'i',L'o',L'd',L'e',L'j',L'a',L'n',L'e',L'i',L'r',L'o',L',',L'r',L'o',L'c',L'h',L'e',L's',L't',L'e',L'r',L',',L'r',L'o',L'c',L'k',L'a',L'r',L't',L',',L'r',L'o',
+	L'm',L'a',L',',L'r',L'u',L's',L's',L'i',L'a',L',',L's',L'a',L'i',L'n',L't',L'l',L'o',L'u',L'i',L's',L',',L's',L'a',L'l',L'e',L'm',L',',L's',L'a',L'l',L'v',L'a',L'd',L'o',L'r',L'd',L'a',L'l',L'i',L',',L's',L'a',L'l',L'z',L'b',L'u',L'r',L'g',L',',L's',L'a',L'n',L'd',L'i',L'e',L'g',L'o',L',',L's',L'a',L'n',L'f',L'r',L'a',L'n',L'c',L'i',L's',L'c',L'o',L',',L's',L'a',L'n',L't',L'a',L'b',L'a',L'r',L'b',L'a',L'r',L'a',L',',L's',L'a',L'n',L't',L'a',L'c',L'r',L'u',L'z',L',',L's',L'a',L'n',L't',L'a',L'f',
+	L'e',L',',L's',L'a',L's',L'k',L'a',L't',L'c',L'h',L'e',L'w',L'a',L'n',L',',L's',L'a',L't',L'x',L',',L's',L'a',L'v',L'a',L'n',L'n',L'a',L'h',L'g',L'a',L',',L's',L'c',L'h',L'l',L'e',L's',L'i',L's',L'c',L'h',L'e',L's',L',',L's',L'c',L'h',L'o',L'e',L'n',L'b',L'r',L'u',L'n',L'n',L',',L's',L'c',L'h',L'o',L'k',L'o',L'l',L'a',L'd',L'e',L'n',L',',L's',L'c',L'h',L'o',L'o',L'l',L',',L's',L'c',L'h',L'w',L'e',L'i',L'z',L',',L's',L'c',L'i',L'e',L'n',L'c',L'e',L',',L's',L'c',L'i',L'e',L'n',L'c',L'e',L'a',L'n',
+	L'd',L'h',L'i',L's',L't',L'o',L'r',L'y',L',',L's',L'c',L'i',L'e',L'n',L'c',L'e',L'a',L'n',L'd',L'i',L'n',L'd',L'u',L's',L't',L'r',L'y',L',',L's',L'c',L'i',L'e',L'n',L'c',L'e',L'c',L'e',L'n',L't',L'e',L'r',L',',L's',L'c',L'i',L'e',L'n',L'c',L'e',L'c',L'e',L'n',L't',L'e',L'r',L's',L',',L's',L'c',L'i',L'e',L'n',L'c',L'e',L'-',L'f',L'i',L'c',L't',L'i',L'o',L'n',L',',L's',L'c',L'i',L'e',L'n',L'c',L'e',L'h',L'i',L's',L't',L'o',L'r',L'y',L',',L's',L'c',L'i',L'e',L'n',L'c',L'e',L's',L',',L's',L'c',L'i',
+	L'e',L'n',L'c',L'e',L's',L'n',L'a',L't',L'u',L'r',L'e',L'l',L'l',L'e',L's',L',',L's',L'c',L'o',L't',L'l',L'a',L'n',L'd',L',',L's',L'e',L'a',L'p',L'o',L'r',L't',L',',L's',L'e',L't',L't',L'l',L'e',L'm',L'e',L'n',L't',L',',L's',L'e',L't',L't',L'l',L'e',L'r',L's',L',',L's',L'h',L'e',L'l',L'l',L',',L's',L'h',L'e',L'r',L'b',L'r',L'o',L'o',L'k',L'e',L',',L's',L'i',L'b',L'e',L'n',L'i',L'k',L',',L's',L'i',L'l',L'k',L',',L's',L'k',L'i',L',',L's',L'k',L'o',L'l',L'e',L',',L's',L'o',L'c',L'i',L'e',L't',L'y',
+	L',',L's',L'o',L'l',L'o',L'g',L'n',L'e',L',',L's',L'o',L'u',L'n',L'd',L'a',L'n',L'd',L'v',L'i',L's',L'i',L'o',L'n',L',',L's',L'o',L'u',L't',L'h',L'c',L'a',L'r',L'o',L'l',L'i',L'n',L'a',L',',L's',L'o',L'u',L't',L'h',L'w',L'e',L's',L't',L',',L's',L'p',L'a',L'c',L'e',L',',L's',L'p',L'y',L',',L's',L'q',L'u',L'a',L'r',L'e',L',',L's',L't',L'a',L'd',L't',L',',L's',L't',L'a',L'l',L'b',L'a',L'n',L's',L',',L's',L't',L'a',L'r',L'n',L'b',L'e',L'r',L'g',L',',L's',L't',L'a',L't',L'e',L',',L's',L't',L'a',L't',
+	L'e',L'o',L'f',L'd',L'e',L'l',L'a',L'w',L'a',L'r',L'e',L',',L's',L't',L'a',L't',L'i',L'o',L'n',L',',L's',L't',L'e',L'a',L'm',L',',L's',L't',L'e',L'i',L'e',L'r',L'm',L'a',L'r',L'k',L',',L's',L't',L'j',L'o',L'h',L'n',L',',L's',L't',L'o',L'c',L'k',L'h',L'o',L'l',L'm',L',',L's',L't',L'p',L'e',L't',L'e',L'r',L's',L'b',L'u',L'r',L'g',L',',L's',L't',L'u',L't',L't',L'g',L'a',L'r',L't',L',',L's',L'u',L'i',L's',L's',L'e',L',',L's',L'u',L'r',L'g',L'e',L'o',L'n',L's',L'h',L'a',L'l',L'l',L',',L's',L'u',L'r',
+	L'r',L'e',L'y',L',',L's',L'v',L'i',L'z',L'z',L'e',L'r',L'a',L',',L's',L'w',L'e',L'd',L'e',L'n',L',',L's',L'y',L'd',L'n',L'e',L'y',L',',L't',L'a',L'n',L'k',L',',L't',L'c',L'm',L',',L't',L'e',L'c',L'h',L'n',L'o',L'l',L'o',L'g',L'y',L',',L't',L'e',L'l',L'e',L'k',L'o',L'm',L'm',L'u',L'n',L'i',L'k',L'a',L't',L'i',L'o',L'n',L',',L't',L'e',L'l',L'e',L'v',L'i',L's',L'i',L'o',L'n',L',',L't',L'e',L'x',L'a',L's',L',',L't',L'e',L'x',L't',L'i',L'l',L'e',L',',L't',L'h',L'e',L'a',L't',L'e',L'r',L',',L't',L'i',
+	L'm',L'e',L',',L't',L'i',L'm',L'e',L'k',L'e',L'e',L'p',L'i',L'n',L'g',L',',L't',L'o',L'p',L'o',L'l',L'o',L'g',L'y',L',',L't',L'o',L'r',L'i',L'n',L'o',L',',L't',L'o',L'u',L'c',L'h',L',',L't',L'o',L'w',L'n',L',',L't',L'r',L'a',L'n',L's',L'p',L'o',L'r',L't',L',',L't',L'r',L'e',L'e',L',',L't',L'r',L'o',L'l',L'l',L'e',L'y',L',',L't',L'r',L'u',L's',L't',L',',L't',L'r',L'u',L's',L't',L'e',L'e',L',',L'u',L'h',L'r',L'e',L'n',L',',L'u',L'l',L'm',L',',L'u',L'n',L'd',L'e',L'r',L's',L'e',L'a',L',',L'u',L'n',
+	L'i',L'v',L'e',L'r',L's',L'i',L't',L'y',L',',L'u',L's',L'a',L',',L'u',L's',L'a',L'n',L't',L'i',L'q',L'u',L'e',L's',L',',L'u',L's',L'a',L'r',L't',L's',L',',L'u',L's',L'c',L'o',L'u',L'n',L't',L'r',L'y',L'e',L's',L't',L'a',L't',L'e',L',',L'u',L's',L'c',L'u',L'l',L't',L'u',L'r',L'e',L',',L'u',L's',L'd',L'e',L'c',L'o',L'r',L'a',L't',L'i',L'v',L'e',L'a',L'r',L't',L's',L',',L'u',L's',L'g',L'a',L'r',L'd',L'e',L'n',L',',L'u',L's',L'h',L'i',L's',L't',L'o',L'r',L'y',L',',L'u',L's',L'h',L'u',L'a',L'i',L'a',
+	L',',L'u',L's',L'l',L'i',L'v',L'i',L'n',L'g',L'h',L'i',L's',L't',L'o',L'r',L'y',L',',L'u',L't',L'a',L'h',L',',L'u',L'v',L'i',L'c',L',',L'v',L'a',L'l',L'l',L'e',L'y',L',',L'v',L'a',L'n',L't',L'a',L'a',L',',L'v',L'e',L'r',L's',L'a',L'i',L'l',L'l',L'e',L's',L',',L'v',L'i',L'k',L'i',L'n',L'g',L',',L'v',L'i',L'l',L'l',L'a',L'g',L'e',L',',L'v',L'i',L'r',L'g',L'i',L'n',L'i',L'a',L',',L'v',L'i',L'r',L't',L'u',L'a',L'l',L',',L'v',L'i',L'r',L't',L'u',L'e',L'l',L',',L'v',L'l',L'a',L'a',L'n',L'd',L'e',L'r',
+	L'e',L'n',L',',L'v',L'o',L'l',L'k',L'e',L'n',L'k',L'u',L'n',L'd',L'e',L',',L'w',L'a',L'l',L'e',L's',L',',L'w',L'a',L'l',L'l',L'o',L'n',L'i',L'e',L',',L'w',L'a',L'r',L',',L'w',L'a',L's',L'h',L'i',L'n',L'g',L't',L'o',L'n',L'd',L'c',L',',L'w',L'a',L't',L'c',L'h',L'a',L'n',L'd',L'c',L'l',L'o',L'c',L'k',L',',L'w',L'a',L't',L'c',L'h',L'-',L'a',L'n',L'd',L'-',L'c',L'l',L'o',L'c',L'k',L',',L'w',L'e',L's',L't',L'e',L'r',L'n',L',',L'w',L'e',L's',L't',L'f',L'a',L'l',L'e',L'n',L',',L'w',L'h',L'a',L'l',L'i',
+	L'n',L'g',L',',L'w',L'i',L'l',L'd',L'l',L'i',L'f',L'e',L',',L'w',L'i',L'l',L'l',L'i',L'a',L'm',L's',L'b',L'u',L'r',L'g',L',',L'w',L'i',L'n',L'd',L'm',L'i',L'l',L'l',L',',L'w',L'o',L'r',L'k',L's',L'h',L'o',L'p',L',',L'y',L'o',L'r',L'k',L',',L'y',L'o',L'r',L'k',L's',L'h',L'i',L'r',L'e',L',',L'y',L'o',L's',L'e',L'm',L'i',L't',L'e',L',',L'y',L'o',L'u',L't',L'h',L',',L'z',L'o',L'o',L'l',L'o',L'g',L'i',L'c',L'a',L'l',L',',L'z',L'o',L'o',L'l',L'o',L'g',L'y',L',',L'י',L'ר',L'ו',L'ש',L'ל',L'י',L'ם',L',',
+	L'и',L'к',L'о',L'м',L')',L',',L'm',L'v',L'(',L'1',L'4',L':',L'a',L'e',L'r',L'o',L',',L'b',L'i',L'z',L',',L'c',L'o',L'm',L',',L'c',L'o',L'o',L'p',L',',L'e',L'd',L'u',L',',L'g',L'o',L'v',L',',L'i',L'n',L'f',L'o',L',',L'i',L'n',L't',L',',L'm',L'i',L'l',L',',L'm',L'u',L's',L'e',L'u',L'm',L',',L'n',L'a',L'm',L'e',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L',',L'p',L'r',L'o',L')',L',',L'm',L'w',L'(',L'1',L'1',L':',L'a',L'c',L',',L'b',L'i',L'z',L',',L'c',L'o',L',',L'c',L'o',L'm',L',',L'c',L'o',L'o',L'p',
+	L',',L'e',L'd',L'u',L',',L'g',L'o',L'v',L',',L'i',L'n',L't',L',',L'm',L'u',L's',L'e',L'u',L'm',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L')',L',',L'm',L'x',L'(',L'5',L':',L'c',L'o',L'm',L',',L'o',L'r',L'g',L',',L'g',L'o',L'b',L',',L'e',L'd',L'u',L',',L'n',L'e',L't',L')',L',',L'm',L'y',L'(',L'7',L':',L'c',L'o',L'm',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L',',L'g',L'o',L'v',L',',L'e',L'd',L'u',L',',L'm',L'i',L'l',L',',L'n',L'a',L'm',L'e',L')',L',',L'm',L'z',L'(',L'1',L':',L'*',L')',L',',L'n',L'a',
+	L'(',L'1',L'7',L':',L'i',L'n',L'f',L'o',L',',L'p',L'r',L'o',L',',L'n',L'a',L'm',L'e',L',',L's',L'c',L'h',L'o',L'o',L'l',L',',L'o',L'r',L',',L'd',L'r',L',',L'u',L's',L',',L'm',L'x',L',',L'c',L'a',L',',L'i',L'n',L',',L'c',L'c',L',',L't',L'v',L',',L'w',L's',L',',L'm',L'o',L'b',L'i',L',',L'c',L'o',L',',L'c',L'o',L'm',L',',L'o',L'r',L'g',L')',L',',L'n',L'a',L'm',L'e',L'(',L'2',L':',L'h',L'e',L'r',L'(',L'1',L':',L'f',L'o',L'r',L'g',L'o',L't',L')',L',',L'h',L'i',L's',L'(',L'1',L':',L'f',L'o',L'r',L'g',
+	L'o',L't',L')',L')',L',',L'n',L'c',L'(',L'1',L':',L'a',L's',L's',L'o',L')',L',',L'n',L'e',L',',L'n',L'e',L't',L'(',L'4',L'1',L':',L'g',L'b',L',',L'j',L'p',L',',L's',L'e',L',',L'u',L'k',L',',L'h',L'u',L',',L'z',L'a',L',',L'a',L't',L'-',L'b',L'a',L'n',L'd',L'-',L'c',L'a',L'm',L'p',L',',L'b',L'l',L'o',L'g',L'd',L'n',L's',L',',L'b',L'r',L'o',L'k',L'e',L'-',L'i',L't',L',',L'b',L'u',L'y',L's',L'h',L'o',L'u',L's',L'e',L's',L',',L'd',L'n',L's',L'a',L'l',L'i',L'a',L's',L',',L'd',L'n',L's',L'd',L'o',L'j',
+	L'o',L',',L'd',L'o',L'e',L's',L'-',L'i',L't',L',',L'd',L'o',L'n',L't',L'e',L'x',L'i',L's',L't',L',',L'd',L'y',L'n',L'a',L'l',L'i',L'a',L's',L',',L'd',L'y',L'n',L'a',L't',L'h',L'o',L'm',L'e',L',',L'e',L'n',L'd',L'o',L'f',L'i',L'n',L't',L'e',L'r',L'n',L'e',L't',L',',L'f',L'r',L'o',L'm',L'-',L'a',L'z',L',',L'f',L'r',L'o',L'm',L'-',L'c',L'o',L',',L'f',L'r',L'o',L'm',L'-',L'l',L'a',L',',L'f',L'r',L'o',L'm',L'-',L'n',L'y',L',',L'g',L'e',L't',L's',L'-',L'i',L't',L',',L'h',L'a',L'm',L'-',L'r',L'a',L'd',
+	L'i',L'o',L'-',L'o',L'p',L',',L'h',L'o',L'm',L'e',L'f',L't',L'p',L',',L'h',L'o',L'm',L'e',L'i',L'p',L',',L'h',L'o',L'm',L'e',L'l',L'i',L'n',L'u',L'x',L',',L'h',L'o',L'm',L'e',L'u',L'n',L'i',L'x',L',',L'i',L'n',L'-',L't',L'h',L'e',L'-',L'b',L'a',L'n',L'd',L',',L'i',L's',L'-',L'a',L'-',L'c',L'h',L'e',L'f',L',',L'i',L's',L'-',L'a',L'-',L'g',L'e',L'e',L'k',L',',L'i',L's',L'a',L'-',L'g',L'e',L'e',L'k',L',',L'k',L'i',L'c',L'k',L's',L'-',L'a',L's',L's',L',',L'o',L'f',L'f',L'i',L'c',L'e',L'-',L'o',L'n',
+	L'-',L't',L'h',L'e',L',',L'p',L'o',L'd',L'z',L'o',L'n',L'e',L',',L's',L'c',L'r',L'a',L'p',L'p',L'e',L'r',L'-',L's',L'i',L't',L'e',L',',L's',L'e',L'l',L'f',L'i',L'p',L',',L's',L'e',L'l',L'l',L's',L'-',L'i',L't',L',',L's',L'e',L'r',L'v',L'e',L'b',L'b',L's',L',',L's',L'e',L'r',L'v',L'e',L'f',L't',L'p',L',',L't',L'h',L'r',L'u',L'h',L'e',L'r',L'e',L',',L'w',L'e',L'b',L'h',L'o',L'p',L')',L',',L'n',L'f',L'(',L'1',L'0',L':',L'c',L'o',L'm',L',',L'n',L'e',L't',L',',L'p',L'e',L'r',L',',L'r',L'e',L'c',L',',
+	L'w',L'e',L'b',L',',L'a',L'r',L't',L's',L',',L'f',L'i',L'r',L'm',L',',L'i',L'n',L'f',L'o',L',',L'o',L't',L'h',L'e',L'r',L',',L's',L't',L'o',L'r',L'e',L')',L',',L'n',L'g',L'(',L'6',L':',L'a',L'c',L',',L'c',L'o',L'm',L',',L'e',L'd',L'u',L',',L'g',L'o',L'v',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L')',L',',L'n',L'i',L'(',L'1',L':',L'*',L')',L',',L'n',L'l',L'(',L'2',L':',L'b',L'v',L',',L'c',L'o',L')',L',',L'n',L'o',L'(',L'7',L'2',L'5',L':',L'f',L'h',L's',L',',L'v',L'g',L's',L',',L'f',L'y',L'l',L'k',
+	L'e',L's',L'b',L'i',L'b',L'l',L',',L'f',L'o',L'l',L'k',L'e',L'b',L'i',L'b',L'l',L',',L'm',L'u',L's',L'e',L'u',L'm',L',',L'i',L'd',L'r',L'e',L't',L't',L',',L'p',L'r',L'i',L'v',L',',L'm',L'i',L'l',L',',L's',L't',L'a',L't',L',',L'd',L'e',L'p',L',',L'k',L'o',L'm',L'm',L'u',L'n',L'e',L',',L'h',L'e',L'r',L'a',L'd',L',',L'a',L'a',L'(',L'1',L':',L'g',L's',L')',L',',L'a',L'h',L'(',L'1',L':',L'g',L's',L')',L',',L'b',L'u',L'(',L'1',L':',L'g',L's',L')',L',',L'f',L'm',L'(',L'1',L':',L'g',L's',L')',L',',L'h',
+	L'l',L'(',L'1',L':',L'g',L's',L')',L',',L'h',L'm',L'(',L'1',L':',L'g',L's',L')',L',',L'j',L'a',L'n',L'-',L'm',L'a',L'y',L'e',L'n',L'(',L'1',L':',L'g',L's',L')',L',',L'm',L'r',L'(',L'1',L':',L'g',L's',L')',L',',L'n',L'l',L'(',L'1',L':',L'g',L's',L')',L',',L'n',L't',L'(',L'1',L':',L'g',L's',L')',L',',L'o',L'f',L'(',L'1',L':',L'g',L's',L')',L',',L'o',L'l',L'(',L'1',L':',L'g',L's',L')',L',',L'o',L's',L'l',L'o',L'(',L'1',L':',L'g',L's',L')',L',',L'r',L'l',L'(',L'1',L':',L'g',L's',L')',L',',L's',L'f',
+	L'(',L'1',L':',L'g',L's',L')',L',',L's',L't',L'(',L'1',L':',L'g',L's',L')',L',',L's',L'v',L'a',L'l',L'b',L'a',L'r',L'd',L'(',L'1',L':',L'g',L's',L')',L',',L't',L'm',L'(',L'1',L':',L'g',L's',L')',L',',L't',L'r',L'(',L'1',L':',L'g',L's',L')',L',',L'v',L'a',L'(',L'1',L':',L'g',L's',L')',L',',L'v',L'f',L'(',L'1',L':',L'g',L's',L')',L',',L'a',L'k',L'r',L'e',L'h',L'a',L'm',L'n',L',',L'å',L'k',L'r',L'e',L'h',L'a',L'm',L'n',L',',L'a',L'l',L'g',L'a',L'r',L'd',L',',L'å',L'l',L'g',L'å',L'r',L'd',L',',L'a',
+	L'r',L'n',L'a',L',',L'b',L'r',L'u',L'm',L'u',L'n',L'd',L'd',L'a',L'l',L',',L'b',L'r',L'y',L'n',L'e',L',',L'b',L'r',L'o',L'n',L'n',L'o',L'y',L's',L'u',L'n',L'd',L',',L'b',L'r',L'ø',L'n',L'n',L'ø',L'y',L's',L'u',L'n',L'd',L',',L'd',L'r',L'o',L'b',L'a',L'k',L',',L'd',L'r',L'ø',L'b',L'a',L'k',L',',L'e',L'g',L'e',L'r',L's',L'u',L'n',L'd',L',',L'f',L'e',L't',L's',L'u',L'n',L'd',L',',L'f',L'l',L'o',L'r',L'o',L',',L'f',L'l',L'o',L'r',L'ø',L',',L'f',L'r',L'e',L'd',L'r',L'i',L'k',L's',L't',L'a',L'd',L',',
+	L'h',L'o',L'k',L'k',L's',L'u',L'n',L'd',L',',L'h',L'o',L'n',L'e',L'f',L'o',L's',L's',L',',L'h',L'ø',L'n',L'e',L'f',L'o',L's',L's',L',',L'j',L'e',L's',L's',L'h',L'e',L'i',L'm',L',',L'j',L'o',L'r',L'p',L'e',L'l',L'a',L'n',L'd',L',',L'j',L'ø',L'r',L'p',L'e',L'l',L'a',L'n',L'd',L',',L'k',L'i',L'r',L'k',L'e',L'n',L'e',L's',L',',L'k',L'o',L'p',L'e',L'r',L'v',L'i',L'k',L',',L'k',L'r',L'o',L'k',L's',L't',L'a',L'd',L'e',L'l',L'v',L'a',L',',L'l',L'a',L'n',L'g',L'e',L'v',L'a',L'g',L',',L'l',L'a',L'n',L'g',
+	L'e',L'v',L'å',L'g',L',',L'l',L'e',L'i',L'r',L'v',L'i',L'k',L',',L'm',L'j',L'o',L'n',L'd',L'a',L'l',L'e',L'n',L',',L'm',L'j',L'ø',L'n',L'd',L'a',L'l',L'e',L'n',L',',L'm',L'o',L'-',L'i',L'-',L'r',L'a',L'n',L'a',L',',L'm',L'o',L's',L'j',L'o',L'e',L'n',L',',L'm',L'o',L's',L'j',L'ø',L'e',L'n',L',',L'n',L'e',L's',L'o',L'd',L'd',L't',L'a',L'n',L'g',L'e',L'n',L',',L'o',L'r',L'k',L'a',L'n',L'g',L'e',L'r',L',',L'o',L's',L'o',L'y',L'r',L'o',L',',L'o',L's',L'ø',L'y',L'r',L'o',L',',L'r',L'a',L'h',L'o',L'l',
+	L't',L',',L'r',L'å',L'h',L'o',L'l',L't',L',',L's',L'a',L'n',L'd',L'n',L'e',L's',L's',L'j',L'o',L'e',L'n',L',',L's',L'a',L'n',L'd',L'n',L'e',L's',L's',L'j',L'ø',L'e',L'n',L',',L's',L'k',L'e',L'd',L's',L'm',L'o',L'k',L'o',L'r',L's',L'e',L't',L',',L's',L'l',L'a',L't',L't',L'u',L'm',L',',L's',L'p',L'j',L'e',L'l',L'k',L'a',L'v',L'i',L'k',L',',L's',L't',L'a',L't',L'h',L'e',L'l',L'l',L'e',L',',L's',L't',L'a',L'v',L'e',L'r',L'n',L',',L's',L't',L'j',L'o',L'r',L'd',L'a',L'l',L's',L'h',L'a',L'l',L's',L'e',
+	L'n',L',',L's',L't',L'j',L'ø',L'r',L'd',L'a',L'l',L's',L'h',L'a',L'l',L's',L'e',L'n',L',',L't',L'a',L'n',L'a',L'n',L'g',L'e',L'r',L',',L't',L'r',L'a',L'n',L'b',L'y',L',',L'v',L'o',L's',L's',L'e',L'v',L'a',L'n',L'g',L'e',L'n',L',',L'a',L'f',L'j',L'o',L'r',L'd',L',',L'å',L'f',L'j',L'o',L'r',L'd',L',',L'a',L'g',L'd',L'e',L'n',L'e',L's',L',',L'a',L'l',L',',L'å',L'l',L',',L'a',L'l',L'e',L's',L'u',L'n',L'd',L',',L'å',L'l',L'e',L's',L'u',L'n',L'd',L',',L'a',L'l',L's',L't',L'a',L'h',L'a',L'u',L'g',L',',
+	L'a',L'l',L't',L'a',L',',L'á',L'l',L't',L'á',L',',L'a',L'l',L'a',L'h',L'e',L'a',L'd',L'j',L'u',L',',L'á',L'l',L'a',L'h',L'e',L'a',L'd',L'j',L'u',L',',L'a',L'l',L'v',L'd',L'a',L'l',L',',L'a',L'm',L'l',L'i',L',',L'å',L'm',L'l',L'i',L',',L'a',L'm',L'o',L't',L',',L'å',L'm',L'o',L't',L',',L'a',L'n',L'd',L'e',L'b',L'u',L',',L'a',L'n',L'd',L'o',L'y',L',',L'a',L'n',L'd',L'ø',L'y',L',',L'a',L'n',L'd',L'a',L's',L'u',L'o',L'l',L'o',L',',L'a',L'r',L'd',L'a',L'l',L',',L'å',L'r',L'd',L'a',L'l',L',',L'a',L'r',
+	L'e',L'm',L'a',L'r',L'k',L',',L'a',L'r',L'e',L'n',L'd',L'a',L'l',L',',L'å',L's',L',',L'a',L's',L'e',L'r',L'a',L'l',L',',L'å',L's',L'e',L'r',L'a',L'l',L',',L'a',L's',L'k',L'e',L'r',L',',L'a',L's',L'k',L'i',L'm',L',',L'a',L's',L'k',L'v',L'o',L'l',L'l',L',',L'a',L's',L'k',L'o',L'y',L',',L'a',L's',L'k',L'ø',L'y',L',',L'a',L's',L'n',L'e',L's',L',',L'å',L's',L'n',L'e',L's',L',',L'a',L'u',L'd',L'n',L'e',L'd',L'a',L'l',L'n',L',',L'a',L'u',L'k',L'r',L'a',L',',L'a',L'u',L'r',L'e',L',',L'a',L'u',L'r',L'l',
+	L'a',L'n',L'd',L',',L'a',L'u',L'r',L's',L'k',L'o',L'g',L'-',L'h',L'o',L'l',L'a',L'n',L'd',L',',L'a',L'u',L'r',L's',L'k',L'o',L'g',L'-',L'h',L'ø',L'l',L'a',L'n',L'd',L',',L'a',L'u',L's',L't',L'e',L'v',L'o',L'l',L'l',L',',L'a',L'u',L's',L't',L'r',L'h',L'e',L'i',L'm',L',',L'a',L'v',L'e',L'r',L'o',L'y',L',',L'a',L'v',L'e',L'r',L'ø',L'y',L',',L'b',L'a',L'l',L'e',L's',L't',L'r',L'a',L'n',L'd',L',',L'b',L'a',L'l',L'l',L'a',L'n',L'g',L'e',L'n',L',',L'b',L'a',L'l',L'a',L't',L',',L'b',L'á',L'l',L'á',L't',
+	L',',L'b',L'a',L'l',L's',L'f',L'j',L'o',L'r',L'd',L',',L'b',L'a',L'h',L'c',L'c',L'a',L'v',L'u',L'o',L't',L'n',L'a',L',',L'b',L'á',L'h',L'c',L'c',L'a',L'v',L'u',L'o',L't',L'n',L'a',L',',L'b',L'a',L'm',L'b',L'l',L'e',L',',L'b',L'a',L'r',L'd',L'u',L',',L'b',L'e',L'a',L'r',L'd',L'u',L',',L'b',L'e',L'i',L'a',L'r',L'n',L',',L'b',L'a',L'j',L'd',L'd',L'a',L'r',L',',L'b',L'á',L'j',L'd',L'd',L'a',L'r',L',',L'b',L'a',L'i',L'd',L'a',L'r',L',',L'b',L'á',L'i',L'd',L'á',L'r',L',',L'b',L'e',L'r',L'g',L',',L'b',
+	L'e',L'r',L'g',L'e',L'n',L',',L'b',L'e',L'r',L'l',L'e',L'v',L'a',L'g',L',',L'b',L'e',L'r',L'l',L'e',L'v',L'å',L'g',L',',L'b',L'e',L'a',L'r',L'a',L'l',L'v',L'a',L'h',L'k',L'i',L',',L'b',L'e',L'a',L'r',L'a',L'l',L'v',L'á',L'h',L'k',L'i',L',',L'b',L'i',L'n',L'd',L'a',L'l',L',',L'b',L'i',L'r',L'k',L'e',L'n',L'e',L's',L',',L'b',L'j',L'a',L'r',L'k',L'o',L'y',L',',L'b',L'j',L'a',L'r',L'k',L'ø',L'y',L',',L'b',L'j',L'e',L'r',L'k',L'r',L'e',L'i',L'm',L',',L'b',L'j',L'u',L'g',L'n',L',',L'b',L'o',L'd',L'o',
+	L',',L'b',L'o',L'd',L'ø',L',',L'b',L'a',L'd',L'a',L'd',L'd',L'j',L'a',L',',L'b',L'å',L'd',L'å',L'd',L'd',L'j',L'å',L',',L'b',L'u',L'd',L'e',L'j',L'j',L'u',L',',L'b',L'o',L'k',L'n',L',',L'b',L'r',L'e',L'm',L'a',L'n',L'g',L'e',L'r',L',',L'b',L'r',L'o',L'n',L'n',L'o',L'y',L',',L'b',L'r',L'ø',L'n',L'n',L'ø',L'y',L',',L'b',L'y',L'g',L'l',L'a',L'n',L'd',L',',L'b',L'y',L'k',L'l',L'e',L',',L'b',L'a',L'r',L'u',L'm',L',',L'b',L'æ',L'r',L'u',L'm',L',',L't',L'e',L'l',L'e',L'm',L'a',L'r',L'k',L'(',L'2',L':',
+	L'b',L'o',L',',L'b',L'ø',L')',L',',L'n',L'o',L'r',L'd',L'l',L'a',L'n',L'd',L'(',L'4',L':',L'b',L'o',L',',L'b',L'ø',L',',L'h',L'e',L'r',L'o',L'y',L',',L'h',L'e',L'r',L'ø',L'y',L')',L',',L'b',L'i',L'e',L'v',L'a',L't',L',',L'b',L'i',L'e',L'v',L'á',L't',L',',L'b',L'o',L'm',L'l',L'o',L',',L'b',L'ø',L'm',L'l',L'o',L',',L'b',L'a',L't',L's',L'f',L'j',L'o',L'r',L'd',L',',L'b',L'å',L't',L's',L'f',L'j',L'o',L'r',L'd',L',',L'b',L'a',L'h',L'c',L'a',L'v',L'u',L'o',L't',L'n',L'a',L',',L'b',L'á',L'h',L'c',L'a',
+	L'v',L'u',L'o',L't',L'n',L'a',L',',L'd',L'o',L'v',L'r',L'e',L',',L'd',L'r',L'a',L'm',L'm',L'e',L'n',L',',L'd',L'r',L'a',L'n',L'g',L'e',L'd',L'a',L'l',L',',L'd',L'y',L'r',L'o',L'y',L',',L'd',L'y',L'r',L'ø',L'y',L',',L'd',L'o',L'n',L'n',L'a',L',',L'd',L'ø',L'n',L'n',L'a',L',',L'e',L'i',L'd',L',',L'e',L'i',L'd',L'f',L'j',L'o',L'r',L'd',L',',L'e',L'i',L'd',L's',L'b',L'e',L'r',L'g',L',',L'e',L'i',L'd',L's',L'k',L'o',L'g',L',',L'e',L'i',L'd',L's',L'v',L'o',L'l',L'l',L',',L'e',L'i',L'g',L'e',L'r',L's',
+	L'u',L'n',L'd',L',',L'e',L'l',L'v',L'e',L'r',L'u',L'm',L',',L'e',L'n',L'e',L'b',L'a',L'k',L'k',L',',L'e',L'n',L'g',L'e',L'r',L'd',L'a',L'l',L',',L'e',L't',L'n',L'e',L',',L'e',L't',L'n',L'e',L'd',L'a',L'l',L',',L'e',L'v',L'e',L'n',L'e',L's',L',',L'e',L'v',L'e',L'n',L'a',L's',L's',L'i',L',',L'e',L'v',L'e',L'n',L'á',L'š',L'š',L'i',L',',L'e',L'v',L'j',L'e',L'-',L'o',L'g',L'-',L'h',L'o',L'r',L'n',L'n',L'e',L's',L',',L'f',L'a',L'r',L's',L'u',L'n',L'd',L',',L'f',L'a',L'u',L's',L'k',L'e',L',',L'f',L'u',
+	L'o',L's',L's',L'k',L'o',L',',L'f',L'u',L'o',L'i',L's',L'k',L'u',L',',L'f',L'e',L'd',L'j',L'e',L',',L'f',L'e',L't',L',',L'f',L'i',L'n',L'n',L'o',L'y',L',',L'f',L'i',L'n',L'n',L'ø',L'y',L',',L'f',L'i',L't',L'j',L'a',L'r',L',',L'f',L'j',L'a',L'l',L'e',L'r',L',',L'f',L'j',L'e',L'l',L'l',L',',L'f',L'l',L'a',L'k',L's',L't',L'a',L'd',L',',L'f',L'l',L'a',L't',L'a',L'n',L'g',L'e',L'r',L',',L'f',L'l',L'e',L'k',L'k',L'e',L'f',L'j',L'o',L'r',L'd',L',',L'f',L'l',L'e',L's',L'b',L'e',L'r',L'g',L',',L'f',L'l',
+	L'o',L'r',L'a',L',',L'f',L'l',L'a',L',',L'f',L'l',L'å',L',',L'f',L'o',L'l',L'l',L'd',L'a',L'l',L',',L'f',L'o',L'r',L's',L'a',L'n',L'd',L',',L'f',L'o',L's',L'n',L'e',L's',L',',L'f',L'r',L'e',L'i',L',',L'f',L'r',L'o',L'g',L'n',L',',L'f',L'r',L'o',L'l',L'a',L'n',L'd',L',',L'f',L'r',L'o',L's',L't',L'a',L',',L'f',L'r',L'a',L'n',L'a',L',',L'f',L'r',L'æ',L'n',L'a',L',',L'f',L'r',L'o',L'y',L'a',L',',L'f',L'r',L'ø',L'y',L'a',L',',L'f',L'u',L's',L'a',L',',L'f',L'y',L'r',L'e',L's',L'd',L'a',L'l',L',',L'f',
+	L'o',L'r',L'd',L'e',L',',L'f',L'ø',L'r',L'd',L'e',L',',L'g',L'a',L'm',L'v',L'i',L'k',L',',L'g',L'a',L'n',L'g',L'a',L'v',L'i',L'i',L'k',L'a',L',',L'g',L'á',L'ŋ',L'g',L'a',L'v',L'i',L'i',L'k',L'a',L',',L'g',L'a',L'u',L'l',L'a',L'r',L',',L'g',L'a',L'u',L's',L'd',L'a',L'l',L',',L'g',L'i',L'l',L'd',L'e',L's',L'k',L'a',L'l',L',',L'g',L'i',L'l',L'd',L'e',L's',L'k',L'å',L'l',L',',L'g',L'i',L's',L'k',L'e',L',',L'g',L'j',L'e',L'm',L'n',L'e',L's',L',',L'g',L'j',L'e',L'r',L'd',L'r',L'u',L'm',L',',L'g',L'j',
+	L'e',L'r',L's',L't',L'a',L'd',L',',L'g',L'j',L'e',L's',L'd',L'a',L'l',L',',L'g',L'j',L'o',L'v',L'i',L'k',L',',L'g',L'j',L'ø',L'v',L'i',L'k',L',',L'g',L'l',L'o',L'p',L'p',L'e',L'n',L',',L'g',L'o',L'l',L',',L'g',L'r',L'a',L'n',L',',L'g',L'r',L'a',L'n',L'e',L',',L'g',L'r',L'a',L'n',L'v',L'i',L'n',L',',L'g',L'r',L'a',L't',L'a',L'n',L'g',L'e',L'n',L',',L'g',L'r',L'i',L'm',L's',L't',L'a',L'd',L',',L'g',L'r',L'o',L'n',L'g',L',',L'k',L'r',L'a',L'a',L'n',L'g',L'h',L'k',L'e',L',',L'k',L'r',L'å',L'a',L'n',
+	L'g',L'h',L'k',L'e',L',',L'g',L'r',L'u',L'e',L',',L'g',L'u',L'l',L'e',L'n',L',',L'h',L'a',L'd',L's',L'e',L'l',L',',L'h',L'a',L'l',L'd',L'e',L'n',L',',L'h',L'a',L'l',L's',L'a',L',',L'h',L'a',L'm',L'a',L'r',L',',L'h',L'a',L'm',L'a',L'r',L'o',L'y',L',',L'h',L'a',L'b',L'm',L'e',L'r',L',',L'h',L'á',L'b',L'm',L'e',L'r',L',',L'h',L'a',L'p',L'm',L'i',L'r',L',',L'h',L'á',L'p',L'm',L'i',L'r',L',',L'h',L'a',L'm',L'm',L'e',L'r',L'f',L'e',L's',L't',L',',L'h',L'a',L'm',L'm',L'a',L'r',L'f',L'e',L'a',L's',L't',
+	L'a',L',',L'h',L'á',L'm',L'm',L'á',L'r',L'f',L'e',L'a',L's',L't',L'a',L',',L'h',L'a',L'r',L'a',L'm',L',',L'h',L'a',L'r',L'e',L'i',L'd',L',',L'h',L'a',L'r',L's',L't',L'a',L'd',L',',L'h',L'a',L's',L'v',L'i',L'k',L',',L'a',L'k',L'n',L'o',L'l',L'u',L'o',L'k',L't',L'a',L',',L'á',L'k',L'ŋ',L'o',L'l',L'u',L'o',L'k',L't',L'a',L',',L'h',L'a',L't',L't',L'f',L'j',L'e',L'l',L'l',L'd',L'a',L'l',L',',L'a',L'a',L'r',L'b',L'o',L'r',L't',L'e',L',',L'h',L'a',L'u',L'g',L'e',L's',L'u',L'n',L'd',L',',L'h',L'e',L'm',
+	L'n',L'e',L',',L'h',L'e',L'm',L'n',L'e',L's',L',',L'h',L'e',L'm',L's',L'e',L'd',L'a',L'l',L',',L'm',L'o',L'r',L'e',L'-',L'o',L'g',L'-',L'r',L'o',L'm',L's',L'd',L'a',L'l',L'(',L'2',L':',L'h',L'e',L'r',L'o',L'y',L',',L's',L'a',L'n',L'd',L'e',L')',L',',L'm',L'ø',L'r',L'e',L'-',L'o',L'g',L'-',L'r',L'o',L'm',L's',L'd',L'a',L'l',L'(',L'2',L':',L'h',L'e',L'r',L'ø',L'y',L',',L's',L'a',L'n',L'd',L'e',L')',L',',L'h',L'i',L't',L'r',L'a',L',',L'h',L'j',L'a',L'r',L't',L'd',L'a',L'l',L',',L'h',L'j',L'e',L'l',
+	L'm',L'e',L'l',L'a',L'n',L'd',L',',L'h',L'o',L'b',L'o',L'l',L',',L'h',L'o',L'b',L'ø',L'l',L',',L'h',L'o',L'f',L',',L'h',L'o',L'l',L',',L'h',L'o',L'l',L'e',L',',L'h',L'o',L'l',L'm',L'e',L's',L't',L'r',L'a',L'n',L'd',L',',L'h',L'o',L'l',L't',L'a',L'l',L'e',L'n',L',',L'h',L'o',L'l',L't',L'å',L'l',L'e',L'n',L',',L'h',L'o',L'r',L'n',L'i',L'n',L'd',L'a',L'l',L',',L'h',L'o',L'r',L't',L'e',L'n',L',',L'h',L'u',L'r',L'd',L'a',L'l',L',',L'h',L'u',L'r',L'u',L'm',L',',L'h',L'v',L'a',L'l',L'e',L'r',L',',L'h',
+	L'y',L'l',L'l',L'e',L's',L't',L'a',L'd',L',',L'h',L'a',L'g',L'e',L'b',L'o',L's',L't',L'a',L'd',L',',L'h',L'æ',L'g',L'e',L'b',L'o',L's',L't',L'a',L'd',L',',L'h',L'o',L'y',L'a',L'n',L'g',L'e',L'r',L',',L'h',L'ø',L'y',L'a',L'n',L'g',L'e',L'r',L',',L'h',L'o',L'y',L'l',L'a',L'n',L'd',L'e',L't',L',',L'h',L'ø',L'y',L'l',L'a',L'n',L'd',L'e',L't',L',',L'h',L'a',L',',L'h',L'å',L',',L'i',L'b',L'e',L's',L't',L'a',L'd',L',',L'i',L'n',L'd',L'e',L'r',L'o',L'y',L',',L'i',L'n',L'd',L'e',L'r',L'ø',L'y',L',',L'i',
+	L'v',L'e',L'l',L'a',L'n',L'd',L',',L'j',L'e',L'v',L'n',L'a',L'k',L'e',L'r',L',',L'j',L'o',L'n',L'd',L'a',L'l',L',',L'j',L'o',L'l',L's',L't',L'e',L'r',L',',L'j',L'ø',L'l',L's',L't',L'e',L'r',L',',L'k',L'a',L'r',L'a',L's',L'j',L'o',L'k',L',',L'k',L'a',L'r',L'a',L's',L'j',L'o',L'h',L'k',L'a',L',',L'k',L'á',L'r',L'á',L'š',L'j',L'o',L'h',L'k',L'a',L',',L'k',L'a',L'r',L'l',L's',L'o',L'y',L',',L'g',L'a',L'l',L's',L'a',L',',L'g',L'á',L'l',L's',L'á',L',',L'k',L'a',L'r',L'm',L'o',L'y',L',',L'k',L'a',L'r',
+	L'm',L'ø',L'y',L',',L'k',L'a',L'u',L't',L'o',L'k',L'e',L'i',L'n',L'o',L',',L'g',L'u',L'o',L'v',L'd',L'a',L'g',L'e',L'a',L'i',L'd',L'n',L'u',L',',L'k',L'l',L'e',L'p',L'p',L',',L'k',L'l',L'a',L'b',L'u',L',',L'k',L'l',L'æ',L'b',L'u',L',',L'k',L'o',L'n',L'g',L's',L'b',L'e',L'r',L'g',L',',L'k',L'o',L'n',L'g',L's',L'v',L'i',L'n',L'g',L'e',L'r',L',',L'k',L'r',L'a',L'g',L'e',L'r',L'o',L',',L'k',L'r',L'a',L'g',L'e',L'r',L'ø',L',',L'k',L'r',L'i',L's',L't',L'i',L'a',L'n',L's',L'a',L'n',L'd',L',',L'k',L'r',
+	L'i',L's',L't',L'i',L'a',L'n',L's',L'u',L'n',L'd',L',',L'k',L'r',L'o',L'd',L's',L'h',L'e',L'r',L'a',L'd',L',',L'k',L'r',L'ø',L'd',L's',L'h',L'e',L'r',L'a',L'd',L',',L'k',L'v',L'a',L'l',L's',L'u',L'n',L'd',L',',L'r',L'a',L'h',L'k',L'k',L'e',L'r',L'a',L'v',L'j',L'u',L',',L'r',L'á',L'h',L'k',L'k',L'e',L'r',L'á',L'v',L'j',L'u',L',',L'k',L'v',L'a',L'm',L',',L'k',L'v',L'i',L'n',L'e',L's',L'd',L'a',L'l',L',',L'k',L'v',L'i',L'n',L'n',L'h',L'e',L'r',L'a',L'd',L',',L'k',L'v',L'i',L't',L'e',L's',L'e',L'i',
+	L'd',L',',L'k',L'v',L'i',L't',L's',L'o',L'y',L',',L'k',L'v',L'i',L't',L's',L'ø',L'y',L',',L'k',L'v',L'a',L'f',L'j',L'o',L'r',L'd',L',',L'k',L'v',L'æ',L'f',L'j',L'o',L'r',L'd',L',',L'g',L'i',L'e',L'h',L't',L'a',L'v',L'u',L'o',L'a',L't',L'n',L'a',L',',L'k',L'v',L'a',L'n',L'a',L'n',L'g',L'e',L'n',L',',L'k',L'v',L'æ',L'n',L'a',L'n',L'g',L'e',L'n',L',',L'n',L'a',L'v',L'u',L'o',L't',L'n',L'a',L',',L'n',L'á',L'v',L'u',L'o',L't',L'n',L'a',L',',L'k',L'a',L'f',L'j',L'o',L'r',L'd',L',',L'k',L'å',L'f',L'j',
+	L'o',L'r',L'd',L',',L'g',L'a',L'i',L'v',L'u',L'o',L't',L'n',L'a',L',',L'g',L'á',L'i',L'v',L'u',L'o',L't',L'n',L'a',L',',L'l',L'a',L'r',L'v',L'i',L'k',L',',L'l',L'a',L'v',L'a',L'n',L'g',L'e',L'n',L',',L'l',L'a',L'v',L'a',L'g',L'i',L's',L',',L'l',L'o',L'a',L'b',L'a',L't',L',',L'l',L'o',L'a',L'b',L'á',L't',L',',L'l',L'e',L'b',L'e',L's',L'b',L'y',L',',L'd',L'a',L'v',L'v',L'e',L's',L'i',L'i',L'd',L'a',L',',L'l',L'e',L'i',L'k',L'a',L'n',L'g',L'e',L'r',L',',L'l',L'e',L'i',L'r',L'f',L'j',L'o',L'r',L'd',
+	L',',L'l',L'e',L'k',L'a',L',',L'l',L'e',L'k',L's',L'v',L'i',L'k',L',',L'l',L'e',L'n',L'v',L'i',L'k',L',',L'l',L'e',L'a',L'n',L'g',L'a',L'v',L'i',L'i',L'k',L'a',L',',L'l',L'e',L'a',L'ŋ',L'g',L'a',L'v',L'i',L'i',L'k',L'a',L',',L'l',L'e',L's',L'j',L'a',L',',L'l',L'e',L'v',L'a',L'n',L'g',L'e',L'r',L',',L'l',L'i',L'e',L'r',L',',L'l',L'i',L'e',L'r',L'n',L'e',L',',L'l',L'i',L'l',L'l',L'e',L'h',L'a',L'm',L'm',L'e',L'r',L',',L'l',L'i',L'l',L'l',L'e',L's',L'a',L'n',L'd',L',',L'l',L'i',L'n',L'd',L'e',L's',
+	L'n',L'e',L's',L',',L'l',L'i',L'n',L'd',L'a',L's',L',',L'l',L'i',L'n',L'd',L'å',L's',L',',L'l',L'o',L'm',L',',L'l',L'o',L'p',L'p',L'a',L',',L'l',L'a',L'h',L'p',L'p',L'i',L',',L'l',L'á',L'h',L'p',L'p',L'i',L',',L'l',L'u',L'n',L'd',L',',L'l',L'u',L'n',L'n',L'e',L'r',L',',L'l',L'u',L'r',L'o',L'y',L',',L'l',L'u',L'r',L'ø',L'y',L',',L'l',L'u',L's',L't',L'e',L'r',L',',L'l',L'y',L'n',L'g',L'd',L'a',L'l',L',',L'l',L'y',L'n',L'g',L'e',L'n',L',',L'i',L'v',L'g',L'u',L',',L'l',L'a',L'r',L'd',L'a',L'l',L',',
+	L'l',L'e',L'r',L'd',L'a',L'l',L',',L'l',L'æ',L'r',L'd',L'a',L'l',L',',L'l',L'o',L'd',L'i',L'n',L'g',L'e',L'n',L',',L'l',L'ø',L'd',L'i',L'n',L'g',L'e',L'n',L',',L'l',L'o',L'r',L'e',L'n',L's',L'k',L'o',L'g',L',',L'l',L'ø',L'r',L'e',L'n',L's',L'k',L'o',L'g',L',',L'l',L'o',L't',L'e',L'n',L',',L'l',L'ø',L't',L'e',L'n',L',',L'm',L'a',L'l',L'v',L'i',L'k',L',',L'm',L'a',L's',L'o',L'y',L',',L'm',L'å',L's',L'ø',L'y',L',',L'm',L'u',L'o',L's',L'a',L't',L',',L'm',L'u',L'o',L's',L'á',L't',L',',L'm',L'a',L'n',
+	L'd',L'a',L'l',L',',L'm',L'a',L'r',L'k',L'e',L'r',L',',L'm',L'a',L'r',L'n',L'a',L'r',L'd',L'a',L'l',L',',L'm',L'a',L's',L'f',L'j',L'o',L'r',L'd',L'e',L'n',L',',L'm',L'e',L'l',L'a',L'n',L'd',L',',L'm',L'e',L'l',L'd',L'a',L'l',L',',L'm',L'e',L'l',L'h',L'u',L's',L',',L'm',L'e',L'l',L'o',L'y',L',',L'm',L'e',L'l',L'ø',L'y',L',',L'm',L'e',L'r',L'a',L'k',L'e',L'r',L',',L'm',L'e',L'r',L'å',L'k',L'e',L'r',L',',L'm',L'o',L'a',L'r',L'e',L'k',L'e',L',',L'm',L'o',L'å',L'r',L'e',L'k',L'e',L',',L'm',L'i',L'd',
+	L's',L'u',L'n',L'd',L',',L'm',L'i',L'd',L't',L'r',L'e',L'-',L'g',L'a',L'u',L'l',L'd',L'a',L'l',L',',L'm',L'o',L'd',L'a',L'l',L'e',L'n',L',',L'm',L'o',L'd',L'u',L'm',L',',L'm',L'o',L'l',L'd',L'e',L',',L'm',L'o',L's',L'k',L'e',L'n',L'e',L's',L',',L'm',L'o',L's',L's',L',',L'm',L'o',L's',L'v',L'i',L'k',L',',L'm',L'a',L'l',L's',L'e',L'l',L'v',L',',L'm',L'å',L'l',L's',L'e',L'l',L'v',L',',L'm',L'a',L'l',L'a',L't',L'v',L'u',L'o',L'p',L'm',L'i',L',',L'm',L'á',L'l',L'a',L't',L'v',L'u',L'o',L'p',L'm',L'i',
+	L',',L'n',L'a',L'm',L'd',L'a',L'l',L's',L'e',L'i',L'd',L',',L'a',L'e',L'j',L'r',L'i',L'e',L',',L'n',L'a',L'm',L's',L'o',L's',L',',L'n',L'a',L'm',L's',L's',L'k',L'o',L'g',L'a',L'n',L',',L'n',L'a',L'a',L'm',L'e',L's',L'j',L'e',L'v',L'u',L'e',L'm',L'i',L'e',L',',L'n',L'å',L'å',L'm',L'e',L's',L'j',L'e',L'v',L'u',L'e',L'm',L'i',L'e',L',',L'l',L'a',L'a',L'k',L'e',L's',L'v',L'u',L'e',L'm',L'i',L'e',L',',L'n',L'a',L'n',L'n',L'e',L's',L't',L'a',L'd',L',',L'n',L'a',L'r',L'v',L'i',L'k',L',',L'n',L'a',L'r',
+	L'v',L'i',L'i',L'k',L'a',L',',L'n',L'a',L'u',L's',L't',L'd',L'a',L'l',L',',L'n',L'e',L'd',L'r',L'e',L'-',L'e',L'i',L'k',L'e',L'r',L',',L'a',L'k',L'e',L'r',L's',L'h',L'u',L's',L'(',L'1',L':',L'n',L'e',L's',L')',L',',L'b',L'u',L's',L'k',L'e',L'r',L'u',L'd',L'(',L'1',L':',L'n',L'e',L's',L')',L',',L'n',L'e',L's',L'n',L'a',L',',L'n',L'e',L's',L'o',L'd',L'd',L'e',L'n',L',',L'n',L'e',L's',L's',L'e',L'b',L'y',L',',L'u',L'n',L'j',L'a',L'r',L'g',L'a',L',',L'u',L'n',L'j',L'á',L'r',L'g',L'a',L',',L'n',L'e',
+	L's',L's',L'e',L't',L',',L'n',L'i',L's',L's',L'e',L'd',L'a',L'l',L',',L'n',L'i',L't',L't',L'e',L'd',L'a',L'l',L',',L'n',L'o',L'r',L'd',L'-',L'a',L'u',L'r',L'd',L'a',L'l',L',',L'n',L'o',L'r',L'd',L'-',L'f',L'r',L'o',L'n',L',',L'n',L'o',L'r',L'd',L'-',L'o',L'd',L'a',L'l',L',',L'n',L'o',L'r',L'd',L'd',L'a',L'l',L',',L'n',L'o',L'r',L'd',L'k',L'a',L'p',L'p',L',',L'd',L'a',L'v',L'v',L'e',L'n',L'j',L'a',L'r',L'g',L'a',L',',L'd',L'a',L'v',L'v',L'e',L'n',L'j',L'á',L'r',L'g',L'a',L',',L'n',L'o',L'r',L'd',
+	L'r',L'e',L'-',L'l',L'a',L'n',L'd',L',',L'n',L'o',L'r',L'd',L'r',L'e',L'i',L's',L'a',L',',L'r',L'a',L'i',L's',L'a',L',',L'r',L'á',L'i',L's',L'a',L',',L'n',L'o',L'r',L'e',L'-',L'o',L'g',L'-',L'u',L'v',L'd',L'a',L'l',L',',L'n',L'o',L't',L'o',L'd',L'd',L'e',L'n',L',',L'n',L'a',L'r',L'o',L'y',L',',L'n',L'æ',L'r',L'ø',L'y',L',',L'n',L'o',L't',L't',L'e',L'r',L'o',L'y',L',',L'n',L'ø',L't',L't',L'e',L'r',L'ø',L'y',L',',L'o',L'd',L'd',L'a',L',',L'o',L'k',L's',L'n',L'e',L's',L',',L'ø',L'k',L's',L'n',L'e',
+	L's',L',',L'o',L'p',L'p',L'd',L'a',L'l',L',',L'o',L'p',L'p',L'e',L'g',L'a',L'r',L'd',L',',L'o',L'p',L'p',L'e',L'g',L'å',L'r',L'd',L',',L'o',L'r',L'k',L'd',L'a',L'l',L',',L'o',L'r',L'l',L'a',L'n',L'd',L',',L'ø',L'r',L'l',L'a',L'n',L'd',L',',L'o',L'r',L's',L'k',L'o',L'g',L',',L'ø',L'r',L's',L'k',L'o',L'g',L',',L'o',L'r',L's',L't',L'a',L',',L'ø',L'r',L's',L't',L'a',L',',L'h',L'e',L'd',L'm',L'a',L'r',L'k',L'(',L'3',L':',L'o',L's',L',',L'v',L'a',L'l',L'e',L'r',L',',L'v',L'å',L'l',L'e',L'r',L')',L',',
+	L'h',L'o',L'r',L'd',L'a',L'l',L'a',L'n',L'd',L'(',L'1',L':',L'o',L's',L')',L',',L'o',L's',L'e',L'n',L',',L'o',L's',L't',L'e',L'r',L'o',L'y',L',',L'o',L's',L't',L'e',L'r',L'ø',L'y',L',',L'o',L's',L't',L'r',L'e',L'-',L't',L'o',L't',L'e',L'n',L',',L'ø',L's',L't',L'r',L'e',L'-',L't',L'o',L't',L'e',L'n',L',',L'o',L'v',L'e',L'r',L'h',L'a',L'l',L'l',L'a',L',',L'o',L'v',L'r',L'e',L'-',L'e',L'i',L'k',L'e',L'r',L',',L'ø',L'v',L'r',L'e',L'-',L'e',L'i',L'k',L'e',L'r',L',',L'o',L'y',L'e',L'r',L',',L'ø',L'y',
+	L'e',L'r',L',',L'o',L'y',L'g',L'a',L'r',L'd',L'e',L'n',L',',L'ø',L'y',L'g',L'a',L'r',L'd',L'e',L'n',L',',L'o',L'y',L's',L't',L'r',L'e',L'-',L's',L'l',L'i',L'd',L'r',L'e',L',',L'ø',L'y',L's',L't',L'r',L'e',L'-',L's',L'l',L'i',L'd',L'r',L'e',L',',L'p',L'o',L'r',L's',L'a',L'n',L'g',L'e',L'r',L',',L'p',L'o',L'r',L's',L'a',L'n',L'g',L'u',L',',L'p',L'o',L'r',L's',L'á',L'ŋ',L'g',L'u',L',',L'p',L'o',L'r',L's',L'g',L'r',L'u',L'n',L'n',L',',L'r',L'a',L'd',L'o',L'y',L',',L'r',L'a',L'd',L'ø',L'y',L',',L'r',
+	L'a',L'k',L'k',L'e',L's',L't',L'a',L'd',L',',L'r',L'a',L'n',L'a',L',',L'r',L'u',L'o',L'v',L'a',L't',L',',L'r',L'a',L'n',L'd',L'a',L'b',L'e',L'r',L'g',L',',L'r',L'a',L'u',L'm',L'a',L',',L'r',L'e',L'n',L'd',L'a',L'l',L'e',L'n',L',',L'r',L'e',L'n',L'n',L'e',L'b',L'u',L',',L'r',L'e',L'n',L'n',L'e',L's',L'o',L'y',L',',L'r',L'e',L'n',L'n',L'e',L's',L'ø',L'y',L',',L'r',L'i',L'n',L'd',L'a',L'l',L',',L'r',L'i',L'n',L'g',L'e',L'b',L'u',L',',L'r',L'i',L'n',L'g',L'e',L'r',L'i',L'k',L'e',L',',L'r',L'i',L'n',
+	L'g',L's',L'a',L'k',L'e',L'r',L',',L'r',L'i',L's',L's',L'a',L',',L'r',L'i',L's',L'o',L'r',L',',L'r',L'i',L's',L'ø',L'r',L',',L'r',L'o',L'a',L'n',L',',L'r',L'o',L'l',L'l',L'a',L'g',L',',L'r',L'y',L'g',L'g',L'e',L',',L'r',L'a',L'l',L'i',L'n',L'g',L'e',L'n',L',',L'r',L'æ',L'l',L'i',L'n',L'g',L'e',L'n',L',',L'r',L'o',L'd',L'o',L'y',L',',L'r',L'ø',L'd',L'ø',L'y',L',',L'r',L'o',L'm',L's',L'k',L'o',L'g',L',',L'r',L'ø',L'm',L's',L'k',L'o',L'g',L',',L'r',L'o',L'r',L'o',L's',L',',L'r',L'ø',L'r',L'o',L's',
+	L',',L'r',L'o',L's',L't',L',',L'r',L'ø',L's',L't',L',',L'r',L'o',L'y',L'k',L'e',L'n',L',',L'r',L'ø',L'y',L'k',L'e',L'n',L',',L'r',L'o',L'y',L'r',L'v',L'i',L'k',L',',L'r',L'ø',L'y',L'r',L'v',L'i',L'k',L',',L'r',L'a',L'd',L'e',L',',L'r',L'å',L'd',L'e',L',',L's',L'a',L'l',L'a',L'n',L'g',L'e',L'n',L',',L's',L'i',L'e',L'l',L'l',L'a',L'k',L',',L's',L'a',L'l',L't',L'd',L'a',L'l',L',',L's',L'a',L'l',L'a',L't',L',',L's',L'á',L'l',L'á',L't',L',',L's',L'á',L'l',L'a',L't',L',',L's',L'a',L'm',L'n',L'a',L'n',
+	L'g',L'e',L'r',L',',L'v',L'e',L's',L't',L'f',L'o',L'l',L'd',L'(',L'1',L':',L's',L'a',L'n',L'd',L'e',L')',L',',L's',L'a',L'n',L'd',L'e',L'f',L'j',L'o',L'r',L'd',L',',L's',L'a',L'n',L'd',L'n',L'e',L's',L',',L's',L'a',L'n',L'd',L'o',L'y',L',',L's',L'a',L'n',L'd',L'ø',L'y',L',',L's',L'a',L'r',L'p',L's',L'b',L'o',L'r',L'g',L',',L's',L'a',L'u',L'd',L'a',L',',L's',L'a',L'u',L'h',L'e',L'r',L'a',L'd',L',',L's',L'e',L'l',L',',L's',L'e',L'l',L'b',L'u',L',',L's',L'e',L'l',L'j',L'e',L',',L's',L'e',L'l',L'j',
+	L'o',L'r',L'd',L',',L's',L'i',L'g',L'd',L'a',L'l',L',',L's',L'i',L'l',L'j',L'a',L'n',L',',L's',L'i',L'r',L'd',L'a',L'l',L',',L's',L'k',L'a',L'u',L'n',L',',L's',L'k',L'e',L'd',L's',L'm',L'o',L',',L's',L'k',L'i',L',',L's',L'k',L'i',L'e',L'n',L',',L's',L'k',L'i',L'p',L't',L'v',L'e',L't',L',',L's',L'k',L'j',L'e',L'r',L'v',L'o',L'y',L',',L's',L'k',L'j',L'e',L'r',L'v',L'ø',L'y',L',',L's',L'k',L'i',L'e',L'r',L'v',L'a',L',',L's',L'k',L'i',L'e',L'r',L'v',L'á',L',',L's',L'k',L'j',L'a',L'k',L',',L's',L'k',
+	L'j',L'å',L'k',L',',L's',L'k',L'o',L'd',L'j',L'e',L',',L's',L'k',L'a',L'n',L'l',L'a',L'n',L'd',L',',L's',L'k',L'å',L'n',L'l',L'a',L'n',L'd',L',',L's',L'k',L'a',L'n',L'i',L't',L',',L's',L'k',L'á',L'n',L'i',L't',L',',L's',L'm',L'o',L'l',L'a',L',',L's',L'm',L'ø',L'l',L'a',L',',L's',L'n',L'i',L'l',L'l',L'f',L'j',L'o',L'r',L'd',L',',L's',L'n',L'a',L's',L'a',L',',L's',L'n',L'å',L's',L'a',L',',L's',L'n',L'o',L'a',L's',L'a',L',',L's',L'n',L'a',L'a',L's',L'e',L',',L's',L'n',L'å',L'a',L's',L'e',L',',L's',
+	L'o',L'g',L'n',L'd',L'a',L'l',L',',L's',L'o',L'k',L'n',L'd',L'a',L'l',L',',L's',L'o',L'l',L'a',L',',L's',L'o',L'l',L'u',L'n',L'd',L',',L's',L'o',L'n',L'g',L'd',L'a',L'l',L'e',L'n',L',',L's',L'o',L'r',L't',L'l',L'a',L'n',L'd',L',',L's',L'p',L'y',L'd',L'e',L'b',L'e',L'r',L'g',L',',L's',L't',L'a',L'n',L'g',L'e',L',',L's',L't',L'a',L'v',L'a',L'n',L'g',L'e',L'r',L',',L's',L't',L'e',L'i',L'g',L'e',L'n',L',',L's',L't',L'e',L'i',L'n',L'k',L'j',L'e',L'r',L',',L's',L't',L'j',L'o',L'r',L'd',L'a',L'l',L',',
+	L's',L't',L'j',L'ø',L'r',L'd',L'a',L'l',L',',L's',L't',L'o',L'k',L'k',L'e',L',',L's',L't',L'o',L'r',L'-',L'e',L'l',L'v',L'd',L'a',L'l',L',',L's',L't',L'o',L'r',L'd',L',',L's',L't',L'o',L'r',L'd',L'a',L'l',L',',L's',L't',L'o',L'r',L'f',L'j',L'o',L'r',L'd',L',',L'o',L'm',L'a',L's',L'v',L'u',L'o',L't',L'n',L'a',L',',L's',L't',L'r',L'a',L'n',L'd',L',',L's',L't',L'r',L'a',L'n',L'd',L'a',L',',L's',L't',L'r',L'y',L'n',L',',L's',L'u',L'l',L'a',L',',L's',L'u',L'l',L'd',L'a',L'l',L',',L's',L'u',L'n',L'd',
+	L',',L's',L'u',L'n',L'n',L'd',L'a',L'l',L',',L's',L'u',L'r',L'n',L'a',L'd',L'a',L'l',L',',L's',L'v',L'e',L'i',L'o',L',',L's',L'v',L'e',L'l',L'v',L'i',L'k',L',',L's',L'y',L'k',L'k',L'y',L'l',L'v',L'e',L'n',L',',L's',L'o',L'g',L'n',L'e',L',',L's',L'ø',L'g',L'n',L'e',L',',L's',L'o',L'm',L'n',L'a',L',',L's',L'ø',L'm',L'n',L'a',L',',L's',L'o',L'n',L'd',L'r',L'e',L'-',L'l',L'a',L'n',L'd',L',',L's',L'ø',L'n',L'd',L'r',L'e',L'-',L'l',L'a',L'n',L'd',L',',L's',L'o',L'r',L'-',L'a',L'u',L'r',L'd',L'a',L'l',
+	L',',L's',L'ø',L'r',L'-',L'a',L'u',L'r',L'd',L'a',L'l',L',',L's',L'o',L'r',L'-',L'f',L'r',L'o',L'n',L',',L's',L'ø',L'r',L'-',L'f',L'r',L'o',L'n',L',',L's',L'o',L'r',L'-',L'o',L'd',L'a',L'l',L',',L's',L'ø',L'r',L'-',L'o',L'd',L'a',L'l',L',',L's',L'o',L'r',L'-',L'v',L'a',L'r',L'a',L'n',L'g',L'e',L'r',L',',L's',L'ø',L'r',L'-',L'v',L'a',L'r',L'a',L'n',L'g',L'e',L'r',L',',L'm',L'a',L't',L't',L'a',L'-',L'v',L'a',L'r',L'j',L'j',L'a',L't',L',',L'm',L'á',L't',L't',L'a',L'-',L'v',L'á',L'r',L'j',L'j',L'a',
+	L't',L',',L's',L'o',L'r',L'f',L'o',L'l',L'd',L',',L's',L'ø',L'r',L'f',L'o',L'l',L'd',L',',L's',L'o',L'r',L'r',L'e',L'i',L's',L'a',L',',L's',L'ø',L'r',L'r',L'e',L'i',L's',L'a',L',',L's',L'o',L'r',L'u',L'm',L',',L's',L'ø',L'r',L'u',L'm',L',',L't',L'a',L'n',L'a',L',',L'd',L'e',L'a',L't',L'n',L'u',L',',L't',L'i',L'm',L'e',L',',L't',L'i',L'n',L'g',L'v',L'o',L'l',L'l',L',',L't',L'i',L'n',L'n',L',',L't',L'j',L'e',L'l',L'd',L's',L'u',L'n',L'd',L',',L'd',L'i',L'e',L'l',L'd',L'd',L'a',L'n',L'u',L'o',L'r',
+	L'r',L'i',L',',L't',L'j',L'o',L'm',L'e',L',',L't',L'j',L'ø',L'm',L'e',L',',L't',L'o',L'k',L'k',L'e',L',',L't',L'o',L'l',L'g',L'a',L',',L't',L'o',L'r',L's',L'k',L'e',L'n',L',',L't',L'r',L'a',L'n',L'o',L'y',L',',L't',L'r',L'a',L'n',L'ø',L'y',L',',L't',L'r',L'o',L'm',L's',L'o',L',',L't',L'r',L'o',L'm',L's',L'ø',L',',L't',L'r',L'o',L'm',L's',L'a',L',',L'r',L'o',L'm',L's',L'a',L',',L't',L'r',L'o',L'n',L'd',L'h',L'e',L'i',L'm',L',',L't',L'r',L'o',L'a',L'n',L'd',L'i',L'n',L',',L't',L'r',L'y',L's',L'i',
+	L'l',L',',L't',L'r',L'a',L'n',L'a',L',',L't',L'r',L'æ',L'n',L'a',L',',L't',L'r',L'o',L'g',L's',L't',L'a',L'd',L',',L't',L'r',L'ø',L'g',L's',L't',L'a',L'd',L',',L't',L'v',L'e',L'd',L'e',L's',L't',L'r',L'a',L'n',L'd',L',',L't',L'y',L'd',L'a',L'l',L',',L't',L'y',L'n',L's',L'e',L't',L',',L't',L'y',L's',L'f',L'j',L'o',L'r',L'd',L',',L'd',L'i',L'v',L't',L'a',L's',L'v',L'u',L'o',L'd',L'n',L'a',L',',L'd',L'i',L'v',L't',L't',L'a',L's',L'v',L'u',L'o',L't',L'n',L'a',L',',L't',L'y',L's',L'n',L'e',L's',L',',
+	L't',L'y',L's',L'v',L'a',L'r',L',',L't',L'y',L's',L'v',L'æ',L'r',L',',L't',L'o',L'n',L's',L'b',L'e',L'r',L'g',L',',L't',L'ø',L'n',L's',L'b',L'e',L'r',L'g',L',',L'u',L'l',L'l',L'e',L'n',L's',L'a',L'k',L'e',L'r',L',',L'u',L'l',L'l',L'e',L'n',L's',L'v',L'a',L'n',L'g',L',',L'u',L'l',L'v',L'i',L'k',L',',L'u',L't',L's',L'i',L'r',L'a',L',',L'v',L'a',L'd',L's',L'o',L',',L'v',L'a',L'd',L's',L'ø',L',',L'c',L'a',L'h',L'c',L'e',L's',L'u',L'o',L'l',L'o',L',',L'č',L'á',L'h',L'c',L'e',L's',L'u',L'o',L'l',L'o',
+	L',',L'v',L'a',L'k',L's',L'd',L'a',L'l',L',',L'v',L'a',L'l',L'l',L'e',L',',L'v',L'a',L'n',L'g',L',',L'v',L'a',L'n',L'y',L'l',L'v',L'e',L'n',L',',L'v',L'a',L'r',L'd',L'o',L',',L'v',L'a',L'r',L'd',L'ø',L',',L'v',L'a',L'r',L'g',L'g',L'a',L't',L',',L'v',L'á',L'r',L'g',L'g',L'á',L't',L',',L'v',L'e',L'f',L's',L'n',L',',L'v',L'a',L'a',L'p',L's',L't',L'e',L',',L'v',L'e',L'g',L'a',L',',L'v',L'e',L'g',L'a',L'r',L's',L'h',L'e',L'i',L',',L'v',L'e',L'g',L'å',L'r',L's',L'h',L'e',L'i',L',',L'v',L'e',L'n',L'n',
+	L'e',L's',L'l',L'a',L',',L'v',L'e',L'r',L'd',L'a',L'l',L',',L'v',L'e',L'r',L'r',L'a',L'n',L',',L'v',L'e',L's',L't',L'b',L'y',L',',L'v',L'e',L's',L't',L'n',L'e',L's',L',',L'v',L'e',L's',L't',L'r',L'e',L'-',L's',L'l',L'i',L'd',L'r',L'e',L',',L'v',L'e',L's',L't',L'r',L'e',L'-',L't',L'o',L't',L'e',L'n',L',',L'v',L'e',L's',L't',L'v',L'a',L'g',L'o',L'y',L',',L'v',L'e',L's',L't',L'v',L'å',L'g',L'ø',L'y',L',',L'v',L'e',L'v',L'e',L'l',L's',L't',L'a',L'd',L',',L'v',L'i',L'k',L',',L'v',L'i',L'k',L'n',L'a',
+	L',',L'v',L'i',L'n',L'd',L'a',L'f',L'j',L'o',L'r',L'd',L',',L'v',L'o',L'l',L'd',L'a',L',',L'v',L'o',L's',L's',L',',L'v',L'a',L'r',L'o',L'y',L',',L'v',L'æ',L'r',L'ø',L'y',L',',L'v',L'a',L'g',L'a',L'n',L',',L'v',L'å',L'g',L'a',L'n',L',',L'v',L'o',L'a',L'g',L'a',L't',L',',L'v',L'a',L'g',L's',L'o',L'y',L',',L'v',L'å',L'g',L's',L'ø',L'y',L',',L'v',L'a',L'g',L'a',L',',L'v',L'å',L'g',L'å',L',',L'o',L's',L't',L'f',L'o',L'l',L'd',L'(',L'1',L':',L'v',L'a',L'l',L'e',L'r',L')',L',',L'ø',L's',L't',L'f',L'o',
+	L'l',L'd',L'(',L'1',L':',L'v',L'å',L'l',L'e',L'r',L')',L',',L'c',L'o',L')',L',',L'n',L'p',L'(',L'1',L':',L'*',L')',L',',L'n',L'r',L'(',L'7',L':',L'b',L'i',L'z',L',',L'i',L'n',L'f',L'o',L',',L'g',L'o',L'v',L',',L'e',L'd',L'u',L',',L'o',L'r',L'g',L',',L'n',L'e',L't',L',',L'c',L'o',L'm',L')',L',',L'n',L'u',L'(',L'3',L':',L'm',L'e',L'r',L's',L'e',L'i',L'n',L'e',L',',L'm',L'i',L'n',L'e',L',',L's',L'h',L'a',L'c',L'k',L'n',L'e',L't',L')',L',',L'n',L'z',L'(',L'1',L':',L'*',L')',L',',L'o',L'm',L'(',L'1',
+	L'1',L':',L'*',L',',L'm',L'e',L'd',L'i',L'a',L'p',L'h',L'o',L'n',L'e',L'(',L'1',L':',L'!',L')',L',',L'n',L'a',L'w',L'r',L'a',L's',L't',L'e',L'l',L'e',L'c',L'o',L'm',L'(',L'1',L':',L'!',L')',L',',L'n',L'a',L'w',L'r',L'a',L's',L'(',L'1',L':',L'!',L')',L',',L'o',L'm',L'a',L'n',L'm',L'o',L'b',L'i',L'l',L'e',L'(',L'1',L':',L'!',L')',L',',L'o',L'm',L'a',L'n',L'p',L'o',L's',L't',L'(',L'1',L':',L'!',L')',L',',L'o',L'm',L'a',L'n',L't',L'e',L'l',L'(',L'1',L':',L'!',L')',L',',L'r',L'a',L'k',L'p',L'e',L't',
+	L'r',L'o',L'l',L'e',L'u',L'm',L'(',L'1',L':',L'!',L')',L',',L's',L'i',L'e',L'm',L'e',L'n',L's',L'(',L'1',L':',L'!',L')',L',',L's',L'o',L'n',L'g',L'f',L'e',L's',L't',L'(',L'1',L':',L'!',L')',L',',L's',L't',L'a',L't',L'e',L'c',L'o',L'u',L'n',L'c',L'i',L'l',L'(',L'1',L':',L'!',L')',L')',L',',L'o',L'r',L'g',L'(',L'5',L'3',L':',L'a',L'e',L',',L'u',L's',L',',L'z',L'a',L',',L'd',L'y',L'n',L'd',L'n',L's',L'(',L'2',L':',L'g',L'o',L',',L'h',L'o',L'm',L'e',L')',L',',L'b',L'l',L'o',L'g',L'd',L'n',L's',L',',
+	L'b',L'l',L'o',L'g',L's',L'i',L't',L'e',L',',L'b',L'o',L'l',L'd',L'l',L'y',L'g',L'o',L'i',L'n',L'g',L'n',L'o',L'w',L'h',L'e',L'r',L'e',L',',L'd',L'n',L's',L'a',L'l',L'i',L'a',L's',L',',L'd',L'n',L's',L'd',L'o',L'j',L'o',L',',L'd',L'o',L'e',L's',L'n',L't',L'e',L'x',L'i',L's',L't',L',',L'd',L'o',L'n',L't',L'e',L'x',L'i',L's',L't',L',',L'd',L'o',L'o',L'm',L'd',L'n',L's',L',',L'd',L'v',L'r',L'd',L'n',L's',L',',L'd',L'y',L'n',L'a',L'l',L'i',L'a',L's',L',',L'e',L'n',L'd',L'o',L'f',L'i',L'n',L't',L'e',
+	L'r',L'n',L'e',L't',L',',L'e',L'n',L'd',L'o',L'f',L't',L'h',L'e',L'i',L'n',L't',L'e',L'r',L'n',L'e',L't',L',',L'f',L'r',L'o',L'm',L'-',L'm',L'e',L',',L'g',L'a',L'm',L'e',L'-',L'h',L'o',L's',L't',L',',L'g',L'o',L't',L'd',L'n',L's',L',',L'h',L'o',L'b',L'b',L'y',L'-',L's',L'i',L't',L'e',L',',L'h',L'o',L'm',L'e',L'd',L'n',L's',L',',L'h',L'o',L'm',L'e',L'f',L't',L'p',L',',L'h',L'o',L'm',L'e',L'l',L'i',L'n',L'u',L'x',L',',L'h',L'o',L'm',L'e',L'u',L'n',L'i',L'x',L',',L'i',L's',L'-',L'a',L'-',L'b',L'r',
+	L'u',L'i',L'n',L's',L'f',L'a',L'n',L',',L'i',L's',L'-',L'a',L'-',L'c',L'a',L'n',L'd',L'i',L'd',L'a',L't',L'e',L',',L'i',L's',L'-',L'a',L'-',L'c',L'e',L'l',L't',L'i',L'c',L's',L'f',L'a',L'n',L',',L'i',L's',L'-',L'a',L'-',L'c',L'h',L'e',L'f',L',',L'i',L's',L'-',L'a',L'-',L'g',L'e',L'e',L'k',L',',L'i',L's',L'-',L'a',L'-',L'k',L'n',L'i',L'g',L'h',L't',L',',L'i',L's',L'-',L'a',L'-',L'l',L'i',L'n',L'u',L'x',L'-',L'u',L's',L'e',L'r',L',',L'i',L's',L'-',L'a',L'-',L'p',L'a',L't',L's',L'f',L'a',L'n',L',',
+	L'i',L's',L'-',L'a',L'-',L's',L'o',L'x',L'f',L'a',L'n',L',',L'i',L's',L'-',L'f',L'o',L'u',L'n',L'd',L',',L'i',L's',L'-',L'l',L'o',L's',L't',L',',L'i',L's',L'-',L's',L'a',L'v',L'e',L'd',L',',L'i',L's',L'-',L'v',L'e',L'r',L'y',L'-',L'b',L'a',L'd',L',',L'i',L's',L'-',L'v',L'e',L'r',L'y',L'-',L'e',L'v',L'i',L'l',L',',L'i',L's',L'-',L'v',L'e',L'r',L'y',L'-',L'g',L'o',L'o',L'd',L',',L'i',L's',L'-',L'v',L'e',L'r',L'y',L'-',L'n',L'i',L'c',L'e',L',',L'i',L's',L'-',L'v',L'e',L'r',L'y',L'-',L's',L'w',L'e',
+	L'e',L't',L',',L'i',L's',L'a',L'-',L'g',L'e',L'e',L'k',L',',L'k',L'i',L'c',L'k',L's',L'-',L'a',L's',L's',L',',L'm',L'i',L's',L'c',L'o',L'n',L'f',L'u',L's',L'e',L'd',L',',L'p',L'o',L'd',L'z',L'o',L'n',L'e',L',',L'r',L'e',L'a',L'd',L'm',L'y',L'b',L'l',L'o',L'g',L',',L's',L'e',L'l',L'f',L'i',L'p',L',',L's',L'e',L'l',L'l',L's',L'y',L'o',L'u',L'r',L'h',L'o',L'm',L'e',L',',L's',L'e',L'r',L'v',L'e',L'b',L'b',L's',L',',L's',L'e',L'r',L'v',L'e',L'f',L't',L'p',L',',L's',L'e',L'r',L'v',L'e',L'g',L'a',L'm',
+	L'e',L',',L's',L't',L'u',L'f',L'f',L'-',L'4',L'-',L's',L'a',L'l',L'e',L',',L'w',L'e',L'b',L'h',L'o',L'p',L')',L',',L'p',L'a',L'(',L'1',L'1',L':',L'a',L'c',L',',L'g',L'o',L'b',L',',L'c',L'o',L'm',L',',L'o',L'r',L'g',L',',L's',L'l',L'd',L',',L'e',L'd',L'u',L',',L'n',L'e',L't',L',',L'i',L'n',L'g',L',',L'a',L'b',L'o',L',',L'm',L'e',L'd',L',',L'n',L'o',L'm',L')',L',',L'p',L'e',L'(',L'7',L':',L'e',L'd',L'u',L',',L'g',L'o',L'b',L',',L'n',L'o',L'm',L',',L'm',L'i',L'l',L',',L'o',L'r',L'g',L',',L'c',L'o',
+	L'm',L',',L'n',L'e',L't',L')',L',',L'p',L'f',L'(',L'3',L':',L'c',L'o',L'm',L',',L'o',L'r',L'g',L',',L'e',L'd',L'u',L')',L',',L'p',L'g',L'(',L'1',L':',L'*',L')',L',',L'p',L'h',L'(',L'8',L':',L'c',L'o',L'm',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L',',L'g',L'o',L'v',L',',L'e',L'd',L'u',L',',L'n',L'g',L'o',L',',L'm',L'i',L'l',L',',L'i',L')',L',',L'p',L'k',L'(',L'1',L'4',L':',L'c',L'o',L'm',L',',L'n',L'e',L't',L',',L'e',L'd',L'u',L',',L'o',L'r',L'g',L',',L'f',L'a',L'm',L',',L'b',L'i',L'z',L',',L'w',
+	L'e',L'b',L',',L'g',L'o',L'v',L',',L'g',L'o',L'b',L',',L'g',L'o',L'k',L',',L'g',L'o',L'n',L',',L'g',L'o',L'p',L',',L'g',L'o',L's',L',',L'i',L'n',L'f',L'o',L')',L',',L'p',L'l',L'(',L'1',L'7',L'1',L':',L'a',L'i',L'd',L',',L'a',L'g',L'r',L'o',L',',L'a',L't',L'm',L',',L'a',L'u',L't',L'o',L',',L'b',L'i',L'z',L',',L'c',L'o',L'm',L',',L'e',L'd',L'u',L',',L'g',L'm',L'i',L'n',L'a',L',',L'g',L's',L'm',L',',L'i',L'n',L'f',L'o',L',',L'm',L'a',L'i',L'l',L',',L'm',L'i',L'a',L's',L't',L'a',L',',L'm',L'e',L'd',
+	L'i',L'a',L',',L'm',L'i',L'l',L',',L'n',L'e',L't',L',',L'n',L'i',L'e',L'r',L'u',L'c',L'h',L'o',L'm',L'o',L's',L'c',L'i',L',',L'n',L'o',L'm',L',',L'o',L'r',L'g',L',',L'p',L'c',L',',L'p',L'o',L'w',L'i',L'a',L't',L',',L'p',L'r',L'i',L'v',L',',L'r',L'e',L'a',L'l',L'e',L's',L't',L'a',L't',L'e',L',',L'r',L'e',L'l',L',',L's',L'e',L'x',L',',L's',L'h',L'o',L'p',L',',L's',L'k',L'l',L'e',L'p',L',',L's',L'o',L's',L',',L's',L'z',L'k',L'o',L'l',L'a',L',',L't',L'a',L'r',L'g',L'i',L',',L't',L'm',L',',L't',L'o',
+	L'u',L'r',L'i',L's',L'm',L',',L't',L'r',L'a',L'v',L'e',L'l',L',',L't',L'u',L'r',L'y',L's',L't',L'y',L'k',L'a',L',',L'6',L'b',L'o',L'n',L'e',L',',L'a',L'r',L't',L',',L'm',L'b',L'o',L'n',L'e',L',',L'g',L'o',L'v',L'(',L'9',L':',L'u',L'w',L',',L'u',L'm',L',',L'u',L'g',L',',L'u',L'p',L'o',L'w',L',',L's',L't',L'a',L'r',L'o',L's',L't',L'w',L'o',L',',L's',L'o',L',',L's',L'r',L',',L'p',L'o',L',',L'p',L'a',L')',L',',L'n',L'g',L'o',L',',L'i',L'r',L'c',L',',L'u',L's',L'e',L'n',L'e',L't',L',',L'a',L'u',L'g',
+	L'u',L's',L't',L'o',L'w',L',',L'b',L'a',L'b',L'i',L'a',L'-',L'g',L'o',L'r',L'a',L',',L'b',L'e',L'd',L'z',L'i',L'n',L',',L'b',L'e',L's',L'k',L'i',L'd',L'y',L',',L'b',L'i',L'a',L'l',L'o',L'w',L'i',L'e',L'z',L'a',L',',L'b',L'i',L'a',L'l',L'y',L's',L't',L'o',L'k',L',',L'b',L'i',L'e',L'l',L'a',L'w',L'a',L',',L'b',L'i',L'e',L's',L'z',L'c',L'z',L'a',L'd',L'y',L',',L'b',L'o',L'l',L'e',L's',L'l',L'a',L'w',L'i',L'e',L'c',L',',L'b',L'y',L'd',L'g',L'o',L's',L'z',L'c',L'z',L',',L'b',L'y',L't',L'o',L'm',L',',
+	L'c',L'i',L'e',L's',L'z',L'y',L'n',L',',L'c',L'z',L'e',L'l',L'a',L'd',L'z',L',',L'c',L'z',L'e',L's',L't',L',',L'd',L'l',L'u',L'g',L'o',L'l',L'e',L'k',L'a',L',',L'e',L'l',L'b',L'l',L'a',L'g',L',',L'e',L'l',L'k',L',',L'g',L'l',L'o',L'g',L'o',L'w',L',',L'g',L'n',L'i',L'e',L'z',L'n',L'o',L',',L'g',L'o',L'r',L'l',L'i',L'c',L'e',L',',L'g',L'r',L'a',L'j',L'e',L'w',L'o',L',',L'i',L'l',L'a',L'w',L'a',L',',L'j',L'a',L'w',L'o',L'r',L'z',L'n',L'o',L',',L'j',L'e',L'l',L'e',L'n',L'i',L'a',L'-',L'g',L'o',L'r',
+	L'a',L',',L'j',L'g',L'o',L'r',L'a',L',',L'k',L'a',L'l',L'i',L's',L'z',L',',L'k',L'a',L'z',L'i',L'm',L'i',L'e',L'r',L'z',L'-',L'd',L'o',L'l',L'n',L'y',L',',L'k',L'a',L'r',L'p',L'a',L'c',L'z',L',',L'k',L'a',L'r',L't',L'u',L'z',L'y',L',',L'k',L'a',L's',L'z',L'u',L'b',L'y',L',',L'k',L'a',L't',L'o',L'w',L'i',L'c',L'e',L',',L'k',L'e',L'p',L'n',L'o',L',',L'k',L'e',L't',L'r',L'z',L'y',L'n',L',',L'k',L'l',L'o',L'd',L'z',L'k',L'o',L',',L'k',L'o',L'b',L'i',L'e',L'r',L'z',L'y',L'c',L'e',L',',L'k',L'o',L'l',
+	L'o',L'b',L'r',L'z',L'e',L'g',L',',L'k',L'o',L'n',L'i',L'n',L',',L'k',L'o',L'n',L's',L'k',L'o',L'w',L'o',L'l',L'a',L',',L'k',L'u',L't',L'n',L'o',L',',L'l',L'a',L'p',L'y',L',',L'l',L'e',L'b',L'o',L'r',L'k',L',',L'l',L'e',L'g',L'n',L'i',L'c',L'a',L',',L'l',L'e',L'z',L'a',L'j',L's',L'k',L',',L'l',L'i',L'm',L'a',L'n',L'o',L'w',L'a',L',',L'l',L'o',L'm',L'z',L'a',L',',L'l',L'o',L'w',L'i',L'c',L'z',L',',L'l',L'u',L'b',L'i',L'n',L',',L'l',L'u',L'k',L'o',L'w',L',',L'm',L'a',L'l',L'b',L'o',L'r',L'k',L',',
+	L'm',L'a',L'l',L'o',L'p',L'o',L'l',L's',L'k',L'a',L',',L'm',L'a',L'z',L'o',L'w',L's',L'z',L'e',L',',L'm',L'a',L'z',L'u',L'r',L'y',L',',L'm',L'i',L'e',L'l',L'e',L'c',L',',L'm',L'i',L'e',L'l',L'n',L'o',L',',L'm',L'r',L'a',L'g',L'o',L'w',L'o',L',',L'n',L'a',L'k',L'l',L'o',L',',L'n',L'o',L'w',L'a',L'r',L'u',L'd',L'a',L',',L'n',L'y',L's',L'a',L',',L'o',L'l',L'a',L'w',L'a',L',',L'o',L'l',L'e',L'c',L'k',L'o',L',',L'o',L'l',L'k',L'u',L's',L'z',L',',L'o',L'l',L's',L'z',L't',L'y',L'n',L',',L'o',L'p',L'o',
+	L'c',L'z',L'n',L'o',L',',L'o',L'p',L'o',L'l',L'e',L',',L'o',L's',L't',L'r',L'o',L'd',L'a',L',',L'o',L's',L't',L'r',L'o',L'l',L'e',L'k',L'a',L',',L'o',L's',L't',L'r',L'o',L'w',L'i',L'e',L'c',L',',L'o',L's',L't',L'r',L'o',L'w',L'w',L'l',L'k',L'p',L',',L'p',L'i',L'l',L'a',L',',L'p',L'i',L's',L'z',L',',L'p',L'o',L'd',L'h',L'a',L'l',L'e',L',',L'p',L'o',L'd',L'l',L'a',L's',L'i',L'e',L',',L'p',L'o',L'l',L'k',L'o',L'w',L'i',L'c',L'e',L',',L'p',L'o',L'm',L'o',L'r',L'z',L'e',L',',L'p',L'o',L'm',L'o',L'r',
+	L's',L'k',L'i',L'e',L',',L'p',L'r',L'o',L'c',L'h',L'o',L'w',L'i',L'c',L'e',L',',L'p',L'r',L'u',L's',L'z',L'k',L'o',L'w',L',',L'p',L'r',L'z',L'e',L'w',L'o',L'r',L's',L'k',L',',L'p',L'u',L'l',L'a',L'w',L'y',L',',L'r',L'a',L'd',L'o',L'm',L',',L'r',L'a',L'w',L'a',L'-',L'm',L'a',L'z',L',',L'r',L'y',L'b',L'n',L'i',L'k',L',',L'r',L'z',L'e',L's',L'z',L'o',L'w',L',',L's',L'a',L'n',L'o',L'k',L',',L's',L'e',L'j',L'n',L'y',L',',L's',L'i',L'e',L'd',L'l',L'c',L'e',L',',L's',L'l',L'a',L's',L'k',L',',L's',L'l',
+	L'u',L'p',L's',L'k',L',',L's',L'o',L's',L'n',L'o',L'w',L'i',L'e',L'c',L',',L's',L't',L'a',L'l',L'o',L'w',L'a',L'-',L'w',L'o',L'l',L'a',L',',L's',L'k',L'o',L'c',L'z',L'o',L'w',L',',L's',L't',L'a',L'r',L'a',L'c',L'h',L'o',L'w',L'i',L'c',L'e',L',',L's',L't',L'a',L'r',L'g',L'a',L'r',L'd',L',',L's',L'u',L'w',L'a',L'l',L'k',L'i',L',',L's',L'w',L'i',L'd',L'n',L'i',L'c',L'a',L',',L's',L'w',L'i',L'e',L'b',L'o',L'd',L'z',L'i',L'n',L',',L's',L'w',L'i',L'n',L'o',L'u',L'j',L's',L'c',L'i',L'e',L',',L's',L'z',
+	L'c',L'z',L'e',L'c',L'i',L'n',L',',L's',L'z',L'c',L'z',L'y',L't',L'n',L'o',L',',L't',L'a',L'r',L'n',L'o',L'b',L'r',L'z',L'e',L'g',L',',L't',L'g',L'o',L'r',L'y',L',',L't',L'u',L'r',L'e',L'k',L',',L't',L'y',L'c',L'h',L'y',L',',L'u',L's',L't',L'k',L'a',L',',L'w',L'a',L'l',L'b',L'r',L'z',L'y',L'c',L'h',L',',L'w',L'a',L'r',L'm',L'i',L'a',L',',L'w',L'a',L'r',L's',L'z',L'a',L'w',L'a',L',',L'w',L'a',L'w',L',',L'w',L'e',L'g',L'r',L'o',L'w',L',',L'w',L'i',L'e',L'l',L'u',L'n',L',',L'w',L'l',L'o',L'c',L'l',
+	L',',L'w',L'l',L'o',L'c',L'l',L'a',L'w',L'e',L'k',L',',L'w',L'o',L'd',L'z',L'i',L's',L'l',L'a',L'w',L',',L'w',L'o',L'l',L'o',L'm',L'i',L'n',L',',L'w',L'r',L'o',L'c',L'l',L'a',L'w',L',',L'z',L'a',L'c',L'h',L'p',L'o',L'm',L'o',L'r',L',',L'z',L'a',L'g',L'a',L'n',L',',L'z',L'a',L'r',L'o',L'w',L',',L'z',L'g',L'o',L'r',L'a',L',',L'z',L'g',L'o',L'r',L'z',L'e',L'l',L'e',L'c',L',',L'g',L'd',L'a',L',',L'g',L'd',L'a',L'n',L's',L'k',L',',L'g',L'd',L'y',L'n',L'i',L'a',L',',L'm',L'e',L'd',L',',L's',L'o',L'p',
+	L'o',L't',L',',L'g',L'l',L'i',L'w',L'i',L'c',L'e',L',',L'k',L'r',L'a',L'k',L'o',L'w',L',',L'p',L'o',L'z',L'n',L'a',L'n',L',',L'w',L'r',L'o',L'c',L',',L'z',L'a',L'k',L'o',L'p',L'a',L'n',L'e',L',',L'c',L'o',L')',L',',L'p',L'm',L',',L'p',L'n',L'(',L'5',L':',L'g',L'o',L'v',L',',L'c',L'o',L',',L'o',L'r',L'g',L',',L'e',L'd',L'u',L',',L'n',L'e',L't',L')',L',',L'p',L'r',L'(',L'1',L'3',L':',L'c',L'o',L'm',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L',',L'g',L'o',L'v',L',',L'e',L'd',L'u',L',',L'i',L's',L'l',
+	L'a',L',',L'p',L'r',L'o',L',',L'b',L'i',L'z',L',',L'i',L'n',L'f',L'o',L',',L'n',L'a',L'm',L'e',L',',L'e',L's',L't',L',',L'p',L'r',L'o',L'f',L',',L'a',L'c',L')',L',',L'p',L'r',L'o',L'(',L'7',L':',L'a',L'c',L'a',L',',L'b',L'a',L'r',L',',L'c',L'p',L'a',L',',L'j',L'u',L'r',L',',L'l',L'a',L'w',L',',L'm',L'e',L'd',L',',L'e',L'n',L'g',L')',L',',L'p',L's',L'(',L'7',L':',L'e',L'd',L'u',L',',L'g',L'o',L'v',L',',L's',L'e',L'c',L',',L'p',L'l',L'o',L',',L'c',L'o',L'm',L',',L'o',L'r',L'g',L',',L'n',L'e',L't',
+	L')',L',',L'p',L't',L'(',L'8',L':',L'n',L'e',L't',L',',L'g',L'o',L'v',L',',L'o',L'r',L'g',L',',L'e',L'd',L'u',L',',L'i',L'n',L't',L',',L'p',L'u',L'b',L'l',L',',L'c',L'o',L'm',L',',L'n',L'o',L'm',L'e',L')',L',',L'p',L'w',L'(',L'6',L':',L'c',L'o',L',',L'n',L'e',L',',L'o',L'r',L',',L'e',L'd',L',',L'g',L'o',L',',L'b',L'e',L'l',L'a',L'u',L')',L',',L'p',L'y',L'(',L'1',L':',L'*',L')',L',',L'q',L'a',L'(',L'8',L':',L'c',L'o',L'm',L',',L'e',L'd',L'u',L',',L'g',L'o',L'v',L',',L'm',L'i',L'l',L',',L'n',L'a',
+	L'm',L'e',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L',',L's',L'c',L'h',L')',L',',L'r',L'e',L'(',L'3',L':',L'c',L'o',L'm',L',',L'a',L's',L's',L'o',L',',L'n',L'o',L'm',L')',L',',L'r',L'o',L'(',L'1',L'1',L':',L'c',L'o',L'm',L',',L'o',L'r',L'g',L',',L't',L'm',L',',L'n',L't',L',',L'n',L'o',L'm',L',',L'i',L'n',L'f',L'o',L',',L'r',L'e',L'c',L',',L'a',L'r',L't',L's',L',',L'f',L'i',L'r',L'm',L',',L's',L't',L'o',L'r',L'e',L',',L'w',L'w',L'w',L')',L',',L'r',L's',L'(',L'6',L':',L'c',L'o',L',',L'o',L'r',L'g',
+	L',',L'e',L'd',L'u',L',',L'a',L'c',L',',L'g',L'o',L'v',L',',L'i',L'n',L')',L',',L'r',L'u',L'(',L'1',L'3',L'3',L':',L'a',L'c',L',',L'c',L'o',L'm',L',',L'e',L'd',L'u',L',',L'i',L'n',L't',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L',',L'p',L'p',L',',L'a',L'd',L'y',L'g',L'e',L'y',L'a',L',',L'a',L'l',L't',L'a',L'i',L',',L'a',L'm',L'u',L'r',L',',L'a',L'r',L'k',L'h',L'a',L'n',L'g',L'e',L'l',L's',L'k',L',',L'a',L's',L't',L'r',L'a',L'k',L'h',L'a',L'n',L',',L'b',L'a',L's',L'h',L'k',L'i',L'r',L'i',L'a',L',',
+	L'b',L'e',L'l',L'g',L'o',L'r',L'o',L'd',L',',L'b',L'i',L'r',L',',L'b',L'r',L'y',L'a',L'n',L's',L'k',L',',L'b',L'u',L'r',L'y',L'a',L't',L'i',L'a',L',',L'c',L'b',L'g',L',',L'c',L'h',L'e',L'l',L',',L'c',L'h',L'e',L'l',L'y',L'a',L'b',L'i',L'n',L's',L'k',L',',L'c',L'h',L'i',L't',L'a',L',',L'c',L'h',L'u',L'k',L'o',L't',L'k',L'a',L',',L'c',L'h',L'u',L'v',L'a',L's',L'h',L'i',L'a',L',',L'd',L'a',L'g',L'e',L's',L't',L'a',L'n',L',',L'd',L'u',L'd',L'i',L'n',L'k',L'a',L',',L'e',L'-',L'b',L'u',L'r',L'g',L',',
+	L'g',L'r',L'o',L'z',L'n',L'y',L',',L'i',L'r',L'k',L'u',L't',L's',L'k',L',',L'i',L'v',L'a',L'n',L'o',L'v',L'o',L',',L'i',L'z',L'h',L'e',L'v',L's',L'k',L',',L'j',L'a',L'r',L',',L'j',L'o',L's',L'h',L'k',L'a',L'r',L'-',L'o',L'l',L'a',L',',L'k',L'a',L'l',L'm',L'y',L'k',L'i',L'a',L',',L'k',L'a',L'l',L'u',L'g',L'a',L',',L'k',L'a',L'm',L'c',L'h',L'a',L't',L'k',L'a',L',',L'k',L'a',L'r',L'e',L'l',L'i',L'a',L',',L'k',L'a',L'z',L'a',L'n',L',',L'k',L'c',L'h',L'r',L',',L'k',L'e',L'm',L'e',L'r',L'o',L'v',L'o',
+	L',',L'k',L'h',L'a',L'b',L'a',L'r',L'o',L'v',L's',L'k',L',',L'k',L'h',L'a',L'k',L'a',L's',L's',L'i',L'a',L',',L'k',L'h',L'v',L',',L'k',L'i',L'r',L'o',L'v',L',',L'k',L'o',L'e',L'n',L'i',L'g',L',',L'k',L'o',L'm',L'i',L',',L'k',L'o',L's',L't',L'r',L'o',L'm',L'a',L',',L'k',L'r',L'a',L's',L'n',L'o',L'y',L'a',L'r',L's',L'k',L',',L'k',L'u',L'b',L'a',L'n',L',',L'k',L'u',L'r',L'g',L'a',L'n',L',',L'k',L'u',L'r',L's',L'k',L',',L'l',L'i',L'p',L'e',L't',L's',L'k',L',',L'm',L'a',L'g',L'a',L'd',L'a',L'n',L',',
+	L'm',L'a',L'r',L'i',L',',L'm',L'a',L'r',L'i',L'-',L'e',L'l',L',',L'm',L'a',L'r',L'i',L'n',L'e',L',',L'm',L'o',L'r',L'd',L'o',L'v',L'i',L'a',L',',L'm',L'o',L's',L'r',L'e',L'g',L',',L'm',L's',L'k',L',',L'm',L'u',L'r',L'm',L'a',L'n',L's',L'k',L',',L'n',L'a',L'l',L'c',L'h',L'i',L'k',L',',L'n',L'n',L'o',L'v',L',',L'n',L'o',L'v',L',',L'n',L'o',L'v',L'o',L's',L'i',L'b',L'i',L'r',L's',L'k',L',',L'n',L's',L'k',L',',L'o',L'm',L's',L'k',L',',L'o',L'r',L'e',L'n',L'b',L'u',L'r',L'g',L',',L'o',L'r',L'y',L'o',
+	L'l',L',',L'p',L'a',L'l',L'a',L'n',L'a',L',',L'p',L'e',L'n',L'z',L'a',L',',L'p',L'e',L'r',L'm',L',',L'p',L's',L'k',L'o',L'v',L',',L'p',L't',L'z',L',',L'r',L'n',L'd',L',',L'r',L'y',L'a',L'z',L'a',L'n',L',',L's',L'a',L'k',L'h',L'a',L'l',L'i',L'n',L',',L's',L'a',L'm',L'a',L'r',L'a',L',',L's',L'a',L'r',L'a',L't',L'o',L'v',L',',L's',L'i',L'm',L'b',L'i',L'r',L's',L'k',L',',L's',L'm',L'o',L'l',L'e',L'n',L's',L'k',L',',L's',L'p',L'b',L',',L's',L't',L'a',L'v',L'r',L'o',L'p',L'o',L'l',L',',L's',L't',L'v',
+	L',',L's',L'u',L'r',L'g',L'u',L't',L',',L't',L'a',L'm',L'b',L'o',L'v',L',',L't',L'a',L't',L'a',L'r',L's',L't',L'a',L'n',L',',L't',L'o',L'm',L',',L't',L'o',L'm',L's',L'k',L',',L't',L's',L'a',L'r',L'i',L't',L's',L'y',L'n',L',',L't',L's',L'k',L',',L't',L'u',L'l',L'a',L',',L't',L'u',L'v',L'a',L',',L't',L'v',L'e',L'r',L',',L't',L'y',L'u',L'm',L'e',L'n',L',',L'u',L'd',L'm',L',',L'u',L'd',L'm',L'u',L'r',L't',L'i',L'a',L',',L'u',L'l',L'a',L'n',L'-',L'u',L'd',L'e',L',',L'v',L'l',L'a',L'd',L'i',L'k',L'a',
+	L'v',L'k',L'a',L'z',L',',L'v',L'l',L'a',L'd',L'i',L'm',L'i',L'r',L',',L'v',L'l',L'a',L'd',L'i',L'v',L'o',L's',L't',L'o',L'k',L',',L'v',L'o',L'l',L'g',L'o',L'g',L'r',L'a',L'd',L',',L'v',L'o',L'l',L'o',L'g',L'd',L'a',L',',L'v',L'o',L'r',L'o',L'n',L'e',L'z',L'h',L',',L'v',L'r',L'n',L',',L'v',L'y',L'a',L't',L'k',L'a',L',',L'y',L'a',L'k',L'u',L't',L'i',L'a',L',',L'y',L'a',L'm',L'a',L'l',L',',L'y',L'a',L'r',L'o',L's',L'l',L'a',L'v',L'l',L',',L'y',L'e',L'k',L'a',L't',L'e',L'r',L'i',L'n',L'b',L'u',L'r',
+	L'g',L',',L'y',L'u',L'z',L'h',L'n',L'o',L'-',L's',L'a',L'k',L'h',L'a',L'l',L'i',L'n',L's',L'k',L',',L'a',L'm',L'u',L'r',L's',L'k',L',',L'b',L'a',L'i',L'k',L'a',L'l',L',',L'c',L'm',L'w',L',',L'f',L'a',L'r',L'e',L'a',L's',L't',L',',L'j',L'a',L'm',L'a',L'l',L',',L'k',L'm',L's',L',',L'k',L'-',L'u',L'r',L'a',L'l',L's',L'k',L',',L'k',L'u',L's',L't',L'a',L'n',L'a',L'i',L',',L'k',L'u',L'z',L'b',L'a',L's',L's',L',',L'm',L'a',L'g',L'n',L'i',L't',L'k',L'a',L',',L'm',L'y',L't',L'i',L's',L',',L'n',L'a',L'k',
+	L'h',L'o',L'd',L'k',L'a',L',',L'n',L'k',L'z',L',',L'n',L'o',L'r',L'i',L'l',L's',L'k',L',',L'o',L's',L'k',L'o',L'l',L',',L'p',L'y',L'a',L't',L'i',L'g',L'o',L'r',L's',L'k',L',',L'r',L'u',L'b',L't',L's',L'o',L'v',L's',L'k',L',',L's',L'n',L'z',L',',L's',L'y',L'z',L'r',L'a',L'n',L',',L'v',L'd',L'o',L'n',L's',L'k',L',',L'z',L'g',L'r',L'a',L'd',L',',L'g',L'o',L'v',L',',L'm',L'i',L'l',L',',L't',L'e',L's',L't',L')',L',',L'r',L'w',L'(',L'9',L':',L'g',L'o',L'v',L',',L'n',L'e',L't',L',',L'e',L'd',L'u',L',',
+	L'a',L'c',L',',L'c',L'o',L'm',L',',L'c',L'o',L',',L'i',L'n',L't',L',',L'm',L'i',L'l',L',',L'g',L'o',L'u',L'v',L')',L',',L's',L'a',L'(',L'8',L':',L'c',L'o',L'm',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L',',L'g',L'o',L'v',L',',L'm',L'e',L'd',L',',L'p',L'u',L'b',L',',L'e',L'd',L'u',L',',L's',L'c',L'h',L')',L',',L's',L'b',L'(',L'5',L':',L'c',L'o',L'm',L',',L'e',L'd',L'u',L',',L'g',L'o',L'v',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L')',L',',L's',L'c',L'(',L'5',L':',L'c',L'o',L'm',L',',L'g',L'o',L'v',
+	L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L',',L'e',L'd',L'u',L')',L',',L's',L'd',L'(',L'8',L':',L'c',L'o',L'm',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L',',L'e',L'd',L'u',L',',L'm',L'e',L'd',L',',L't',L'v',L',',L'g',L'o',L'v',L',',L'i',L'n',L'f',L'o',L')',L',',L's',L'e',L'(',L'4',L'0',L':',L'a',L',',L'a',L'c',L',',L'b',L',',L'b',L'd',L',',L'b',L'r',L'a',L'n',L'd',L',',L'c',L',',L'd',L',',L'e',L',',L'f',L',',L'f',L'h',L',',L'f',L'h',L's',L'k',L',',L'f',L'h',L'v',L',',L'g',L',',L'h',L',',L'i',L',',
+	L'k',L',',L'k',L'o',L'm',L'f',L'o',L'r',L'b',L',',L'k',L'o',L'm',L'm',L'u',L'n',L'a',L'l',L'f',L'o',L'r',L'b',L'u',L'n',L'd',L',',L'k',L'o',L'm',L'v',L'u',L'x',L',',L'l',L',',L'l',L'a',L'n',L'b',L'i',L'b',L',',L'm',L',',L'n',L',',L'n',L'a',L't',L'u',L'r',L'b',L'r',L'u',L'k',L's',L'g',L'y',L'm',L'n',L',',L'o',L',',L'o',L'r',L'g',L',',L'p',L',',L'p',L'a',L'r',L't',L'i',L',',L'p',L'p',L',',L'p',L'r',L'e',L's',L's',L',',L'r',L',',L's',L',',L's',L's',L'h',L'n',L',',L't',L',',L't',L'm',L',',L'u',L',',
+	L'w',L',',L'x',L',',L'y',L',',L'z',L')',L',',L's',L'g',L'(',L'6',L':',L'c',L'o',L'm',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L',',L'g',L'o',L'v',L',',L'e',L'd',L'u',L',',L'p',L'e',L'r',L')',L',',L's',L'h',L'(',L'5',L':',L'c',L'o',L'm',L',',L'n',L'e',L't',L',',L'g',L'o',L'v',L',',L'o',L'r',L'g',L',',L'm',L'i',L'l',L')',L',',L's',L'i',L',',L's',L'k',L',',L's',L'l',L'(',L'5',L':',L'c',L'o',L'm',L',',L'n',L'e',L't',L',',L'e',L'd',L'u',L',',L'g',L'o',L'v',L',',L'o',L'r',L'g',L')',L',',L's',L'm',L',',
+	L's',L'n',L'(',L'7',L':',L'a',L'r',L't',L',',L'c',L'o',L'm',L',',L'e',L'd',L'u',L',',L'g',L'o',L'u',L'v',L',',L'o',L'r',L'g',L',',L'p',L'e',L'r',L's',L'o',L',',L'u',L'n',L'i',L'v',L')',L',',L's',L'o',L'(',L'3',L':',L'c',L'o',L'm',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L')',L',',L's',L'r',L',',L's',L't',L'(',L'1',L'2',L':',L'c',L'o',L',',L'c',L'o',L'm',L',',L'c',L'o',L'n',L's',L'u',L'l',L'a',L'd',L'o',L',',L'e',L'd',L'u',L',',L'e',L'm',L'b',L'a',L'i',L'x',L'a',L'd',L'a',L',',L'g',L'o',L'v',L',',
+	L'm',L'i',L'l',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L',',L'p',L'r',L'i',L'n',L'c',L'i',L'p',L'e',L',',L's',L'a',L'o',L't',L'o',L'm',L'e',L',',L's',L't',L'o',L'r',L'e',L')',L',',L's',L'u',L',',L's',L'v',L'(',L'1',L':',L'*',L')',L',',L's',L'x',L'(',L'1',L':',L'g',L'o',L'v',L')',L',',L's',L'y',L'(',L'6',L':',L'e',L'd',L'u',L',',L'g',L'o',L'v',L',',L'n',L'e',L't',L',',L'm',L'i',L'l',L',',L'c',L'o',L'm',L',',L'o',L'r',L'g',L')',L',',L's',L'z',L'(',L'3',L':',L'c',L'o',L',',L'a',L'c',L',',L'o',L'r',
+	L'g',L')',L',',L't',L'c',L',',L't',L'd',L',',L't',L'e',L'l',L',',L't',L'f',L',',L't',L'g',L',',L't',L'h',L'(',L'7',L':',L'a',L'c',L',',L'c',L'o',L',',L'g',L'o',L',',L'i',L'n',L',',L'm',L'i',L',',L'n',L'e',L't',L',',L'o',L'r',L')',L',',L't',L'j',L'(',L'1',L'5',L':',L'a',L'c',L',',L'b',L'i',L'z',L',',L'c',L'o',L',',L'c',L'o',L'm',L',',L'e',L'd',L'u',L',',L'g',L'o',L',',L'g',L'o',L'v',L',',L'i',L'n',L't',L',',L'm',L'i',L'l',L',',L'n',L'a',L'm',L'e',L',',L'n',L'e',L't',L',',L'n',L'i',L'c',L',',L'o',
+	L'r',L'g',L',',L't',L'e',L's',L't',L',',L'w',L'e',L'b',L')',L',',L't',L'k',L',',L't',L'l',L'(',L'1',L':',L'g',L'o',L'v',L')',L',',L't',L'm',L'(',L'8',L':',L'c',L'o',L'm',L',',L'c',L'o',L',',L'o',L'r',L'g',L',',L'n',L'e',L't',L',',L'n',L'o',L'm',L',',L'g',L'o',L'v',L',',L'm',L'i',L'l',L',',L'e',L'd',L'u',L')',L',',L't',L'n',L'(',L'2',L'0',L':',L'c',L'o',L'm',L',',L'e',L'n',L's',L',',L'f',L'i',L'n',L',',L'g',L'o',L'v',L',',L'i',L'n',L'd',L',',L'i',L'n',L't',L'l',L',',L'n',L'a',L't',L',',L'n',L'e',
+	L't',L',',L'o',L'r',L'g',L',',L'i',L'n',L'f',L'o',L',',L'p',L'e',L'r',L's',L'o',L',',L't',L'o',L'u',L'r',L'i',L's',L'm',L',',L'e',L'd',L'u',L'n',L'e',L't',L',',L'r',L'n',L'r',L't',L',',L'r',L'n',L's',L',',L'r',L'n',L'u',L',',L'm',L'i',L'n',L'c',L'o',L'm',L',',L'a',L'g',L'r',L'i',L'n',L'e',L't',L',',L'd',L'e',L'f',L'e',L'n',L's',L'e',L',',L't',L'u',L'r',L'e',L'n',L')',L',',L't',L'o',L'(',L'6',L':',L'c',L'o',L'm',L',',L'g',L'o',L'v',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L',',L'e',L'd',L'u',L',',
+	L'm',L'i',L'l',L')',L',',L't',L'r',L'(',L'3',L':',L'*',L',',L'n',L'i',L'c',L'(',L'1',L':',L'!',L')',L',',L'n',L'c',L'(',L'1',L':',L'g',L'o',L'v',L')',L')',L',',L't',L'r',L'a',L'v',L'e',L'l',L',',L't',L't',L'(',L'1',L'7',L':',L'c',L'o',L',',L'c',L'o',L'm',L',',L'o',L'r',L'g',L',',L'n',L'e',L't',L',',L'b',L'i',L'z',L',',L'i',L'n',L'f',L'o',L',',L'p',L'r',L'o',L',',L'i',L'n',L't',L',',L'c',L'o',L'o',L'p',L',',L'j',L'o',L'b',L's',L',',L'm',L'o',L'b',L'i',L',',L't',L'r',L'a',L'v',L'e',L'l',L',',L'm',
+	L'u',L's',L'e',L'u',L'm',L',',L'a',L'e',L'r',L'o',L',',L'n',L'a',L'm',L'e',L',',L'g',L'o',L'v',L',',L'e',L'd',L'u',L')',L',',L't',L'v',L'(',L'4',L':',L'd',L'y',L'n',L'd',L'n',L's',L',',L'b',L'e',L't',L't',L'e',L'r',L'-',L't',L'h',L'a',L'n',L',',L'o',L'n',L'-',L't',L'h',L'e',L'-',L'w',L'e',L'b',L',',L'w',L'o',L'r',L's',L'e',L'-',L't',L'h',L'a',L'n',L')',L',',L't',L'w',L'(',L'1',L'3',L':',L'e',L'd',L'u',L',',L'g',L'o',L'v',L',',L'm',L'i',L'l',L',',L'c',L'o',L'm',L',',L'n',L'e',L't',L',',L'o',L'r',
+	L'g',L',',L'i',L'd',L'v',L',',L'g',L'a',L'm',L'e',L',',L'e',L'b',L'i',L'z',L',',L'c',L'l',L'u',L'b',L',',L'網',L'路',L',',L'組',L'織',L',',L'商',L'業',L')',L',',L't',L'z',L'(',L'7',L':',L'a',L'c',L',',L'c',L'o',L',',L'g',L'o',L',',L'm',L'i',L'l',L',',L'n',L'e',L',',L'o',L'r',L',',L's',L'c',L')',L',',L'u',L'a',L'(',L'7',L'8',L':',L'c',L'o',L'm',L',',L'e',L'd',L'u',L',',L'g',L'o',L'v',L',',L'i',L'n',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L',',L'c',L'h',L'e',L'r',L'k',L'a',L's',L's',L'y',L',',L'c',L'h',
+	L'e',L'r',L'k',L'a',L's',L'y',L',',L'c',L'h',L'e',L'r',L'n',L'i',L'g',L'o',L'v',L',',L'c',L'h',L'e',L'r',L'n',L'i',L'h',L'i',L'v',L',',L'c',L'h',L'e',L'r',L'n',L'i',L'v',L't',L's',L'i',L',',L'c',L'h',L'e',L'r',L'n',L'o',L'v',L't',L's',L'y',L',',L'c',L'k',L',',L'c',L'n',L',',L'c',L'r',L',',L'c',L'r',L'i',L'm',L'e',L'a',L',',L'c',L'v',L',',L'd',L'n',L',',L'd',L'n',L'e',L'p',L'r',L'o',L'p',L'e',L't',L'r',L'o',L'v',L's',L'k',L',',L'd',L'n',L'i',L'p',L'r',L'o',L'p',L'e',L't',L'r',L'o',L'v',L's',L'k',
+	L',',L'd',L'o',L'm',L'i',L'n',L'i',L'c',L',',L'd',L'o',L'n',L'e',L't',L's',L'k',L',',L'd',L'p',L',',L'i',L'f',L',',L'i',L'v',L'a',L'n',L'o',L'-',L'f',L'r',L'a',L'n',L'k',L'i',L'v',L's',L'k',L',',L'k',L'h',L',',L'k',L'h',L'a',L'r',L'k',L'i',L'v',L',',L'k',L'h',L'a',L'r',L'k',L'o',L'v',L',',L'k',L'h',L'e',L'r',L's',L'o',L'n',L',',L'k',L'h',L'm',L'e',L'l',L'n',L'i',L't',L's',L'k',L'i',L'y',L',',L'k',L'h',L'm',L'e',L'l',L'n',L'y',L't',L's',L'k',L'y',L'i',L',',L'k',L'i',L'e',L'v',L',',L'k',L'i',L'r',
+	L'o',L'v',L'o',L'g',L'r',L'a',L'd',L',',L'k',L'm',L',',L'k',L'r',L',',L'k',L'r',L'y',L'm',L',',L'k',L's',L',',L'k',L'v',L',',L'k',L'y',L'i',L'v',L',',L'l',L'g',L',',L'l',L't',L',',L'l',L'u',L'g',L'a',L'n',L's',L'k',L',',L'l',L'u',L't',L's',L'k',L',',L'l',L'v',L',',L'l',L'v',L'i',L'v',L',',L'm',L'k',L',',L'm',L'y',L'k',L'o',L'l',L'a',L'i',L'v',L',',L'n',L'i',L'k',L'o',L'l',L'a',L'e',L'v',L',',L'o',L'd',L',',L'o',L'd',L'e',L's',L'a',L',',L'o',L'd',L'e',L's',L's',L'a',L',',L'p',L'l',L',',L'p',L'o',
+	L'l',L't',L'a',L'v',L'a',L',',L'r',L'i',L'v',L'n',L'e',L',',L'r',L'o',L'v',L'n',L'o',L',',L'r',L'v',L',',L's',L'b',L',',L's',L'e',L'b',L'a',L's',L't',L'o',L'p',L'o',L'l',L',',L's',L'e',L'v',L'a',L's',L't',L'o',L'p',L'o',L'l',L',',L's',L'm',L',',L's',L'u',L'm',L'y',L',',L't',L'e',L',',L't',L'e',L'r',L'n',L'o',L'p',L'i',L'l',L',',L'u',L'z',L',',L'u',L'z',L'h',L'g',L'o',L'r',L'o',L'd',L',',L'v',L'i',L'n',L'n',L'i',L'c',L'a',L',',L'v',L'i',L'n',L'n',L'y',L't',L's',L'i',L'a',L',',L'v',L'n',L',',L'v',
+	L'o',L'l',L'y',L'n',L',',L'y',L'a',L'l',L't',L'a',L',',L'z',L'a',L'p',L'o',L'r',L'i',L'z',L'h',L'z',L'h',L'e',L',',L'z',L'a',L'p',L'o',L'r',L'i',L'z',L'h',L'z',L'h',L'i',L'a',L',',L'z',L'h',L'i',L't',L'o',L'm',L'i',L'r',L',',L'z',L'h',L'y',L't',L'o',L'm',L'y',L'r',L',',L'z',L'p',L',',L'z',L't',L',',L'c',L'o',L',',L'p',L'p',L')',L',',L'u',L'g',L'(',L'8',L':',L'c',L'o',L',',L'o',L'r',L',',L'a',L'c',L',',L's',L'c',L',',L'g',L'o',L',',L'n',L'e',L',',L'c',L'o',L'm',L',',L'o',L'r',L'g',L')',L',',L'u',
+	L'k',L'(',L'1',L'4',L':',L'*',L',',L's',L'c',L'h',L'(',L'1',L':',L'*',L')',L',',L'b',L'l',L'(',L'1',L':',L'!',L')',L',',L'b',L'r',L'i',L't',L'i',L's',L'h',L'-',L'l',L'i',L'b',L'r',L'a',L'r',L'y',L'(',L'1',L':',L'!',L')',L',',L'i',L'c',L'n',L'e',L't',L'(',L'1',L':',L'!',L')',L',',L'j',L'e',L't',L'(',L'1',L':',L'!',L')',L',',L'm',L'o',L'd',L'(',L'1',L':',L'!',L')',L',',L'n',L'e',L'l',L'(',L'1',L':',L'!',L')',L',',L'n',L'h',L's',L'(',L'1',L':',L'!',L')',L',',L'n',L'i',L'c',L'(',L'1',L':',L'!',L')',
+	L',',L'n',L'l',L's',L'(',L'1',L':',L'!',L')',L',',L'n',L'a',L't',L'i',L'o',L'n',L'a',L'l',L'-',L'l',L'i',L'b',L'r',L'a',L'r',L'y',L'-',L's',L'c',L'o',L't',L'l',L'a',L'n',L'd',L'(',L'1',L':',L'!',L')',L',',L'p',L'a',L'r',L'l',L'i',L'a',L'm',L'e',L'n',L't',L'(',L'1',L':',L'!',L')',L',',L'p',L'o',L'l',L'i',L'c',L'e',L'(',L'1',L':',L'!',L')',L')',L',',L'u',L's',L'(',L'6',L'3',L':',L'd',L'n',L'i',L',',L'f',L'e',L'd',L',',L'i',L's',L'a',L',',L'k',L'i',L'd',L's',L',',L'n',L's',L'n',L',',L'a',L'k',L'(',
+	L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'a',L'l',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'a',L'r',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'a',L's',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'a',L'z',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'c',L'a',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'c',
+	L'o',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'c',L't',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'd',L'c',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'd',L'e',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'f',L'l',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'g',L'a',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',
+	L',',L'g',L'u',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'h',L'i',L'(',L'2',L':',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'i',L'a',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'i',L'd',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'i',L'l',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'i',L'n',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'k',
+	L's',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'k',L'y',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'l',L'a',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'm',L'a',L'(',L'3',L':',L'k',L'1',L'2',L'(',L'3',L':',L'p',L'v',L't',L',',L'c',L'h',L't',L'r',L',',L'p',L'a',L'r',L'o',L'c',L'h',L')',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'm',L'd',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',
+	L'b',L')',L',',L'm',L'e',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'm',L'i',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'm',L'n',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'm',L'o',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'm',L's',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'm',L't',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',
+	L'l',L'i',L'b',L')',L',',L'n',L'c',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'n',L'd',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'n',L'e',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'n',L'h',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'n',L'j',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'n',L'm',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',
+	L'c',L',',L'l',L'i',L'b',L')',L',',L'n',L'v',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'n',L'y',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'o',L'h',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'o',L'k',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'o',L'r',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'p',L'a',L'(',L'3',L':',L'k',L'1',L'2',
+	L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'p',L'r',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'r',L'i',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L's',L'c',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L's',L'd',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L't',L'n',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L't',L'x',L'(',L'3',L':',L'k',
+	L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'u',L't',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'v',L'i',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'v',L't',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'v',L'a',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'w',L'a',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'w',L'i',L'(',L'3',
+	L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'w',L'v',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'w',L'y',L'(',L'3',L':',L'k',L'1',L'2',L',',L'c',L'c',L',',L'l',L'i',L'b',L')',L',',L'i',L's',L'-',L'b',L'y',L',',L'l',L'a',L'n',L'd',L'-',L'4',L'-',L's',L'a',L'l',L'e',L',',L's',L't',L'u',L'f',L'f',L'-',L'4',L'-',L's',L'a',L'l',L'e',L')',L',',L'u',L'y',L'(',L'6',L':',L'c',L'o',L'm',L',',L'e',L'd',L'u',L',',L'g',L'u',L'b',L',',L'm',L'i',L'l',L',',
+	L'n',L'e',L't',L',',L'o',L'r',L'g',L')',L',',L'u',L'z',L'(',L'4',L':',L'c',L'o',L',',L'c',L'o',L'm',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L')',L',',L'v',L'a',L',',L'v',L'c',L'(',L'6',L':',L'c',L'o',L'm',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L',',L'g',L'o',L'v',L',',L'm',L'i',L'l',L',',L'e',L'd',L'u',L')',L',',L'v',L'e',L'(',L'1',L':',L'*',L')',L',',L'v',L'g',L',',L'v',L'i',L'(',L'5',L':',L'c',L'o',L',',L'c',L'o',L'm',L',',L'k',L'1',L'2',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L')',L',',L'v',
+	L'n',L'(',L'1',L'2',L':',L'c',L'o',L'm',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L',',L'e',L'd',L'u',L',',L'g',L'o',L'v',L',',L'i',L'n',L't',L',',L'a',L'c',L',',L'b',L'i',L'z',L',',L'i',L'n',L'f',L'o',L',',L'n',L'a',L'm',L'e',L',',L'p',L'r',L'o',L',',L'h',L'e',L'a',L'l',L't',L'h',L')',L',',L'v',L'u',L',',L'w',L'f',L',',L'w',L's',L'(',L'7',L':',L'c',L'o',L'm',L',',L'n',L'e',L't',L',',L'o',L'r',L'g',L',',L'g',L'o',L'v',L',',L'e',L'd',L'u',L',',L'd',L'y',L'n',L'd',L'n',L's',L',',L'm',L'y',L'p',L'e',
+	L't',L's',L')',L',',L'y',L't',L',',L'ا',L'م',L'ا',L'ر',L'ا',L'ت',L',',L'ব',L'া',L'ং',L'ল',L'া',L',',L'中',L'国',L',',L'中',L'國',L',',L'ا',L'ل',L'ج',L'ز',L'ا',L'ئ',L'ر',L',',L'م',L'ص',L'ر',L',',L'გ',L'ე',L',',L'香',L'港',L',',L'भ',L'ा',L'र',L'त',L',',L'ب',L'ھ',L'ا',L'ر',L'ت',L',',L'భ',L'ా',L'ర',L'త',L'్',L',',L'ભ',L'ા',L'ર',L'ત',L',',L'ਭ',L'ਾ',L'ਰ',L'ਤ',L',',L'ভ',L'া',L'র',L'ত',L',',L'இ',L'ந',L'்',L'த',L'ி',L'ய',L'ா',L',',L'ا',L'ی',L'ر',L'ا',L'ن',L',',L'ا',L'ي',L'ر',L'ا',L'ن',L',',L'ا',L'ل',L'ا',L'ر',
+	L'د',L'ن',L',',L'한',L'국',L',',L'ල',L'ං',L'ක',L'ා',L',',L'இ',L'ல',L'ங',L'்',L'க',L'ை',L',',L'ا',L'ل',L'م',L'غ',L'ر',L'ب',L',',L'ع',L'م',L'ا',L'ن',L',',L'ف',L'ل',L'س',L'ط',L'ي',L'ن',L',',L'с',L'р',L'б',L',',L'р',L'ф',L',',L'ق',L'ط',L'ر',L',',L'ا',L'ل',L'س',L'ع',L'و',L'د',L'ي',L'ة',L',',L'ا',L'ل',L'س',L'ع',L'و',L'د',L'ی',L'ة',L',',L'ا',L'ل',L'س',L'ع',L'و',L'د',L'ی',L'ۃ',L',',L'ا',L'ل',L'س',L'ع',L'و',L'د',L'ي',L'ه',L',',L'س',L'و',L'ر',L'ي',L'ة',L',',L'س',L'و',L'ر',L'ي',L'ا',L',',L'新',L'加',L'坡',L',',
+	L'ச',L'ி',L'ங',L'்',L'க',L'ப',L'்',L'ப',L'ூ',L'ர',L'்',L',',L'ไ',L'ท',L'ย',L',',L'ت',L'و',L'ن',L'س',L',',L'台',L'灣',L',',L'台',L'湾',L',',L'臺',L'灣',L',',L'у',L'к',L'р',L',',L'ا',L'ل',L'ي',L'م',L'ن',L',',L'x',L'x',L'x',L',',L'y',L'e',L'(',L'1',L':',L'*',L')',L',',L'z',L'a',L'(',L'1',L':',L'*',L')',L',',L'z',L'm',L'(',L'1',L':',L'*',L')',L',',L'z',L'w',L'(',L'1',L':',L'*',L')',L')',
+L'\0' };
diff --git a/plugin/regdom-libs/tldStringGen.scratchpad.js b/plugin/regdom-libs/tldStringGen.scratchpad.js
new file mode 100644
index 0000000..1ca99ee
--- /dev/null
+++ b/plugin/regdom-libs/tldStringGen.scratchpad.js
@@ -0,0 +1,11 @@
+/*
+ * 这是一个 JavaScript 代码片段速记器。
+ *
+ * 您可以输入一些 JavaScript 代码，然后右击或者从 执行 菜单中选择执行下列操作：
+ * 1. 运行选中的代码。
+ * 2. 打开对象查看器查看运行结果。
+ * 3. 将运行结果作为注释添加到选中内容的后面显示。
+ */
+
+let str = "root(308:ac(6:com,edu,gov,net,mil,org),ad(1:nom),ae(7:co,net,org,sch,ac,gov,mil),aero(89:accident-investigation,accident-prevention,aerobatic,aeroclub,aerodrome,agents,aircraft,airline,airport,air-surveillance,airtraffic,air-traffic-control,ambulance,amusement,association,author,ballooning,broker,caa,cargo,catering,certification,championship,charter,civilaviation,club,conference,consultant,consulting,control,council,crew,design,dgca,educator,emergency,engine,engineer,entertainment,equipment,exchange,express,federation,flight,freight,fuel,gliding,government,groundhandling,group,hanggliding,homebuilt,insurance,journal,journalist,leasing,logistics,magazine,maintenance,marketplace,media,microlight,modelling,navigation,parachuting,paragliding,passenger-association,pilot,press,production,recreation,repbody,res,research,rotorcraft,safety,scientist,services,show,skydiving,software,student,taxi,trader,trading,trainer,union,workinggroup,works),af(5:gov,com,org,net,edu),ag(5:com,org,net,co,nom),ai(4:off,com,net,org),al(6:com,edu,gov,mil,net,org),am,an(4:com,net,org,edu),ao(6:ed,gv,og,co,pb,it),aq,ar(10:*,congresodelalengua3(1:!),educ(1:!),gobiernoelectronico(1:!),mecon(1:!),nacion(1:!),nic(1:!),promocion(1:!),retina(1:!),uba(1:!)),arpa(6:e164,in-addr,ip6,iris,uri,urn),as(1:gov),asia,at(7:ac,co,gv,or,biz,info,priv),au(19:com,net,org,edu(8:act,nsw,nt,qld,sa,tas,vic,wa),gov(7:act,nt,qld,sa,tas,vic,wa),csiro,asn,id,info,conf,oz,act,nsw,nt,qld,sa,tas,vic,wa),aw(1:com),ax,az(12:com,net,int,gov,org,edu,info,pp,mil,name,pro,biz),ba(10:org,net,edu,gov,mil,unsa,unbi,co,com,rs),bb(8:biz,com,edu,gov,info,net,org,store),bd(1:*),be(1:ac),bf(1:gov),bg(36:a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,0,1,2,3,4,5,6,7,8,9),bh(5:com,edu,net,org,gov),bi(5:co,com,edu,or,org),biz(7:dyndns,for-better,for-more,for-some,for-the,selfip,webhop),bj(3:asso,barreau,gouv),bm(5:com,edu,gov,net,org),bn(1:*),bo(9:com,edu,gov,gob,int,org,net,mil,tv),br(69:adm,adv,agr,am,arq,art,ato,b,bio,blog,bmd,cim,cng,cnt,com,coop,ecn,eco,edu,emp,eng,esp,etc,eti,far,flog,fm,fnd,fot,fst,g12,ggf,gov,imb,ind,inf,jor,jus,leg,lel,mat,med,mil,mus,net,nom,not,ntr,odo,org,ppg,pro,psc,psi,qsl,radio,rec,slg,srv,taxi,teo,tmp,trd,tur,tv,vet,vlog,wiki,zlg),bs(5:com,net,org,edu,gov),bt(5:com,edu,gov,net,org),bw(2:co,org),by(4:gov,mil,com,of),bz(5:com,net,org,edu,gov),ca(16:ab,bc,mb,nb,nf,nl,ns,nt,nu,on,pe,qc,sk,yk,gc,co),cat,cc(4:ftpaccess,game-server,myphotos,scrapping),cd(1:gov),cf,cg,ch,ci(15:org,or,com,co,edu,ed,ac,net,go,asso,aéroport,int,presse,md,gouv),ck(2:*,www(1:!)),cl(4:gov,gob,co,mil),cm(1:gov),cn(44:ac,com,edu,gov,net,org,mil,公司,网络,網絡,ah,bj,cq,fj,gd,gs,gz,gx,ha,hb,he,hi,hl,hn,jl,js,jx,ln,nm,nx,qh,sc,sd,sh,sn,sx,tj,xj,xz,yn,zj,hk,mo,tw),co(13:arts,com,edu,firm,gov,info,int,mil,net,nom,org,rec,web),com(171:ar,br,cn,de,eu,gb,gr,hu,jpn,kr,no,qc,ru,sa,se,uk,us,uy,za,operaunite,appspot,dyndns-at-home,dyndns-at-work,dyndns-blog,dyndns-free,dyndns-home,dyndns-ip,dyndns-mail,dyndns-office,dyndns-pics,dyndns-remote,dyndns-server,dyndns-web,dyndns-wiki,dyndns-work,blogdns,cechire,dnsalias,dnsdojo,doesntexist,dontexist,doomdns,dyn-o-saur,dynalias,est-a-la-maison,est-a-la-masion,est-le-patron,est-mon-blogueur,from-ak,from-al,from-ar,from-ca,from-ct,from-dc,from-de,from-fl,from-ga,from-hi,from-ia,from-id,from-il,from-in,from-ks,from-ky,from-ma,from-md,from-mi,from-mn,from-mo,from-ms,from-mt,from-nc,from-nd,from-ne,from-nh,from-nj,from-nm,from-nv,from-oh,from-ok,from-or,from-pa,from-pr,from-ri,from-sc,from-sd,from-tn,from-tx,from-ut,from-va,from-vt,from-wa,from-wi,from-wv,from-wy,getmyip,gotdns,hobby-site,homelinux,homeunix,iamallama,is-a-anarchist,is-a-blogger,is-a-bookkeeper,is-a-bulls-fan,is-a-caterer,is-a-chef,is-a-conservative,is-a-cpa,is-a-cubicle-slave,is-a-democrat,is-a-designer,is-a-doctor,is-a-financialadvisor,is-a-geek,is-a-green,is-a-guru,is-a-hard-worker,is-a-hunter,is-a-landscaper,is-a-lawyer,is-a-liberal,is-a-libertarian,is-a-llama,is-a-musician,is-a-nascarfan,is-a-nurse,is-a-painter,is-a-personaltrainer,is-a-photographer,is-a-player,is-a-republican,is-a-rockstar,is-a-socialist,is-a-student,is-a-teacher,is-a-techie,is-a-therapist,is-an-accountant,is-an-actor,is-an-actress,is-an-anarchist,is-an-artist,is-an-engineer,is-an-entertainer,is-certified,is-gone,is-into-anime,is-into-cars,is-into-cartoons,is-into-games,is-leet,is-not-certified,is-slick,is-uberleet,is-with-theband,isa-geek,isa-hockeynut,issmarterthanyou,likes-pie,likescandy,neat-url,saves-the-whales,selfip,sells-for-less,sells-for-u,servebbs,simple-url,space-to-rent,teaches-yoga,writesthisblog),coop,cr(7:ac,co,ed,fi,go,or,sa),cu(6:com,edu,org,net,gov,inf),cv,cx(2:gov,ath),cy(1:*),cz,de(7:com,fuettertdasnetz,isteingeek,istmein,lebtimnetz,leitungsen,traeumtgerade),dj,dk,dm(5:com,net,org,edu,gov),do(10:art,com,edu,gob,gov,mil,net,org,sld,web),dz(8:com,org,net,gov,edu,asso,pol,art),ec(12:com,info,net,fin,k12,med,pro,org,edu,gov,gob,mil),edu,ee(10:edu,gov,riik,lib,med,com,pri,aip,org,fie),eg(9:com,edu,eun,gov,mil,name,net,org,sci),er(1:*),es(5:com,nom,org,gob,edu),et(1:*),eu,fi(2:aland,iki),fj(1:*),fk(1:*),fm,fo,fr(23:com,asso,nom,prd,presse,tm,aeroport,assedic,avocat,avoues,cci,chambagri,chirurgiens-dentistes,experts-comptables,geometre-expert,gouv,greta,huissier-justice,medecin,notaires,pharmacien,port,veterinaire),ga,gd,ge(7:com,edu,gov,org,mil,net,pvt),gf,gg(5:co,org,net,sch,gov),gh(5:com,edu,gov,org,mil),gi(6:com,ltd,gov,mod,edu,org),gl,gm,gn(6:ac,com,edu,gov,org,net),gov,gp(6:com,net,mobi,edu,org,asso),gq,gr(5:com,edu,net,org,gov),gs,gt(2:*,www(1:!)),gu(1:*),gw,gy(3:co,com,net),hk(21:com,edu,gov,idv,net,org,公司,教育,敎育,政府,個人,个人,箇人,網络,网络,组織,網絡,网絡,组织,組織,組织),hm,hn(6:com,edu,org,net,mil,gob),hr(4:iz,from,name,com),ht(17:com,shop,firm,info,adult,net,pro,org,med,art,coop,pol,asso,edu,rel,gouv,perso),hu(31:co,info,org,priv,sport,tm,2000,agrar,bolt,casino,city,erotica,erotika,film,forum,games,hotel,ingatlan,jogasz,konyvelo,lakas,media,news,reklam,sex,shop,suli,szex,tozsde,utazas,video),id(8:ac,co,go,mil,net,or,sch,web),ie(1:gov),il(1:*),im(6:co(2:ltd,plc),net,gov,org,nic,ac),in(12:co,firm,net,org,gen,ind,nic,ac,edu,res,gov,mil),info(10:dyndns,barrel-of-knowledge,barrell-of-knowledge,for-our,groks-the,groks-this,here-for-more,knowsitall,selfip,webhop),int(1:eu),io(1:com),iq(6:gov,edu,mil,com,org,net),ir(9:ac,co,gov,id,net,org,sch,ایران,ايران),is(6:net,com,edu,gov,org,int),it(277:gov,edu,agrigento,ag,alessandria,al,ancona,an,aosta,aoste,ao,arezzo,ar,ascoli-piceno,ascolipiceno,ap,asti,at,avellino,av,bari,ba,andria-barletta-trani,andriabarlettatrani,trani-barletta-andria,tranibarlettaandria,barletta-trani-andria,barlettatraniandria,andria-trani-barletta,andriatranibarletta,trani-andria-barletta,traniandriabarletta,bt,belluno,bl,benevento,bn,bergamo,bg,biella,bi,bologna,bo,bolzano,bozen,balsan,alto-adige,altoadige,suedtirol,bz,brescia,bs,brindisi,br,cagliari,ca,caltanissetta,cl,campobasso,cb,carboniaiglesias,carbonia-iglesias,iglesias-carbonia,iglesiascarbonia,ci,caserta,ce,catania,ct,catanzaro,cz,chieti,ch,como,co,cosenza,cs,cremona,cr,crotone,kr,cuneo,cn,dell-ogliastra,dellogliastra,ogliastra,og,enna,en,ferrara,fe,fermo,fm,firenze,florence,fi,foggia,fg,forli-cesena,forlicesena,cesena-forli,cesenaforli,fc,frosinone,fr,genova,genoa,ge,gorizia,go,grosseto,gr,imperia,im,isernia,is,laquila,aquila,aq,la-spezia,laspezia,sp,latina,lt,lecce,le,lecco,lc,livorno,li,lodi,lo,lucca,lu,macerata,mc,mantova,mn,massa-carrara,massacarrara,carrara-massa,carraramassa,ms,matera,mt,medio-campidano,mediocampidano,campidano-medio,campidanomedio,vs,messina,me,milano,milan,mi,modena,mo,monza,monza-brianza,monzabrianza,monzaebrianza,monzaedellabrianza,monza-e-della-brianza,mb,napoli,naples,na,novara,no,nuoro,nu,oristano,or,padova,padua,pd,palermo,pa,parma,pr,pavia,pv,perugia,pg,pescara,pe,pesaro-urbino,pesarourbino,urbino-pesaro,urbinopesaro,pu,piacenza,pc,pisa,pi,pistoia,pt,pordenone,pn,potenza,pz,prato,po,ragusa,rg,ravenna,ra,reggio-calabria,reggiocalabria,rc,reggio-emilia,reggioemilia,re,rieti,ri,rimini,rn,roma,rome,rm,rovigo,ro,salerno,sa,sassari,ss,savona,sv,siena,si,siracusa,sr,sondrio,so,taranto,ta,tempio-olbia,tempioolbia,olbia-tempio,olbiatempio,ot,teramo,te,terni,tr,torino,turin,to,trapani,tp,trento,trentino,tn,treviso,tv,trieste,ts,udine,ud,varese,va,venezia,venice,ve,verbania,vb,vercelli,vc,verona,vr,vibo-valentia,vibovalentia,vv,vicenza,vi,viterbo,vt),je(5:co,org,net,sch,gov),jm(1:*),jo(8:com,org,net,edu,sch,gov,mil,name),jobs,jp(63:ac,ad,co,ed,go,gr,lg,ne,or,aichi(53:aisai,ama,anjo,asuke,chiryu,chita,fuso,gamagori,handa,hazu,hekinan,higashiura,ichinomiya,inazawa,inuyama,isshiki,iwakura,kanie,kariya,kasugai,kira,kiyosu,komaki,konan,kota,mihama,miyoshi,nagakute,nishio,nisshin,obu,oguchi,oharu,okazaki,owariasahi,seto,shikatsu,shinshiro,shitara,tahara,takahama,tobishima,toei,togo,tokai,tokoname,toyoake,toyohashi,toyokawa,toyone,toyota,tsushima,yatomi),akita(28:akita,daisen,fujisato,gojome,hachirogata,happou,higashinaruse,honjo,honjyo,ikawa,kamikoani,kamioka,katagami,kazuno,kitaakita,kosaka,kyowa,misato,mitane,moriyoshi,nikaho,noshiro,odate,oga,ogata,semboku,yokote,yurihonjo),aomori(22:aomori,gonohe,hachinohe,hashikami,hiranai,hirosaki,itayanagi,kuroishi,misawa,mutsu,nakadomari,noheji,oirase,owani,rokunohe,sannohe,shichinohe,shingo,takko,towada,tsugaru,tsuruta),chiba(58:abiko,asahi,chonan,chosei,choshi,chuo,funabashi,futtsu,hanamigawa,ichihara,ichikawa,ichinomiya,inzai,isumi,kamagaya,kamogawa,kashiwa,katori,katsuura,kimitsu,kisarazu,kozaki,kujukuri,kyonan,matsudo,midori,mihama,minamiboso,mobara,mutsuzawa,nagara,nagareyama,narashino,narita,noda,oamishirasato,omigawa,onjuku,otaki,sakae,sakura,shimofusa,shirako,shiroi,shisui,sodegaura,sosa,tako,tateyama,togane,tohnosho,tomisato,urayasu,yachimata,yachiyo,yokaichiba,yokoshibahikari,yotsukaido),ehime(22:ainan,honai,ikata,imabari,iyo,kamijima,kihoku,kumakogen,masaki,matsuno,matsuyama,namikata,niihama,ozu,saijo,seiyo,shikokuchuo,tobe,toon,uchiko,uwajima,yawatahama),fukui(15:echizen,eiheiji,fukui,ikeda,katsuyama,mihama,minamiechizen,obama,ohi,ono,sabae,sakai,takahama,tsuruga,wakasa),fukuoka(63:ashiya,buzen,chikugo,chikuho,chikujo,chikushino,chikuzen,chuo,dazaifu,fukuchi,hakata,higashi,hirokawa,hisayama,iizuka,inatsuki,kaho,kasuga,kasuya,kawara,keisen,koga,kurate,kurogi,kurume,minami,miyako,miyama,miyawaka,mizumaki,munakata,nakagawa,nakama,nishi,nogata,ogori,okagaki,okawa,oki,omuta,onga,onojo,oto,saigawa,sasaguri,shingu,shinyoshitomi,shonai,soeda,sue,tachiarai,tagawa,takata,toho,toyotsu,tsuiki,ukiha,umi,usui,yamada,yame,yanagawa,yukuhashi),fukushima(51:aizubange,aizumisato,aizuwakamatsu,asakawa,bandai,date,fukushima,furudono,futaba,hanawa,higashi,hirata,hirono,iitate,inawashiro,ishikawa,iwaki,izumizaki,kagamiishi,kaneyama,kawamata,kitakata,kitashiobara,koori,koriyama,kunimi,miharu,mishima,namie,nango,nishiaizu,nishigo,okuma,omotego,ono,otama,samegawa,shimogo,shirakawa,showa,soma,sukagawa,taishin,tamakawa,tanagura,tenei,yabuki,yamato,yamatsuri,yanaizu,yugawa),gifu(38:anpachi,ena,gifu,ginan,godo,gujo,hashima,hichiso,hida,higashishirakawa,ibigawa,ikeda,kakamigahara,kani,kasahara,kasamatsu,kawaue,kitagata,mino,minokamo,mitake,mizunami,motosu,nakatsugawa,ogaki,sakahogi,seki,sekigahara,shirakawa,tajimi,takayama,tarui,toki,tomika,wanouchi,yamagata,yaotsu,yoro),gunma(36:annaka,chiyoda,fujioka,higashiagatsuma,isesaki,itakura,kanna,kanra,katashina,kawaba,kiryu,kusatsu,maebashi,meiwa,midori,minakami,naganohara,nakanojo,nanmoku,numata,oizumi,ora,ota,shibukawa,shimonita,shinto,showa,takasaki,takayama,tamamura,tatebayashi,tomioka,tsukiyono,tsumagoi,ueno,yoshioka),hiroshima(25:asaminami,daiwa,etajima,fuchu,fukuyama,hatsukaichi,higashihiroshima,hongo,jinsekikogen,kaita,kui,kumano,kure,mihara,miyoshi,naka,onomichi,osakikamijima,otake,saka,sera,seranishi,shinichi,shobara,takehara),hokkaido(142:abashiri,abira,aibetsu,akabira,akkeshi,asahikawa,ashibetsu,ashoro,assabu,atsuma,bibai,biei,bifuka,bihoro,biratori,chippubetsu,chitose,date,ebetsu,embetsu,eniwa,erimo,esan,esashi,fukagawa,fukushima,furano,furubira,haboro,hakodate,hamatonbetsu,hidaka,higashikagura,higashikawa,hiroo,hokuryu,hokuto,honbetsu,horokanai,horonobe,ikeda,imakane,ishikari,iwamizawa,iwanai,kamifurano,kamikawa,kamishihoro,kamisunagawa,kamoenai,kayabe,kembuchi,kikonai,kimobetsu,kitahiroshima,kitami,kiyosato,koshimizu,kunneppu,kuriyama,kuromatsunai,kushiro,kutchan,kyowa,mashike,matsumae,mikasa,minamifurano,mombetsu,moseushi,mukawa,muroran,naie,nakagawa,nakasatsunai,nakatombetsu,nanae,nanporo,nayoro,nemuro,niikappu,niki,nishiokoppe,noboribetsu,numata,obihiro,obira,oketo,okoppe,otaru,otobe,otofuke,otoineppu,oumu,ozora,pippu,rankoshi,rebun,rikubetsu,rishiri,rishirifuji,saroma,sarufutsu,shakotan,shari,shibecha,shibetsu,shikabe,shikaoi,shimamaki,shimizu,shimokawa,shinshinotsu,shintoku,shiranuka,shiraoi,shiriuchi,sobetsu,sunagawa,taiki,takasu,takikawa,takinoue,teshikaga,tobetsu,tohma,tomakomai,tomari,toya,toyako,toyotomi,toyoura,tsubetsu,tsukigata,urakawa,urausu,uryu,utashinai,wakkanai,wassamu,yakumo,yoichi),hyogo(46:aioi,akashi,ako,amagasaki,aogaki,asago,ashiya,awaji,fukusaki,goshiki,harima,himeji,ichikawa,inagawa,itami,kakogawa,kamigori,kamikawa,kasai,kasuga,kawanishi,miki,minamiawaji,nishinomiya,nishiwaki,ono,sanda,sannan,sasayama,sayo,shingu,shinonsen,shiso,sumoto,taishi,taka,takarazuka,takasago,takino,tamba,tatsuno,toyooka,yabu,yashiro,yoka,yokawa),ibaraki(51:ami,asahi,bando,chikusei,daigo,fujishiro,hitachi,hitachinaka,hitachiomiya,hitachiota,ibaraki,ina,inashiki,itako,iwama,joso,kamisu,kasama,kashima,kasumigaura,koga,miho,mito,moriya,naka,namegata,oarai,ogawa,omitama,ryugasaki,sakai,sakuragawa,shimodate,shimotsuma,shirosato,sowa,suifu,takahagi,tamatsukuri,tokai,tomobe,tone,toride,tsuchiura,tsukuba,uchihara,ushiku,yachiyo,yamagata,yawara,yuki),ishikawa(19:anamizu,hakui,hakusan,kaga,kahoku,kanazawa,kawakita,komatsu,nakanoto,nanao,nomi,nonoichi,noto,shika,suzu,tsubata,tsurugi,uchinada,wajima),iwate(35:fudai,fujisawa,hanamaki,hiraizumi,hirono,ichinohe,ichinoseki,iwaizumi,iwate,joboji,kamaishi,kanegasaki,karumai,kawai,kitakami,kuji,kunohe,kuzumaki,miyako,mizusawa,morioka,ninohe,noda,ofunato,oshu,otsuchi,rikuzentakata,shiwa,shizukuishi,sumita,takizawa,tanohata,tono,yahaba,yamada),kagawa(15:ayagawa,higashikagawa,kanonji,kotohira,manno,marugame,mitoyo,naoshima,sanuki,tadotsu,takamatsu,tonosho,uchinomi,utazu,zentsuji),kagoshima(20:akune,amami,hioki,isa,isen,izumi,kagoshima,kanoya,kawanabe,kinko,kouyama,makurazaki,matsumoto,minamitane,nakatane,nishinoomote,satsumasendai,soo,tarumizu,yusui),kanagawa(30:aikawa,atsugi,ayase,chigasaki,ebina,fujisawa,hadano,hakone,hiratsuka,isehara,kaisei,kamakura,kiyokawa,matsuda,minamiashigara,miura,nakai,ninomiya,odawara,oi,oiso,sagamihara,samukawa,tsukui,yamakita,yamato,yokosuka,yugawara,zama,zushi),kochi(31:aki,geisei,hidaka,higashitsuno,ino,kagami,kami,kitagawa,kochi,mihara,motoyama,muroto,nahari,nakamura,nankoku,nishitosa,niyodogawa,ochi,okawa,otoyo,otsuki,sakawa,sukumo,susaki,tosa,tosashimizu,toyo,tsuno,umaji,yasuda,yusuhara),kumamoto(26:amakusa,arao,aso,choyo,gyokuto,hitoyoshi,kamiamakusa,kashima,kikuchi,kosa,kumamoto,mashiki,mifune,minamata,minamioguni,nagasu,nishihara,oguni,ozu,sumoto,takamori,uki,uto,yamaga,yamato,yatsushiro),kyoto(31:ayabe,fukuchiyama,higashiyama,ide,ine,joyo,kameoka,kamo,kita,kizu,kumiyama,kyotamba,kyotanabe,kyotango,maizuru,minami,minamiyamashiro,miyazu,muko,nagaokakyo,nakagyo,nantan,oyamazaki,sakyo,seika,tanabe,uji,ujitawara,wazuka,yamashina,yawata),mie(30:asahi,inabe,ise,kameyama,kawagoe,kiho,kisosaki,kiwa,komono,kumano,kuwana,matsusaka,meiwa,mihama,minamiise,misugi,miyama,nabari,shima,suzuka,tado,taiki,taki,tamaki,toba,tsu,udono,ureshino,watarai,yokkaichi),miyagi(33:furukawa,higashimatsushima,ishinomaki,iwanuma,kakuda,kami,kawasaki,kesennuma,marumori,matsushima,minamisanriku,misato,murata,natori,ogawara,ohira,onagawa,osaki,rifu,semine,shibata,shichikashuku,shikama,shiogama,shiroishi,tagajo,taiwa,tome,tomiya,wakuya,watari,yamamoto,zao),miyazaki(27:aya,ebino,gokase,hyuga,kadogawa,kawaminami,kijo,kitagawa,kitakata,kitaura,kobayashi,kunitomi,kushima,mimata,miyakonojo,miyazaki,morotsuka,nichinan,nishimera,nobeoka,saito,shiiba,shintomi,takaharu,takanabe,takazaki,tsuno),nagano(75:achi,agematsu,anan,aoki,asahi,azumino,chikuhoku,chikuma,chino,fujimi,hakuba,hara,hiraya,iida,iijima,iiyama,iizuna,ikeda,ikusaka,ina,karuizawa,kawakami,kiso,kisofukushima,kitaaiki,komagane,komoro,matsukawa,matsumoto,miasa,minamiaiki,minamimaki,minamiminowa,minowa,miyada,miyota,mochizuki,nagano,nagawa,nagiso,nakagawa,nakano,nozawaonsen,obuse,ogawa,okaya,omachi,omi,ookuwa,ooshika,otaki,otari,sakae,sakaki,saku,sakuho,shimosuwa,shinanomachi,shiojiri,suwa,suzaka,takagi,takamori,takayama,tateshina,tatsuno,togakushi,togura,tomi,ueda,wada,yamagata,yamanouchi,yasaka,yasuoka),nagasaki(22:chijiwa,futsu,goto,hasami,hirado,iki,isahaya,kawatana,kuchinotsu,matsuura,nagasaki,obama,omura,oseto,saikai,sasebo,seihi,shimabara,shinkamigoto,togitsu,tsushima,unzen),nara(38:ando,gose,heguri,higashiyoshino,ikaruga,ikoma,kamikitayama,kanmaki,kashiba,kashihara,katsuragi,kawai,kawakami,kawanishi,koryo,kurotaki,mitsue,miyake,nara,nosegawa,oji,ouda,oyodo,sakurai,sango,shimoichi,shimokitayama,shinjo,soni,takatori,tawaramoto,tenkawa,tenri,uda,yamatokoriyama,yamatotakada,yamazoe,yoshino),niigata(34:aga,agano,gosen,itoigawa,izumozaki,joetsu,kamo,kariwa,kashiwazaki,minamiuonuma,mitsuke,muika,murakami,myoko,nagaoka,niigata,ojiya,omi,sado,sanjo,seiro,seirou,sekikawa,shibata,tagami,tainai,tochio,tokamachi,tsubame,tsunan,uonuma,yahiko,yoita,yuzawa),oita(19:beppu,bungoono,bungotakada,hasama,hiji,himeshima,hita,kamitsue,kokonoe,kuju,kunisaki,kusu,oita,saiki,taketa,tsukumi,usa,usuki,yufu),okayama(26:akaiwa,asakuchi,bizen,hayashima,ibara,kagamino,kasaoka,kibichuo,kumenan,kurashiki,maniwa,misaki,nagi,niimi,nishiawakura,okayama,satosho,setouchi,shinjo,shoo,soja,takahashi,tamano,tsuyama,wake,yakage),okinawa(42:aguni,ginowan,ginoza,gushikami,haebaru,higashi,hirara,iheya,ishigaki,ishikawa,itoman,izena,kadena,kin,kitadaito,kitanakagusuku,kumejima,kunigami,minamidaito,motobu,nago,naha,nakagusuku,nakijin,nanjo,nishihara,ogimi,okinawa,onna,shimoji,taketomi,tarama,tokashiki,tomigusuku,tonaki,urasoe,uruma,yaese,yomitan,yonabaru,yonaguni,zamami),osaka(50:abeno,chihayaakasaka,chuo,daito,fujiidera,habikino,hannan,higashiosaka,higashisumiyoshi,higashiyodogawa,hirakata,ibaraki,ikeda,izumi,izumiotsu,izumisano,kadoma,kaizuka,kanan,kashiwara,katano,kawachinagano,kishiwada,kita,kumatori,matsubara,minato,minoh,misaki,moriguchi,neyagawa,nishi,nose,osakasayama,sakai,sayama,sennan,settsu,shijonawate,shimamoto,suita,tadaoka,taishi,tajiri,takaishi,takatsuki,tondabayashi,toyonaka,toyono,yao),saga(26:ariake,arita,fukudomi,genkai,hamatama,hizen,imari,kamimine,kanzaki,karatsu,kashima,kitagata,kitahata,kiyama,kouhoku,kyuragi,nishiarita,ogi,omachi,ouchi,saga,shiroishi,taku,tara,tosu,yoshinogari),saitama(69:arakawa,asaka,chichibu,fujimi,fujimino,fukaya,hanno,hanyu,hasuda,hatogaya,hatoyama,hidaka,higashichichibu,higashimatsuyama,honjo,ina,iruma,iwatsuki,kamiizumi,kamikawa,kamisato,kasukabe,kawagoe,kawaguchi,kawajima,kazo,kitamoto,koshigaya,kounosu,kuki,kumagaya,matsubushi,minano,misato,miyashiro,miyoshi,moroyama,nagatoro,namegawa,niiza,ogano,ogawa,ogose,okegawa,omiya,otaki,ranzan,ryokami,saitama,sakado,satte,sayama,shiki,shiraoka,soka,sugito,toda,tokigawa,tokorozawa,tsurugashima,urawa,warabi,yashio,yokoze,yono,yorii,yoshida,yoshikawa,yoshimi),shiga(23:aisho,gamo,higashiomi,hikone,koka,konan,kosei,koto,kusatsu,maibara,moriyama,nagahama,nishiazai,notogawa,omihachiman,otsu,ritto,ryuoh,takashima,takatsuki,torahime,toyosato,yasu),shimane(23:akagi,ama,gotsu,hamada,higashiizumo,hikawa,hikimi,izumo,kakinoki,masuda,matsue,misato,nishinoshima,ohda,okinoshima,okuizumo,shimane,tamayu,tsuwano,unnan,yakumo,yasugi,yatsuka),shizuoka(36:arai,atami,fuji,fujieda,fujikawa,fujinomiya,fukuroi,gotemba,haibara,hamamatsu,higashiizu,ito,iwata,izu,izunokuni,kakegawa,kannami,kawanehon,kawazu,kikugawa,kosai,makinohara,matsuzaki,minamiizu,mishima,morimachi,nishiizu,numazu,omaezaki,shimada,shimizu,shimoda,shizuoka,susono,yaizu,yoshida),tochigi(31:ashikaga,bato,haga,ichikai,iwafune,kaminokawa,kanuma,karasuyama,kuroiso,mashiko,mibu,moka,motegi,nasu,nasushiobara,nikko,nishikata,nogi,ohira,ohtawara,oyama,sakura,sano,shimotsuke,shioya,takanezawa,tochigi,tsuga,ujiie,utsunomiya,yaita),tokushima(17:aizumi,anan,ichiba,itano,kainan,komatsushima,matsushige,mima,minami,miyoshi,mugi,nakagawa,naruto,sanagochi,shishikui,tokushima,wajiki),tokyo(57:adachi,akiruno,akishima,aogashima,arakawa,bunkyo,chiyoda,chofu,chuo,edogawa,fuchu,fussa,hachijo,hachioji,hamura,higashikurume,higashimurayama,higashiyamato,hino,hinode,hinohara,inagi,itabashi,katsushika,kita,kiyose,kodaira,koganei,kokubunji,komae,koto,kouzushima,kunitachi,machida,meguro,minato,mitaka,mizuho,musashimurayama,musashino,nakano,nerima,ogasawara,okutama,ome,oshima,ota,setagaya,shibuya,shinagawa,shinjuku,suginami,sumida,tachikawa,taito,tama,toshima),tottori(13:chizu,hino,kawahara,koge,kotoura,misasa,nanbu,nichinan,sakaiminato,tottori,wakasa,yazu,yonago),toyama(24:asahi,fuchu,fukumitsu,funahashi,himi,imizu,inami,johana,kamiichi,kurobe,nakaniikawa,namerikawa,nanto,nyuzen,oyabe,taira,takaoka,tateyama,toga,tonami,toyama,unazuki,uozu,yamada),wakayama(29:arida,aridagawa,gobo,hashimoto,hidaka,hirogawa,inami,iwade,kainan,kamitonda,katsuragi,kimino,kinokawa,kitayama,koya,koza,kozagawa,kudoyama,kushimoto,mihama,misato,nachikatsuura,shingu,shirahama,taiji,tanabe,wakayama,yuasa,yura),yamagata(34:asahi,funagata,higashine,iide,kahoku,kaminoyama,kaneyama,kawanishi,mamurogawa,mikawa,murayama,nagai,nakayama,nanyo,nishikawa,obanazawa,oe,oguni,ohkura,oishida,sagae,sakata,sakegawa,shinjo,shirataka,shonai,takahata,tendo,tozawa,tsuruoka,yamagata,yamanobe,yonezawa,yuza),yamaguchi(16:abu,hagi,hikari,hofu,iwakuni,kudamatsu,mitou,nagato,oshima,shimonoseki,shunan,tabuse,tokuyama,toyota,ube,yuu),yamanashi(28:chuo,doshi,fuefuki,fujikawa,fujikawaguchiko,fujiyoshida,hayakawa,hokuto,ichikawamisato,kai,kofu,koshu,kosuge,minami-alps,minobu,nakamichi,nanbu,narusawa,nirasaki,nishikatsura,oshino,otsuki,showa,tabayama,tsuru,uenohara,yamanakako,yamanashi),kawasaki(2:*,city(1:!)),kitakyushu(2:*,city(1:!)),kobe(2:*,city(1:!)),nagoya(2:*,city(1:!)),sapporo(2:*,city(1:!)),sendai(2:*,city(1:!)),yokohama(2:*,city(1:!))),ke(1:*),kg(6:org,net,com,edu,gov,mil),kh(1:*),ki(7:edu,biz,net,org,gov,info,com),km(17:org,nom,gov,prd,tm,edu,mil,ass,com,coop,asso,presse,medecin,notaires,pharmaciens,veterinaire,gouv),kn(4:net,org,edu,gov),kp(6:com,edu,gov,org,rep,tra),kr(29:ac,co,es,go,hs,kg,mil,ms,ne,or,pe,re,sc,busan,chungbuk,chungnam,daegu,daejeon,gangwon,gwangju,gyeongbuk,gyeonggi,gyeongnam,incheon,jeju,jeonbuk,jeonnam,seoul,ulsan),kw(1:*),ky(5:edu,gov,com,org,net),kz(6:org,edu,net,gov,mil,com),la(9:int,net,info,edu,gov,per,com,org,c),lb(5:com,edu,gov,net,org),lc(6:com,net,co,org,edu,gov),li,lk(14:gov,sch,net,int,com,org,edu,ngo,soc,web,ltd,assn,grp,hotel),lr(5:com,edu,gov,org,net),ls(2:co,org),lt(1:gov),lu,lv(9:com,edu,gov,org,mil,id,net,asn,conf),ly(9:com,net,gov,plc,edu,sch,med,org,id),ma(6:co,net,gov,org,ac,press),mc(2:tm,asso),md,me(8:co,net,org,edu,ac,gov,its,priv),mg(8:org,nom,gov,prd,tm,edu,mil,com),mh,mil,mk(7:com,org,net,edu,gov,inf,name),ml(7:com,edu,gouv,gov,net,org,presse),mm(1:*),mn(3:gov,edu,org),mo(5:com,net,org,edu,gov),mobi,mp,mq,mr(1:gov),ms,mt(1:*),mu(7:com,net,org,gov,ac,co,or),museum(548:academy,agriculture,air,airguard,alabama,alaska,amber,ambulance,american,americana,americanantiques,americanart,amsterdam,and,annefrank,anthro,anthropology,antiques,aquarium,arboretum,archaeological,archaeology,architecture,art,artanddesign,artcenter,artdeco,arteducation,artgallery,arts,artsandcrafts,asmatart,assassination,assisi,association,astronomy,atlanta,austin,australia,automotive,aviation,axis,badajoz,baghdad,bahn,bale,baltimore,barcelona,baseball,basel,baths,bauern,beauxarts,beeldengeluid,bellevue,bergbau,berkeley,berlin,bern,bible,bilbao,bill,birdart,birthplace,bonn,boston,botanical,botanicalgarden,botanicgarden,botany,brandywinevalley,brasil,bristol,british,britishcolumbia,broadcast,brunel,brussel,brussels,bruxelles,building,burghof,bus,bushey,cadaques,california,cambridge,can,canada,capebreton,carrier,cartoonart,casadelamoneda,castle,castres,celtic,center,chattanooga,cheltenham,chesapeakebay,chicago,children,childrens,childrensgarden,chiropractic,chocolate,christiansburg,cincinnati,cinema,circus,civilisation,civilization,civilwar,clinton,clock,coal,coastaldefence,cody,coldwar,collection,colonialwilliamsburg,coloradoplateau,columbia,columbus,communication,communications,community,computer,computerhistory,comunicações,contemporary,contemporaryart,convent,copenhagen,corporation,correios-e-telecomunicações,corvette,costume,countryestate,county,crafts,cranbrook,creation,cultural,culturalcenter,culture,cyber,cymru,dali,dallas,database,ddr,decorativearts,delaware,delmenhorst,denmark,depot,design,detroit,dinosaur,discovery,dolls,donostia,durham,eastafrica,eastcoast,education,educational,egyptian,eisenbahn,elburg,elvendrell,embroidery,encyclopedic,england,entomology,environment,environmentalconservation,epilepsy,essex,estate,ethnology,exeter,exhibition,family,farm,farmequipment,farmers,farmstead,field,figueres,filatelia,film,fineart,finearts,finland,flanders,florida,force,fortmissoula,fortworth,foundation,francaise,frankfurt,franziskaner,freemasonry,freiburg,fribourg,frog,fundacio,furniture,gallery,garden,gateway,geelvinck,gemological,geology,georgia,giessen,glas,glass,gorge,grandrapids,graz,guernsey,halloffame,hamburg,handson,harvestcelebration,hawaii,health,heimatunduhren,hellas,helsinki,hembygdsforbund,heritage,histoire,historical,historicalsociety,historichouses,historisch,historisches,history,historyofscience,horology,house,humanities,illustration,imageandsound,indian,indiana,indianapolis,indianmarket,intelligence,interactive,iraq,iron,isleofman,jamison,jefferson,jerusalem,jewelry,jewish,jewishart,jfk,journalism,judaica,judygarland,juedisches,juif,karate,karikatur,kids,koebenhavn,koeln,kunst,kunstsammlung,kunstunddesign,labor,labour,lajolla,lancashire,landes,lans,läns,larsson,lewismiller,lincoln,linz,living,livinghistory,localhistory,london,losangeles,louvre,loyalist,lucerne,luxembourg,luzern,mad,madrid,mallorca,manchester,mansion,mansions,manx,marburg,maritime,maritimo,maryland,marylhurst,media,medical,medizinhistorisches,meeres,memorial,mesaverde,michigan,midatlantic,military,mill,miners,mining,minnesota,missile,missoula,modern,moma,money,monmouth,monticello,montreal,moscow,motorcycle,muenchen,muenster,mulhouse,muncie,museet,museumcenter,museumvereniging,music,national,nationalfirearms,nationalheritage,nativeamerican,naturalhistory,naturalhistorymuseum,naturalsciences,nature,naturhistorisches,natuurwetenschappen,naumburg,naval,nebraska,neues,newhampshire,newjersey,newmexico,newport,newspaper,newyork,niepce,norfolk,north,nrw,nuernberg,nuremberg,nyc,nyny,oceanographic,oceanographique,omaha,online,ontario,openair,oregon,oregontrail,otago,oxford,pacific,paderborn,palace,paleo,palmsprings,panama,paris,pasadena,pharmacy,philadelphia,philadelphiaarea,philately,phoenix,photography,pilots,pittsburgh,planetarium,plantation,plants,plaza,portal,portland,portlligat,posts-and-telecommunications,preservation,presidio,press,project,public,pubol,quebec,railroad,railway,research,resistance,riodejaneiro,rochester,rockart,roma,russia,saintlouis,salem,salvadordali,salzburg,sandiego,sanfrancisco,santabarbara,santacruz,santafe,saskatchewan,satx,savannahga,schlesisches,schoenbrunn,schokoladen,school,schweiz,science,scienceandhistory,scienceandindustry,sciencecenter,sciencecenters,science-fiction,sciencehistory,sciences,sciencesnaturelles,scotland,seaport,settlement,settlers,shell,sherbrooke,sibenik,silk,ski,skole,society,sologne,soundandvision,southcarolina,southwest,space,spy,square,stadt,stalbans,starnberg,state,stateofdelaware,station,steam,steiermark,stjohn,stockholm,stpetersburg,stuttgart,suisse,surgeonshall,surrey,svizzera,sweden,sydney,tank,tcm,technology,telekommunikation,television,texas,textile,theater,time,timekeeping,topology,torino,touch,town,transport,tree,trolley,trust,trustee,uhren,ulm,undersea,university,usa,usantiques,usarts,uscountryestate,usculture,usdecorativearts,usgarden,ushistory,ushuaia,uslivinghistory,utah,uvic,valley,vantaa,versailles,viking,village,virginia,virtual,virtuel,vlaanderen,volkenkunde,wales,wallonie,war,washingtondc,watchandclock,watch-and-clock,western,westfalen,whaling,wildlife,williamsburg,windmill,workshop,york,yorkshire,yosemite,youth,zoological,zoology,ירושלים,иком),mv(14:aero,biz,com,coop,edu,gov,info,int,mil,museum,name,net,org,pro),mw(11:ac,biz,co,com,coop,edu,gov,int,museum,net,org),mx(5:com,org,gob,edu,net),my(7:com,net,org,gov,edu,mil,name),mz(1:*),na(17:info,pro,name,school,or,dr,us,mx,ca,in,cc,tv,ws,mobi,co,com,org),name(2:her(1:forgot),his(1:forgot)),nc(1:asso),ne,net(41:gb,jp,se,uk,hu,za,at-band-camp,blogdns,broke-it,buyshouses,dnsalias,dnsdojo,does-it,dontexist,dynalias,dynathome,endofinternet,from-az,from-co,from-la,from-ny,gets-it,ham-radio-op,homeftp,homeip,homelinux,homeunix,in-the-band,is-a-chef,is-a-geek,isa-geek,kicks-ass,office-on-the,podzone,scrapper-site,selfip,sells-it,servebbs,serveftp,thruhere,webhop),nf(10:com,net,per,rec,web,arts,firm,info,other,store),ng(6:ac,com,edu,gov,net,org),ni(1:*),nl(2:bv,co),no(725:fhs,vgs,fylkesbibl,folkebibl,museum,idrett,priv,mil,stat,dep,kommune,herad,aa(1:gs),ah(1:gs),bu(1:gs),fm(1:gs),hl(1:gs),hm(1:gs),jan-mayen(1:gs),mr(1:gs),nl(1:gs),nt(1:gs),of(1:gs),ol(1:gs),oslo(1:gs),rl(1:gs),sf(1:gs),st(1:gs),svalbard(1:gs),tm(1:gs),tr(1:gs),va(1:gs),vf(1:gs),akrehamn,åkrehamn,algard,ålgård,arna,brumunddal,bryne,bronnoysund,brønnøysund,drobak,drøbak,egersund,fetsund,floro,florø,fredrikstad,hokksund,honefoss,hønefoss,jessheim,jorpeland,jørpeland,kirkenes,kopervik,krokstadelva,langevag,langevåg,leirvik,mjondalen,mjøndalen,mo-i-rana,mosjoen,mosjøen,nesoddtangen,orkanger,osoyro,osøyro,raholt,råholt,sandnessjoen,sandnessjøen,skedsmokorset,slattum,spjelkavik,stathelle,stavern,stjordalshalsen,stjørdalshalsen,tananger,tranby,vossevangen,afjord,åfjord,agdenes,al,ål,alesund,ålesund,alstahaug,alta,áltá,alaheadju,álaheadju,alvdal,amli,åmli,amot,åmot,andebu,andoy,andøy,andasuolo,ardal,årdal,aremark,arendal,ås,aseral,åseral,asker,askim,askvoll,askoy,askøy,asnes,åsnes,audnedaln,aukra,aure,aurland,aurskog-holand,aurskog-høland,austevoll,austrheim,averoy,averøy,balestrand,ballangen,balat,bálát,balsfjord,bahccavuotna,báhccavuotna,bamble,bardu,beardu,beiarn,bajddar,bájddar,baidar,báidár,berg,bergen,berlevag,berlevåg,bearalvahki,bearalváhki,bindal,birkenes,bjarkoy,bjarkøy,bjerkreim,bjugn,bodo,bodø,badaddja,bådåddjå,budejju,bokn,bremanger,bronnoy,brønnøy,bygland,bykle,barum,bærum,telemark(2:bo,bø),nordland(4:bo,bø,heroy,herøy),bievat,bievát,bomlo,bømlo,batsfjord,båtsfjord,bahcavuotna,báhcavuotna,dovre,drammen,drangedal,dyroy,dyrøy,donna,dønna,eid,eidfjord,eidsberg,eidskog,eidsvoll,eigersund,elverum,enebakk,engerdal,etne,etnedal,evenes,evenassi,evenášši,evje-og-hornnes,farsund,fauske,fuossko,fuoisku,fedje,fet,finnoy,finnøy,fitjar,fjaler,fjell,flakstad,flatanger,flekkefjord,flesberg,flora,fla,flå,folldal,forsand,fosnes,frei,frogn,froland,frosta,frana,fræna,froya,frøya,fusa,fyresdal,forde,førde,gamvik,gangaviika,gáŋgaviika,gaular,gausdal,gildeskal,gildeskål,giske,gjemnes,gjerdrum,gjerstad,gjesdal,gjovik,gjøvik,gloppen,gol,gran,grane,granvin,gratangen,grimstad,grong,kraanghke,kråanghke,grue,gulen,hadsel,halden,halsa,hamar,hamaroy,habmer,hábmer,hapmir,hápmir,hammerfest,hammarfeasta,hámmárfeasta,haram,hareid,harstad,hasvik,aknoluokta,ákŋoluokta,hattfjelldal,aarborte,haugesund,hemne,hemnes,hemsedal,more-og-romsdal(2:heroy,sande),møre-og-romsdal(2:herøy,sande),hitra,hjartdal,hjelmeland,hobol,hobøl,hof,hol,hole,holmestrand,holtalen,holtålen,hornindal,horten,hurdal,hurum,hvaler,hyllestad,hagebostad,hægebostad,hoyanger,høyanger,hoylandet,høylandet,ha,hå,ibestad,inderoy,inderøy,iveland,jevnaker,jondal,jolster,jølster,karasjok,karasjohka,kárášjohka,karlsoy,galsa,gálsá,karmoy,karmøy,kautokeino,guovdageaidnu,klepp,klabu,klæbu,kongsberg,kongsvinger,kragero,kragerø,kristiansand,kristiansund,krodsherad,krødsherad,kvalsund,rahkkeravju,ráhkkerávju,kvam,kvinesdal,kvinnherad,kviteseid,kvitsoy,kvitsøy,kvafjord,kvæfjord,giehtavuoatna,kvanangen,kvænangen,navuotna,návuotna,kafjord,kåfjord,gaivuotna,gáivuotna,larvik,lavangen,lavagis,loabat,loabát,lebesby,davvesiida,leikanger,leirfjord,leka,leksvik,lenvik,leangaviika,leaŋgaviika,lesja,levanger,lier,lierne,lillehammer,lillesand,lindesnes,lindas,lindås,lom,loppa,lahppi,láhppi,lund,lunner,luroy,lurøy,luster,lyngdal,lyngen,ivgu,lardal,lerdal,lærdal,lodingen,lødingen,lorenskog,lørenskog,loten,løten,malvik,masoy,måsøy,muosat,muosát,mandal,marker,marnardal,masfjorden,meland,meldal,melhus,meloy,meløy,meraker,meråker,moareke,moåreke,midsund,midtre-gauldal,modalen,modum,molde,moskenes,moss,mosvik,malselv,målselv,malatvuopmi,málatvuopmi,namdalseid,aejrie,namsos,namsskogan,naamesjevuemie,nååmesjevuemie,laakesvuemie,nannestad,narvik,narviika,naustdal,nedre-eiker,akershus(1:nes),buskerud(1:nes),nesna,nesodden,nesseby,unjarga,unjárga,nesset,nissedal,nittedal,nord-aurdal,nord-fron,nord-odal,norddal,nordkapp,davvenjarga,davvenjárga,nordre-land,nordreisa,raisa,ráisa,nore-og-uvdal,notodden,naroy,nærøy,notteroy,nøtterøy,odda,oksnes,øksnes,oppdal,oppegard,oppegård,orkdal,orland,ørland,orskog,ørskog,orsta,ørsta,hedmark(3:os,valer,våler),hordaland(1:os),osen,osteroy,osterøy,ostre-toten,østre-toten,overhalla,ovre-eiker,øvre-eiker,oyer,øyer,oygarden,øygarden,oystre-slidre,øystre-slidre,porsanger,porsangu,porsáŋgu,porsgrunn,radoy,radøy,rakkestad,rana,ruovat,randaberg,rauma,rendalen,rennebu,rennesoy,rennesøy,rindal,ringebu,ringerike,ringsaker,rissa,risor,risør,roan,rollag,rygge,ralingen,rælingen,rodoy,rødøy,romskog,rømskog,roros,røros,rost,røst,royken,røyken,royrvik,røyrvik,rade,råde,salangen,siellak,saltdal,salat,sálát,sálat,samnanger,vestfold(1:sande),sandefjord,sandnes,sandoy,sandøy,sarpsborg,sauda,sauherad,sel,selbu,selje,seljord,sigdal,siljan,sirdal,skaun,skedsmo,ski,skien,skiptvet,skjervoy,skjervøy,skierva,skiervá,skjak,skjåk,skodje,skanland,skånland,skanit,skánit,smola,smøla,snillfjord,snasa,snåsa,snoasa,snaase,snåase,sogndal,sokndal,sola,solund,songdalen,sortland,spydeberg,stange,stavanger,steigen,steinkjer,stjordal,stjørdal,stokke,stor-elvdal,stord,stordal,storfjord,omasvuotna,strand,stranda,stryn,sula,suldal,sund,sunndal,surnadal,sveio,svelvik,sykkylven,sogne,søgne,somna,sømna,sondre-land,søndre-land,sor-aurdal,sør-aurdal,sor-fron,sør-fron,sor-odal,sør-odal,sor-varanger,sør-varanger,matta-varjjat,mátta-várjjat,sorfold,sørfold,sorreisa,sørreisa,sorum,sørum,tana,deatnu,time,tingvoll,tinn,tjeldsund,dielddanuorri,tjome,tjøme,tokke,tolga,torsken,tranoy,tranøy,tromso,tromsø,tromsa,romsa,trondheim,troandin,trysil,trana,træna,trogstad,trøgstad,tvedestrand,tydal,tynset,tysfjord,divtasvuodna,divttasvuotna,tysnes,tysvar,tysvær,tonsberg,tønsberg,ullensaker,ullensvang,ulvik,utsira,vadso,vadsø,cahcesuolo,čáhcesuolo,vaksdal,valle,vang,vanylven,vardo,vardø,varggat,várggát,vefsn,vaapste,vega,vegarshei,vegårshei,vennesla,verdal,verran,vestby,vestnes,vestre-slidre,vestre-toten,vestvagoy,vestvågøy,vevelstad,vik,vikna,vindafjord,volda,voss,varoy,værøy,vagan,vågan,voagat,vagsoy,vågsøy,vaga,vågå,ostfold(1:valer),østfold(1:våler),co),np(1:*),nr(7:biz,info,gov,edu,org,net,com),nu(3:merseine,mine,shacknet),nz(1:*),om(11:*,mediaphone(1:!),nawrastelecom(1:!),nawras(1:!),omanmobile(1:!),omanpost(1:!),omantel(1:!),rakpetroleum(1:!),siemens(1:!),songfest(1:!),statecouncil(1:!)),org(53:ae,us,za,dyndns(2:go,home),blogdns,blogsite,boldlygoingnowhere,dnsalias,dnsdojo,doesntexist,dontexist,doomdns,dvrdns,dynalias,endofinternet,endoftheinternet,from-me,game-host,gotdns,hobby-site,homedns,homeftp,homelinux,homeunix,is-a-bruinsfan,is-a-candidate,is-a-celticsfan,is-a-chef,is-a-geek,is-a-knight,is-a-linux-user,is-a-patsfan,is-a-soxfan,is-found,is-lost,is-saved,is-very-bad,is-very-evil,is-very-good,is-very-nice,is-very-sweet,isa-geek,kicks-ass,misconfused,podzone,readmyblog,selfip,sellsyourhome,servebbs,serveftp,servegame,stuff-4-sale,webhop),pa(11:ac,gob,com,org,sld,edu,net,ing,abo,med,nom),pe(7:edu,gob,nom,mil,org,com,net),pf(3:com,org,edu),pg(1:*),ph(8:com,net,org,gov,edu,ngo,mil,i),pk(14:com,net,edu,org,fam,biz,web,gov,gob,gok,gon,gop,gos,info),pl(171:aid,agro,atm,auto,biz,com,edu,gmina,gsm,info,mail,miasta,media,mil,net,nieruchomosci,nom,org,pc,powiat,priv,realestate,rel,sex,shop,sklep,sos,szkola,targi,tm,tourism,travel,turystyka,6bone,art,mbone,gov(9:uw,um,ug,upow,starostwo,so,sr,po,pa),ngo,irc,usenet,augustow,babia-gora,bedzin,beskidy,bialowieza,bialystok,bielawa,bieszczady,boleslawiec,bydgoszcz,bytom,cieszyn,czeladz,czest,dlugoleka,elblag,elk,glogow,gniezno,gorlice,grajewo,ilawa,jaworzno,jelenia-gora,jgora,kalisz,kazimierz-dolny,karpacz,kartuzy,kaszuby,katowice,kepno,ketrzyn,klodzko,kobierzyce,kolobrzeg,konin,konskowola,kutno,lapy,lebork,legnica,lezajsk,limanowa,lomza,lowicz,lubin,lukow,malbork,malopolska,mazowsze,mazury,mielec,mielno,mragowo,naklo,nowaruda,nysa,olawa,olecko,olkusz,olsztyn,opoczno,opole,ostroda,ostroleka,ostrowiec,ostrowwlkp,pila,pisz,podhale,podlasie,polkowice,pomorze,pomorskie,prochowice,pruszkow,przeworsk,pulawy,radom,rawa-maz,rybnik,rzeszow,sanok,sejny,siedlce,slask,slupsk,sosnowiec,stalowa-wola,skoczow,starachowice,stargard,suwalki,swidnica,swiebodzin,swinoujscie,szczecin,szczytno,tarnobrzeg,tgory,turek,tychy,ustka,walbrzych,warmia,warszawa,waw,wegrow,wielun,wlocl,wloclawek,wodzislaw,wolomin,wroclaw,zachpomor,zagan,zarow,zgora,zgorzelec,gda,gdansk,gdynia,med,sopot,gliwice,krakow,poznan,wroc,zakopane,co),pm,pn(5:gov,co,org,edu,net),pr(13:com,net,org,gov,edu,isla,pro,biz,info,name,est,prof,ac),pro(7:aca,bar,cpa,jur,law,med,eng),ps(7:edu,gov,sec,plo,com,org,net),pt(8:net,gov,org,edu,int,publ,com,nome),pw(6:co,ne,or,ed,go,belau),py(1:*),qa(8:com,edu,gov,mil,name,net,org,sch),re(3:com,asso,nom),ro(11:com,org,tm,nt,nom,info,rec,arts,firm,store,www),rs(6:co,org,edu,ac,gov,in),ru(133:ac,com,edu,int,net,org,pp,adygeya,altai,amur,arkhangelsk,astrakhan,bashkiria,belgorod,bir,bryansk,buryatia,cbg,chel,chelyabinsk,chita,chukotka,chuvashia,dagestan,dudinka,e-burg,grozny,irkutsk,ivanovo,izhevsk,jar,joshkar-ola,kalmykia,kaluga,kamchatka,karelia,kazan,kchr,kemerovo,khabarovsk,khakassia,khv,kirov,koenig,komi,kostroma,krasnoyarsk,kuban,kurgan,kursk,lipetsk,magadan,mari,mari-el,marine,mordovia,mosreg,msk,murmansk,nalchik,nnov,nov,novosibirsk,nsk,omsk,orenburg,oryol,palana,penza,perm,pskov,ptz,rnd,ryazan,sakhalin,samara,saratov,simbirsk,smolensk,spb,stavropol,stv,surgut,tambov,tatarstan,tom,tomsk,tsaritsyn,tsk,tula,tuva,tver,tyumen,udm,udmurtia,ulan-ude,vladikavkaz,vladimir,vladivostok,volgograd,vologda,voronezh,vrn,vyatka,yakutia,yamal,yaroslavl,yekaterinburg,yuzhno-sakhalinsk,amursk,baikal,cmw,fareast,jamal,kms,k-uralsk,kustanai,kuzbass,magnitka,mytis,nakhodka,nkz,norilsk,oskol,pyatigorsk,rubtsovsk,snz,syzran,vdonsk,zgrad,gov,mil,test),rw(9:gov,net,edu,ac,com,co,int,mil,gouv),sa(8:com,net,org,gov,med,pub,edu,sch),sb(5:com,edu,gov,net,org),sc(5:com,gov,net,org,edu),sd(8:com,net,org,edu,med,tv,gov,info),se(40:a,ac,b,bd,brand,c,d,e,f,fh,fhsk,fhv,g,h,i,k,komforb,kommunalforbund,komvux,l,lanbib,m,n,naturbruksgymn,o,org,p,parti,pp,press,r,s,sshn,t,tm,u,w,x,y,z),sg(6:com,net,org,gov,edu,per),sh(5:com,net,gov,org,mil),si,sk,sl(5:com,net,edu,gov,org),sm,sn(7:art,com,edu,gouv,org,perso,univ),so(3:com,net,org),sr,st(12:co,com,consulado,edu,embaixada,gov,mil,net,org,principe,saotome,store),su,sv(1:*),sx(1:gov),sy(6:edu,gov,net,mil,com,org),sz(3:co,ac,org),tc,td,tel,tf,tg,th(7:ac,co,go,in,mi,net,or),tj(15:ac,biz,co,com,edu,go,gov,int,mil,name,net,nic,org,test,web),tk,tl(1:gov),tm(8:com,co,org,net,nom,gov,mil,edu),tn(20:com,ens,fin,gov,ind,intl,nat,net,org,info,perso,tourism,edunet,rnrt,rns,rnu,mincom,agrinet,defense,turen),to(6:com,gov,net,org,edu,mil),tr(3:*,nic(1:!),nc(1:gov)),travel,tt(17:co,com,org,net,biz,info,pro,int,coop,jobs,mobi,travel,museum,aero,name,gov,edu),tv(4:dyndns,better-than,on-the-web,worse-than),tw(13:edu,gov,mil,com,net,org,idv,game,ebiz,club,網路,組織,商業),tz(7:ac,co,go,mil,ne,or,sc),ua(78:com,edu,gov,in,net,org,cherkassy,cherkasy,chernigov,chernihiv,chernivtsi,chernovtsy,ck,cn,cr,crimea,cv,dn,dnepropetrovsk,dnipropetrovsk,dominic,donetsk,dp,if,ivano-frankivsk,kh,kharkiv,kharkov,kherson,khmelnitskiy,khmelnytskyi,kiev,kirovograd,km,kr,krym,ks,kv,kyiv,lg,lt,lugansk,lutsk,lv,lviv,mk,mykolaiv,nikolaev,od,odesa,odessa,pl,poltava,rivne,rovno,rv,sb,sebastopol,sevastopol,sm,sumy,te,ternopil,uz,uzhgorod,vinnica,vinnytsia,vn,volyn,yalta,zaporizhzhe,zaporizhzhia,zhitomir,zhytomyr,zp,zt,co,pp),ug(8:co,or,ac,sc,go,ne,com,org),uk(14:*,sch(1:*),bl(1:!),british-library(1:!),icnet(1:!),jet(1:!),mod(1:!),nel(1:!),nhs(1:!),nic(1:!),nls(1:!),national-library-scotland(1:!),parliament(1:!),police(1:!)),us(63:dni,fed,isa,kids,nsn,ak(3:k12,cc,lib),al(3:k12,cc,lib),ar(3:k12,cc,lib),as(3:k12,cc,lib),az(3:k12,cc,lib),ca(3:k12,cc,lib),co(3:k12,cc,lib),ct(3:k12,cc,lib),dc(3:k12,cc,lib),de(3:k12,cc,lib),fl(3:k12,cc,lib),ga(3:k12,cc,lib),gu(3:k12,cc,lib),hi(2:cc,lib),ia(3:k12,cc,lib),id(3:k12,cc,lib),il(3:k12,cc,lib),in(3:k12,cc,lib),ks(3:k12,cc,lib),ky(3:k12,cc,lib),la(3:k12,cc,lib),ma(3:k12(3:pvt,chtr,paroch),cc,lib),md(3:k12,cc,lib),me(3:k12,cc,lib),mi(3:k12,cc,lib),mn(3:k12,cc,lib),mo(3:k12,cc,lib),ms(3:k12,cc,lib),mt(3:k12,cc,lib),nc(3:k12,cc,lib),nd(3:k12,cc,lib),ne(3:k12,cc,lib),nh(3:k12,cc,lib),nj(3:k12,cc,lib),nm(3:k12,cc,lib),nv(3:k12,cc,lib),ny(3:k12,cc,lib),oh(3:k12,cc,lib),ok(3:k12,cc,lib),or(3:k12,cc,lib),pa(3:k12,cc,lib),pr(3:k12,cc,lib),ri(3:k12,cc,lib),sc(3:k12,cc,lib),sd(3:k12,cc,lib),tn(3:k12,cc,lib),tx(3:k12,cc,lib),ut(3:k12,cc,lib),vi(3:k12,cc,lib),vt(3:k12,cc,lib),va(3:k12,cc,lib),wa(3:k12,cc,lib),wi(3:k12,cc,lib),wv(3:k12,cc,lib),wy(3:k12,cc,lib),is-by,land-4-sale,stuff-4-sale),uy(6:com,edu,gub,mil,net,org),uz(4:co,com,net,org),va,vc(6:com,net,org,gov,mil,edu),ve(1:*),vg,vi(5:co,com,k12,net,org),vn(12:com,net,org,edu,gov,int,ac,biz,info,name,pro,health),vu,wf,ws(7:com,net,org,gov,edu,dyndns,mypets),yt,امارات,বাংলা,中国,中國,الجزائر,مصر,გე,香港,भारत,بھارت,భారత్,ભારત,ਭਾਰਤ,ভারত,இந்தியா,ایران,ايران,الاردن,한국,ලංකා,இலங்கை,المغرب,عمان,فلسطين,срб,рф,قطر,السعودية,السعودیة,السعودیۃ,السعوديه,سورية,سوريا,新加坡,சிங்கப்பூர்,ไทย,تونس,台灣,台湾,臺灣,укр,اليمن,xxx,ye(1:*),za(1:*),zm(1:*),zw(1:*))";
+"wchar_t tldString[] = {\r\n" + str.replace(/.{1,100}/g, function(s) "\t" + s.replace(/./g, "L'$&',") + "\r\n") + "L'\\0' };"
\ No newline at end of file
diff --git a/plugin/test/test.cpp b/plugin/test/test.cpp
new file mode 100644
index 0000000..120eb23
--- /dev/null
+++ b/plugin/test/test.cpp
@@ -0,0 +1,81 @@
+﻿/*
+This file is part of Fire-IE.
+
+Fire-IE is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Fire-IE is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Fire-IE.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "StdAfx.h"
+
+#ifdef DEBUG
+
+#include "test.h"
+#include "re/strutils.h"
+#include "re/RegExp.h"
+#include "Utils/TLD.h"
+
+using namespace std;
+using namespace re;
+using namespace re::strutils;
+using namespace Utils;
+
+namespace test {
+	void testReplace()
+	{
+		ASSERT(replace(L"abcdefghijklmn", wstring(L"/./"), L"*") == L"*bcdefghijklmn");
+		ASSERT(replace(L"abcdefghijklmn", wstring(L"/./g"), L"*") == L"**************");
+		ASSERT(replace(L"abcdefghijklmn", wstring(L"/[b-dk-m]/g"), L"*") == L"a***efghij***n");
+		ASSERT(replace(L"abcdefghijklmn", wstring(L"/nomatch/g"), L"*") == L"abcdefghijklmn");
+
+		ASSERT(replace(L"abcdefghijklmn", wstring(L"/(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)/"), L"$001") == L"a$001n");
+		ASSERT(replace(L"abcdefghijklmn", wstring(L"/(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)/"), L"$01") == L"abn");
+		ASSERT(replace(L"abcdefghijklmn", wstring(L"/(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)/"), L"$10") == L"akn");
+		ASSERT(replace(L"abcdefghijklmn", wstring(L"/(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)/"), L"$15") == L"ab5n");
+		ASSERT(replace(L"abcdefghijklmn", wstring(L"/(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)/"), L"$20") == L"ac0n");
+		ASSERT(replace(L"abcdefghijklmn", wstring(L"/(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)/"), L"$") == L"a$n");
+		ASSERT(replace(L"abcdefghijklmn", wstring(L"/(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)/"), L"$&") == L"abcdefghijklmn");
+		ASSERT(replace(L"abcdefghijklmn", wstring(L"/(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)/"), L"$`") == L"aan");
+		ASSERT(replace(L"abcdefghijklmn", wstring(L"/(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)/"), L"$'") == L"ann");
+		ASSERT(replace(L"abcdefghijklmn", wstring(L"/(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)/"), L"$$'") == L"a$'n");
+	}
+
+	void testTLD()
+	{
+		ASSERT(TLD::getEffectiveDomain(_T("")) == _T(""));
+		ASSERT(TLD::getEffectiveDomain(_T("addons.mozilla.org")) == _T("mozilla.org"));
+		ASSERT(TLD::getEffectiveDomain(_T("www.com.cn")) == _T("www.com.cn"));
+		ASSERT(TLD::getEffectiveDomain(_T("a.b.c.idontknow")) == _T("a.b.c.idontknow"));
+		ASSERT(TLD::getEffectiveDomain(_T("localhost")) == _T("localhost"));
+		ASSERT(TLD::getEffectiveDomain(_T("www.sjtu.ed.cn")) == _T("ed.cn"));
+		ASSERT(TLD::getEffectiveDomain(_T("www.sjtu.edu.cn")) == _T("sjtu.edu.cn"));
+		ASSERT(TLD::getEffectiveDomain(_T("www.sina.com.cn")) == _T("sina.com.cn"));
+		ASSERT(TLD::getEffectiveDomain(_T("co.uk")) == _T("co.uk"));
+		ASSERT(TLD::getEffectiveDomain(_T("bn.sjtu.info")) == _T("sjtu.info"));
+		ASSERT(TLD::getEffectiveDomain(_T("图书馆.上海交通大学.中国")) == _T("上海交通大学.中国"));
+		ASSERT(TLD::getEffectiveDomain(_T("www.lib.sjtu.edu.cn")) == _T("sjtu.edu.cn"));
+		ASSERT(TLD::getEffectiveDomain(_T("www.lib.sjtu.edu.cn.www.lib.sjtu.edu.cn.www.lib.sjtu.edu.cn")) == _T("sjtu.edu.cn"));
+		ASSERT(TLD::getEffectiveDomain(_T("a.b.c.d.e.f.g.h.i.j.k.l.m.n")) == _T("a.b.c.d.e.f.g.h.i.j.k.l.m.n"));
+		ASSERT(TLD::getEffectiveDomain(_T("..........")) == _T(".........."));
+		ASSERT(TLD::getEffectiveDomain(_T(".........com.cn")) == _T(".com.cn"));
+		ASSERT(TLD::getEffectiveDomain(_T("192.168.0.1")) == _T("192.168.0.1"));
+		ASSERT(TLD::getEffectiveDomain(_T("what.is.this.domain.اليمن")) == _T("domain.اليمن"));
+	}
+
+	void doTest()
+	{
+		testReplace();
+		testTLD();
+	}
+}
+
+#endif
diff --git a/plugin/test/test.h b/plugin/test/test.h
new file mode 100644
index 0000000..e0a81c2
--- /dev/null
+++ b/plugin/test/test.h
@@ -0,0 +1,26 @@
+/*
+This file is part of Fire-IE.
+
+Fire-IE is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Fire-IE is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Fire-IE.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+#ifdef DEBUG
+
+namespace test {
+	void doTest();
+}
+
+#endif
